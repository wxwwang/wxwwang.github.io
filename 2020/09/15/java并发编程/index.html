<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java并发编程 | 我的笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="[TOC] 进程1、程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备，进程就是用来加载指令、管理内存、管理IO的 2、当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 3、进程就可以视为成程序的一个实例，大部分程序可以同时运行对个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程">
<meta property="og:url" content="http://yoursite.com/2020/09/15/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="我的笔记">
<meta property="og:description" content="[TOC] 进程1、程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备，进程就是用来加载指令、管理内存、管理IO的 2、当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 3、进程就可以视为成程序的一个实例，大部分程序可以同时运行对个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/15/w6RGHU.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/15/w6Rob8.png">
<meta property="article:published_time" content="2020-09-15T07:47:19.713Z">
<meta property="article:modified_time" content="2020-09-15T12:58:44.630Z">
<meta property="article:author" content="我的笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/09/15/w6RGHU.png">
  
    <link rel="alternate" href="/atom.xml" title="我的笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">我的笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java并发编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/15/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2020-09-15T07:47:19.713Z" itemprop="datePublished">2020-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java并发编程
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>1、程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备，进程就是用来加载指令、管理内存、管理IO的</p>
<p>2、当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</p>
<p>3、进程就可以视为成程序的一个实例，大部分程序可以同时运行对个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360安全卫士等）</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>1、一个进程之内可以分为一到对个线程。</p>
<p>2、一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行。</p>
<p>3、在Java中，线程作为最小调度单位，进程作为资源分配的最小单位，在Windows中进程是不活动的，只是作为线程的容器。</p>
<h4 id="进程和线程的对比"><a href="#进程和线程的对比" class="headerlink" title="进程和线程的对比"></a>进程和线程的对比</h4><p>1、进程基本上相互独立的，而线程存在于进程内，是进程的一个子集。</p>
<p>2、进程拥有共享的资源，如内存空间等，供其内部的线程的线程共享。</p>
<p>3、进程间通信较为复杂</p>
<p>​        同一台计算机的进程通信称为IPC（Inter-process communication)。</p>
<p>​        不同计算机之间的进程通信，需要通过网络，并遵循共同的协议，例如HTTP。</p>
<p>4、线程通信相对简单，因为它们共享进程内的内存，一个例子是对个线程访问同一个共享变量。</p>
<p>5、线程更轻量，线程上下文切换成本一般上要比进程上下文切换低。</p>
<h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><p>一般会将线程轮流使用CPU的做法称为并发，concurrent  微观串行，宏观并行。</p>
<p>多核CPU下，每个核都可以调度运行线程，这时候线程可以是并行的。</p>
<p>*并发：是同一时间应对多件事情的能力。</p>
<p>*并行：是同一时间动手做多件事情的能力。</p>
<h4 id="创建线程的第一种方式"><a href="#创建线程的第一种方式" class="headerlink" title="创建线程的第一种方式"></a>创建线程的第一种方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;HelloWrold&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">&quot;HelloWrold&quot;</span>));</span><br><span class="line">        thread1.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建线程的第二种方式"><a href="#创建线程的第二种方式" class="headerlink" title="创建线程的第二种方式"></a>创建线程的第二种方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;HelloWrlod&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Runnable runnable1 = ()-&gt; System.out.println(<span class="string">&quot;HelloWrold&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable1);</span><br><span class="line">        thread1.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Thread-与-Runnable-的关系"><a href="#Thread-与-Runnable-的关系" class="headerlink" title="Thread 与 Runnable 的关系"></a>Thread 与 Runnable 的关系</h4><p>分析 Thread 的源码，理清它与 Runnable 的关系<br>小结<br> 1、方法一 是把线程和任务合并在了一起，方法二是把线程和任务分开了（推荐）<br> 2、用 Runnable 更容易与线程池等高级 API 配合<br> 3、用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</p>
<h4 id="创建线程的第三种方式"><a href="#创建线程的第三种方式" class="headerlink" title="创建线程的第三种方式"></a>创建线程的第三种方式</h4><p>FutureTask(Callable<V> callable)<br>创建一个 FutureTask ，它将在运行时执行给定的 Callable 。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;running....&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(task,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Integer integer = task.get();</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查看进程线程的方法"><a href="#查看进程线程的方法" class="headerlink" title="查看进程线程的方法"></a>查看进程线程的方法</h4><p>windows</p>
<p>*任务管理器可以查看进程和线程数，也可以用来杀死进程</p>
<p>*tasklist 查看进程（tasklist | findstr java）<br>*taskkill 杀死进程 （taskkill /F /PID 15920）</p>
<p>linux<br> *ps -fe 查看所有进程(ps -fe | grep java)<br> *ps -fT -p 查看某个进程（PID）的所有线程</p>
<p>*kill 杀死进程</p>
<p>*top 按大写 H 切换是否显示线程</p>
<p>*top -H -p 查看某个进程（PID）的所有线程<br>Java</p>
<p>*jps 命令查看所有 Java 进程</p>
<p>*jstack 查看某个 Java 进程（PID）的所有线程状态<br>*jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</p>
<h4 id="jconsole-远程监控配置"><a href="#jconsole-远程监控配置" class="headerlink" title="jconsole 远程监控配置"></a>jconsole 远程监控配置</h4><p>*需要以如下方式运行你的 java 类<br>java -Djava.rmi.server.hostname=<code>ip地址</code> -Dcom.sun.management.jmxremote -<br>Dcom.sun.management.jmxremote.port=<code>连接端口</code> -Dcom.sun.management.jmxremote.ssl=是否安全连接 -<br>Dcom.sun.management.jmxremote.authenticate=是否认证 java类<br> *修改 /etc/hosts 文件将 127.0.0.1 映射至主机名<br>如果要认证访问，还需要做如下步骤</p>
<p>*复制 jmxremote.password 文件</p>
<p>*修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写</p>
<p>*连接时填入 controlRole（用户名），R&amp;D（密码）</p>
<h4 id="原理之线程运行"><a href="#原理之线程运行" class="headerlink" title="原理之线程运行"></a>原理之线程运行</h4><p>栈与栈帧<br>Java Virtual Machine Stacks （Java 虚拟机栈）<br>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟<br>机就会为其分配一块栈内存。<br> *每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存<br> *每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p>
<h4 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码<br> *线程的 cpu 时间片用完<br> *垃圾回收（此时会停止所有的工作进程）<br> *有更高优先级的线程需要运行<br>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法<br>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念<br>就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的<br> *状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等<br> *Context Switch 频繁发生会影响性能</p>
<h4 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w6RGHU"><img src="https://s1.ax1x.com/2020/09/15/w6RGHU.png" alt="w6RGHU.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w6Rob8"><img src="https://s1.ax1x.com/2020/09/15/w6Rob8.png" alt="w6Rob8.png"></a></p>
<h4 id="start与run"><a href="#start与run" class="headerlink" title="start与run"></a>start与run</h4><p>直接调用 run 是在主线程中执行了 run，没有启动新的线程，为普通的方法调用。<br> 使用 start 是启动新的线程，这样虚拟机才会把这个thread与操作系统的线程 一 一对应，通过新的线程间接执行 run 中的代码。</p>
<h4 id="sleep与yield"><a href="#sleep与yield" class="headerlink" title="sleep与yield"></a>sleep与yield</h4><p>sleep:</p>
<p>1、调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）<br>2、其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException<br>3、睡眠结束后的线程未必会立刻得到执行(等待任务调度器分配时间片)<br>4、建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p>
<p>yield:</p>
<p>1、调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程<br>2、具体的实现依赖于操作系统的任务调度器</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/15/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" data-id="ckf3z463h0007nkvw7co903ua" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/09/14/%E7%BC%93%E5%86%B2%E6%B5%81%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">缓冲流、转换流</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/15/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a>
          </li>
        
          <li>
            <a href="/2020/09/14/%E7%BC%93%E5%86%B2%E6%B5%81%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81/">缓冲流、转换流</a>
          </li>
        
          <li>
            <a href="/2020/09/14/IO%E6%B5%81/">IO流</a>
          </li>
        
          <li>
            <a href="/2020/09/13/File/">File类、</a>
          </li>
        
          <li>
            <a href="/2020/09/13/%E6%B7%B1%E5%85%A5%E7%BA%BF%E7%A8%8B/">深入线程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 我的笔记<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>