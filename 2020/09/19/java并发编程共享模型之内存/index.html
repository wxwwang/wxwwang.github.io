<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>java并发编程共享模型之内存 | 我的笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="[TOC] java并发编程共享模型之内存之前的入门篇主要讲解的Monitor主要关注的是访问共享变量时，保证临界区代码的原子性，本文我们将进一步深入学习共享变量在多线程间的【可见性】问题与多条指令执行时的【有序性】问题。 Java 内存模型JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等 JVM体现在以">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发编程共享模型之内存">
<meta property="og:url" content="http://yoursite.com/2020/09/19/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="我的笔记">
<meta property="og:description" content="[TOC] java并发编程共享模型之内存之前的入门篇主要讲解的Monitor主要关注的是访问共享变量时，保证临界区代码的原子性，本文我们将进一步深入学习共享变量在多线程间的【可见性】问题与多条指令执行时的【有序性】问题。 Java 内存模型JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等 JVM体现在以">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/19/wIBtbt.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/19/wIB0PS.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/19/wIByKs.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/20/woTGwV.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/20/woTtFU.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/20/woTUW4.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/20/woTwl9.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/20/woTgYD.png">
<meta property="article:published_time" content="2020-09-19T09:52:17.300Z">
<meta property="article:modified_time" content="2020-09-20T05:07:18.544Z">
<meta property="article:author" content="我的笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/09/19/wIBtbt.png">
  
    <link rel="alternate" href="/atom.xml" title="我的笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">我的笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java并发编程共享模型之内存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/19/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98/" class="article-date">
  <time datetime="2020-09-19T09:52:17.300Z" itemprop="datePublished">2020-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java并发编程共享模型之内存
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="java并发编程共享模型之内存"><a href="#java并发编程共享模型之内存" class="headerlink" title="java并发编程共享模型之内存"></a>java并发编程共享模型之内存</h1><p>之前的入门篇主要讲解的Monitor主要关注的是访问共享变量时，保证临界区代码的<strong>原子性</strong>，本文我们将进一步深入学习共享变量在多线程间的【<strong>可见性</strong>】问题与多条指令执行时的【<strong>有序性</strong>】问题。</p>
<h4 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a><strong>Java 内存模型</strong></h4><p>JMM 即 Java Memory Model，它定义了<strong>主存、工作内存</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等</p>
<p>JVM体现在以下几个方面</p>
<ul>
<li>原子性-保证指令不会受到线程上下文切换的影响</li>
<li>可见性-保证指令不会受到CPU缓存的影响</li>
<li>有序性-保证指令不会受到CPU指令并行优化的影响</li>
</ul>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h4 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h4><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> 	Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">	 	<span class="keyword">while</span>(run)&#123;</span><br><span class="line">	 	<span class="comment">// ....</span></span><br><span class="line">	 	&#125;</span><br><span class="line"> 	&#125;);</span><br><span class="line"> 	t.start();</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line"> 	run = <span class="keyword">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为什么呢？分析一下：</p>
<p>1、初始状态， t 线程刚开始从<strong>主内存</strong>读取了 run 的值到<strong>工作内存</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wIBtbt"><img src="https://s1.ax1x.com/2020/09/19/wIBtbt.png" alt="wIBtbt.png"></a></p>
<p>2、因为 t 线程要频繁从主内存中读取 run 的值，JIT 即时编译器会将 run 的值缓存至自己工作内存中的<strong>高速缓存</strong>中，减少对主存中 run 的访问，提高效率。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wIB0PS"><img src="https://s1.ax1x.com/2020/09/19/wIB0PS.png" alt="wIB0PS.png"></a></p>
<p>3、1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wIByKs"><img src="https://s1.ax1x.com/2020/09/19/wIByKs.png" alt="wIByKs.png"></a></p>
<p><strong>解决方法</strong></p>
<p><strong>volatile（易变关键字）</strong><br>   它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，<strong>线程操作 volatile 变量都是直接操作主存。</strong></p>
<p><strong>可见性 vs 原子性</strong><br>   前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， <strong>不能保证原子性</strong>，仅用在<strong>一个写线程，多个读线程</strong>的情况： 上例从字节码理解是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true </span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true </span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true </span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true </span></span><br><span class="line">putstatic run <span class="comment">// 线程 main 修改 run 为 false， 仅此一次</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run false</span></span><br></pre></td></tr></table></figure>

<p>比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到最新值，<strong>不能解决指令交错。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设i的初始值为0 </span></span><br><span class="line">getstatic i <span class="comment">// 线程2-获取静态变量i的值 线程内i=0 </span></span><br><span class="line">getstatic i <span class="comment">// 线程1-获取静态变量i的值 线程内i=0 </span></span><br><span class="line">iconst_1 <span class="comment">// 线程1-准备常量1 </span></span><br><span class="line">iadd <span class="comment">// 线程1-自增 线程内i=1 </span></span><br><span class="line">putstatic i <span class="comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1 </span></span><br><span class="line">iconst_1 <span class="comment">// 线程2-准备常量1 </span></span><br><span class="line">isub <span class="comment">// 线程2-自减 线程内i=-1 </span></span><br><span class="line">putstatic i <span class="comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> <strong>synchronized</strong> 语句块<strong>既可以保证代码块的原子性，也同时保证代码块内变量的可见性</strong>。但缺点是synchronized 是属于重量级操作，性能相对更低。</p>
<p>如果在前面示例的死循环中加入 <strong>System.out.println()</strong> 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？<br> <strong>答</strong>：因为System.out.println()底层加了synchronize锁从而保证了可见性。</p>
<p><strong>模式之两阶段终止(volatile改进）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TwoPhaseTermination twoPhaseTermination = <span class="keyword">new</span> TwoPhaseTermination();</span><br><span class="line">        twoPhaseTermination.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        twoPhaseTermination.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseTermination</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        monitor= <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;执行监控日志&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭线程监控</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步模式之Balking"><a href="#同步模式之Balking" class="headerlink" title="同步模式之Balking"></a>同步模式之Balking</h4><p>Balking（犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需在做了，直接结束返回。</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TwoPhaseTermination tpt = <span class="keyword">new</span> TwoPhaseTermination();</span><br><span class="line">        tpt.start();</span><br><span class="line">        tpt.start();</span><br><span class="line">        tpt.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;停止监控&quot;</span>);</span><br><span class="line">        tpt.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseTermination</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread monitorThread;</span><br><span class="line">    <span class="comment">// 停止标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;  <span class="comment">//设置成volatile 因为只有一个线程对stop进行操作</span></span><br><span class="line">    <span class="comment">// 判断是否执行过 start 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> starting = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;    <span class="comment">//需要加锁防止多个线程同时改变starting状态</span></span><br><span class="line">            <span class="keyword">if</span> (starting) &#123; <span class="comment">// false</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        monitorThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Thread current = Thread.currentThread();</span><br><span class="line">                <span class="comment">// 是否被打断</span></span><br><span class="line">                <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行监控记录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;monitor&quot;</span>);</span><br><span class="line">        monitorThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">        monitorThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行监控记录</span><br><span class="line">执行监控记录</span><br><span class="line">执行监控记录</span><br><span class="line">停止监控</span><br><span class="line">料理后事</span><br></pre></td></tr></table></figure>

<h3 id="有序性—–指令重排序"><a href="#有序性—–指令重排序" class="headerlink" title="有序性—–指令重排序"></a>有序性—–指令重排序</h3><h4 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h4><p>现代CPU支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为五级指令流水线。这时CPU可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。</p>
<p><strong>提示</strong></p>
<p>奔腾四(Pentiium4)支持高达35级流水线，但由于功耗太高被废弃。</p>
<h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a><strong>volatile原理</strong></h3><p>1、volatile保证可见性原理</p>
<p>volatile 的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）<br>   ● 对 volatile 变量的<strong>写指令后</strong>会加入<strong>写屏障</strong><br>   ● 对 volatile 变量的<strong>读指令前</strong>会加入<strong>读屏障</strong></p>
<p>(1) 如何保证可见性</p>
<p>  ● 写屏障（sfence）保证在该屏障<strong>之前</strong>的，对<strong>共享变量的改动</strong>，都<strong>同步到主存</strong>当中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">	 num = <span class="number">2</span>;</span><br><span class="line">	 ready = <span class="keyword">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">	 <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ● 而读屏障（lfence）保证在<strong>该屏障之后</strong>，对共享变量的读取，<strong>加载的是主存中最新数据</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 读屏障</span></span><br><span class="line">	 <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">	 <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">		 r.r1 = num + num;</span><br><span class="line">		 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		 r.r1 = <span class="number">1</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）如何保证有序性</p>
<p>  ● 写屏障会确保指令重排序时，<strong>不会将写屏障之前的代码排在写屏障之后</strong><br>   ●读屏障会确保指令重排序时，不<strong>会将读屏障之后的代码排在读屏障之前</strong></p>
<p><strong>不能解决指令交错：</strong></p>
<ul>
<li>写屏障仅仅是保证之后地读能读到最新地结果，但不能保证读跑到他前面去</li>
<li>而有序性地保证也只是保证了本线程内相关代码不被重排序</li>
</ul>
<p><strong>（3）. double-checked locking 问题</strong></p>
<p>以著名的 double-checked locking 单例模式为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">	 <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		 <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">		 <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">		 <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">			 <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">			 	INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">			 &#125; </span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">return</span> INSTANCE;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以上地实现特点是</strong></p>
<ul>
<li>懒惰实例化</li>
<li>首次使用getInstance()才使用synchronized加锁，后继使用时才需加锁</li>
<li>有隐含地，但很关键地一点：第一个if使用了INSTANCE变量，是在同步块之外</li>
</ul>
<p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0: getstatic #2 &#x2F;&#x2F; Field INSTANCE:Lcn&#x2F;itcast&#x2F;n5&#x2F;Singleton;</span><br><span class="line">3: ifnonnull 37</span><br><span class="line">6: ldc #3 &#x2F;&#x2F; class cn&#x2F;itcast&#x2F;n5&#x2F;Singleton</span><br><span class="line">8: dup   &#x2F;&#x2F;复制对象的指针用于后面解锁</span><br><span class="line">9: astore_0</span><br><span class="line">10: monitorenter</span><br><span class="line">11: getstatic #2 &#x2F;&#x2F; Field INSTANCE:Lcn&#x2F;itcast&#x2F;n5&#x2F;Singleton;</span><br><span class="line">14: ifnonnull 27</span><br><span class="line">17: new #3 &#x2F;&#x2F; class cn&#x2F;itcast&#x2F;n5&#x2F;Singleton</span><br><span class="line">20: dup</span><br><span class="line">21: invokespecial #4 &#x2F;&#x2F; Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">24: putstatic #2 &#x2F;&#x2F; Field INSTANCE:Lcn&#x2F;itcast&#x2F;n5&#x2F;Singleton;</span><br><span class="line">27: aload_0</span><br><span class="line">28: monitorexit</span><br><span class="line">29: goto 37</span><br><span class="line">32: astore_1</span><br><span class="line">33: aload_0</span><br><span class="line">34: monitorexit</span><br><span class="line">35: aload_1</span><br><span class="line">36: athrow</span><br><span class="line">37: getstatic #2 &#x2F;&#x2F; Field INSTANCE:Lcn&#x2F;itcast&#x2F;n5&#x2F;Singleton;</span><br><span class="line">40: areturn</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>17表示创建对象，将对象引用入栈//new Singlenton</li>
<li>20表示复制一份对象引用//引用地址</li>
<li>21表示利用一个对象引用，调用构造方法</li>
<li>24表示利用一个对象引用，赋值给 static INSTANCE</li>
</ul>
<p>也许jvm会优化为：先执行24，在执行21.</p>
<p>关键在于0：getstatic这行代码在monitor控制外，它就像之前举例中不守规矩的人，可以越过monitor读取INSTANCE变量的值</p>
<p>这时t1还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么t2拿到的是将是一个未初始化完毕的单例</p>
<p>对INSTANCE使用volatile修饰即可，可以禁用指令重排，但要注意JDK5以上的版本的volatile才会真正有效</p>
<p><strong>double-checked locking 解决</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">	 <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 实例没创建，才会进入内部的 synchronized代码块</span></span><br><span class="line">		 <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; </span><br><span class="line">			 <span class="keyword">synchronized</span> (Singleton.class) &#123; // t2</span><br><span class="line">				 <span class="comment">// 也许有其它线程已经创建实例，所以再判断一次</span></span><br><span class="line">				 <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">				 	INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">			 	&#125;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	 	<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上解决了：<br> ① 使用synchronized 对Singleton.class进行了加<strong>synchronized</strong> 锁，解决了多个线程访问到 INSTANCE = new Singleton();会创建多个单例了。<br> ② 对Singleton实例INSTANCE 加了<strong>volatile</strong>关键字从而保证不会指令重排。</p>
<p><strong>小结：\</strong>① synchronized 既能保证**原子性、可见性、有序性<strong>，其中</strong>有序性<strong>是在该共享变量</strong>完全被synchronized 所接管<strong>（包括共享变量的读写操作），上面的例子中synchronized 外面的 if (INSTANCE == null) 中的INSTANCE读操作没有被synchronized 接管，因此无法保证INSTANCE共享变量的有序性（即不能防止指令重排）。<br>    ② 对共享变量加volatile关键字可以保证</strong>可见性<strong>和</strong>有序性<strong>，但是</strong>不能保证原子性**（即不能防止指令交错）。</p>
<ul>
<li><p>可见性</p>
<ul>
<li>写屏障保证在该屏障之前的t1对共享变量的改动，都同步到主存当中</li>
<li>而写屏障保证在该屏障之后t2对共享变量的读取，加载的是主存中最新数据</li>
</ul>
</li>
<li><p>有序性</p>
<ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在写屏障之前</li>
</ul>
</li>
<li><p>更底层是读写变量时使用lock指令来多核CPU之间的可见性与有序性</p>
</li>
</ul>
<p><strong>(4) happens-before</strong></p>
<p>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是<strong>可见性与有序性的一套规则总结</strong>，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见。 </p>
<p>● 线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> Object m = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">	 <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">	 x = <span class="number">10</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">	 <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">	 System.out.println(x);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> 	x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> 	System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>线程 start 前对变量的写，对该线程开始后对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x; x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> 	System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> 	x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">	t1.start();</span><br><span class="line">	t1.join();</span><br><span class="line">	System.out.println(x)</span><br></pre></td></tr></table></figure>

<p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">		<span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">		sout(x);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">	t2.start();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		x = <span class="number">10</span>;</span><br><span class="line">		t2.interrupt();</span><br><span class="line">	&#125;.<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">	<span class="keyword">while</span>(!t2.isInterrupted())&#123;</span><br><span class="line">		Thread.yield();</span><br><span class="line">	&#125;</span><br><span class="line">	sout(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">	y = <span class="number">10</span>;</span><br><span class="line">	x = <span class="number">20</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">	<span class="comment">//x = 20 对t2可见，同时 y = 10也对t2可见</span></span><br><span class="line">	sout(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p><strong>习题</strong></p>
<p><strong>balking模式习题</strong></p>
<p>希望doInit()方法被调用一次，下面的实现是否有问题，为什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span></span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(initialized)&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		doInit();</span><br><span class="line">		initialized = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInIT</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该使用同步代码块将被有读写操作的数据保护起来。</p>
<p><strong>(4) 线程安全单例习题</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/woTGwV"><img src="https://s1.ax1x.com/2020/09/20/woTGwV.png" alt="woTGwV.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/woTtFU"><img src="https://s1.ax1x.com/2020/09/20/woTtFU.png" alt="woTtFU.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/woTUW4"><img src="https://s1.ax1x.com/2020/09/20/woTUW4.png" alt="woTUW4.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/woTwl9"><img src="https://s1.ax1x.com/2020/09/20/woTwl9.png" alt="woTwl9.png"></a></p>
<h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/woTgYD"><img src="https://s1.ax1x.com/2020/09/20/woTgYD.png" alt="woTgYD.png"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/19/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98/" data-id="ckfb6v613000sxcvwalyh8kt7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/09/20/%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8BCAS%E6%97%A0%E9%94%81%EF%BC%88%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%89/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          共享模型之CAS无锁（乐观锁，非阻塞）
        
      </div>
    </a>
  
  
    <a href="/2020/09/19/ReentrantLock/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ReentrantLock</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/20/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98/">java并发编程共享模型之不可变</a>
          </li>
        
          <li>
            <a href="/2020/09/20/%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8BCAS%E6%97%A0%E9%94%81%EF%BC%88%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%89/">共享模型之CAS无锁（乐观锁，非阻塞）</a>
          </li>
        
          <li>
            <a href="/2020/09/19/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98/">java并发编程共享模型之内存</a>
          </li>
        
          <li>
            <a href="/2020/09/19/ReentrantLock/">ReentrantLock</a>
          </li>
        
          <li>
            <a href="/2020/09/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/">Java并发编程共享模型之管程（二）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 我的笔记<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>