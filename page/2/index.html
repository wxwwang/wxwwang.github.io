<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>我的笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="我的笔记">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="我的笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="我的笔记">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="我的笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">我的笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java并发编程共享模型之工具(二)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/22/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7(%E4%BA%8C)/" class="article-date">
  <time datetime="2020-09-22T00:28:59.977Z" itemprop="datePublished">2020-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/22/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7(%E4%BA%8C)/">java并发编程共享模型之工具(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="java并发编程共享模型之工具-二"><a href="#java并发编程共享模型之工具-二" class="headerlink" title="java并发编程共享模型之工具(二)"></a>java并发编程共享模型之工具(二)</h1><h4 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h4><p>在任务调度线程池功能加入之前，可以使用java.uti.Timer来实现定时功能，Timer的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是穿行执行的，同一时间只能由一个任务执行，前一个任务的延迟或异常都将会影响到之后的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        TimerTask task = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;task1......&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        TimerTask task1 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;task2....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">        <span class="comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span></span><br><span class="line">        timer.schedule(task,<span class="number">1000</span>);</span><br><span class="line">        timer.schedule(task1,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 ScheduledExecutorService 改写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutorServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;begin...&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="comment">// 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">        pool.schedule(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task1.....&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        pool.schedule(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task1.....&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        &#125;,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin...Tue Sep <span class="number">22</span> <span class="number">08</span>:<span class="number">48</span>:<span class="number">39</span> CST <span class="number">2020</span></span><br><span class="line">task1.....Tue Sep <span class="number">22</span> <span class="number">08</span>:<span class="number">48</span>:<span class="number">40</span> CST <span class="number">2020</span></span><br><span class="line">task1.....Tue Sep <span class="number">22</span> <span class="number">08</span>:<span class="number">48</span>:<span class="number">40</span> CST <span class="number">2020</span></span><br></pre></td></tr></table></figure>

<p>scheduleAtFixedRate 例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">scheduleAtFixedRateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;bengin....&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        pool.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task1...&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bengin....Tue Sep 22 08:54:35 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:54:36 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:54:37 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:54:38 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:54:39 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:54:40 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:54:41 CST 2020</span><br></pre></td></tr></table></figure>

<p>scheduleAtFixedRate 例子（任务执行时间超过了间隔时间）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">scheduleAtFixedRateTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;bengin....&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        pool.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task1...&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出分析：一开始，延时 1s，接下来，由于任务执行时间 &gt; 间隔时间，间隔被『撑』到了 2s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bengin....Tue Sep 22 08:58:03 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:58:04 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:58:06 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:58:08 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:58:10 CST 2020</span><br></pre></td></tr></table></figure>

<p>scheduleWithFixedDelay 例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleWithFixedDelayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot;bengin....&quot;</span>);</span><br><span class="line">        pool.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot;task....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束 &lt;-&gt; 延时 &lt;-&gt; 下一个任务开始 所 以间隔都是 3s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tue Sep 22 09:03:09 CST 2020bengin....</span><br><span class="line">Tue Sep 22 09:03:10 CST 2020task....</span><br><span class="line">Tue Sep 22 09:03:13 CST 2020task....</span><br><span class="line">Tue Sep 22 09:03:16 CST 2020task....</span><br><span class="line">Tue Sep 22 09:03:19 CST 2020task....</span><br></pre></td></tr></table></figure>

<p><strong>评价</strong></p>
<p>整个线程池变现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也会被释放。用来执行延迟或反复执行的任务。</p>
<h4 id="正确处理执行任务异常"><a href="#正确处理执行任务异常" class="headerlink" title="正确处理执行任务异常"></a>正确处理执行任务异常</h4><p>方法1：主动捉异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;error:&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>方法2：使用 Future</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">log.debug(<span class="string">&quot;result:&#123;&#125;&quot;</span>, f.get());</span><br></pre></td></tr></table></figure>

<h4 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h4><p>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型 运算</p>
<p>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计 算，如归并排序、斐波那契数列、都可以用分治思想进行求解</p>
<p>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运 算效率</p>
<p>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池</p>
<p><strong>使用</strong></p>
<p>提交给Fork/Join 线程池的任务需要继承RecursiveTask(有返回值)或RecursiveAction(没有返回值)，例如下面定义了一个对1-N之间的整数求和的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        System.out.println(forkJoinPool.invoke(<span class="keyword">new</span> AddTask(<span class="number">5</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddTask</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AddTask&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;n=&quot;</span> + n +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 n 已经为 1，可以求得结果了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;join&quot;</span> + n);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将任务进行拆分(fork)</span></span><br><span class="line">        AddTask t1 = <span class="keyword">new</span> AddTask(n - <span class="number">1</span>);</span><br><span class="line">        t1.fork();</span><br><span class="line">        System.out.println(<span class="string">&quot;fork&quot;</span> + n + t1);</span><br><span class="line">        <span class="comment">// 合并(join)结果</span></span><br><span class="line">        <span class="keyword">int</span> result = n + t1.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;join&quot;</span> + n + t1 + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fork5AddTask&#123;n&#x3D;4&#125;</span><br><span class="line">fork4AddTask&#123;n&#x3D;3&#125;</span><br><span class="line">fork3AddTask&#123;n&#x3D;2&#125;</span><br><span class="line">fork2AddTask&#123;n&#x3D;1&#125;</span><br><span class="line">join1</span><br><span class="line">join2AddTask&#123;n&#x3D;1&#125;3</span><br><span class="line">join3AddTask&#123;n&#x3D;2&#125;6</span><br><span class="line">join4AddTask&#123;n&#x3D;3&#125;10</span><br><span class="line">join5AddTask&#123;n&#x3D;4&#125;15</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<h4 id="J-U-C"><a href="#J-U-C" class="headerlink" title="J.U.C"></a>J.U.C</h4><h4 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h4><p>**概述 **</p>
<p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p>
<p>特点：</p>
<ul>
<li><p>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取 锁和释放锁 </p>
<ul>
<li>getState - 获取 state 状态</li>
<li>setState - 设置 state 状态 </li>
<li>compareAndSetState - cas 机制设置 state 状态 </li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li><p>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList </p>
</li>
<li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet  </p>
</li>
</ul>
<p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p>
<ul>
<li>tryAcquire</li>
<li>tryRelease</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared </li>
<li>isHeldExclusively</li>
</ul>
<p>获取锁的姿势</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果锁获取失败</span></span><br><span class="line"><span class="keyword">if</span>(!tryAcquire(arg))&#123;</span><br><span class="line">	<span class="comment">//入队，可以选择阻塞当前线程  park  unpark</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放锁的姿势</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span>(tryRelease(arg))&#123;</span><br><span class="line">	<span class="comment">//让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReentrantLock-原理"><a href="#ReentrantLock-原理" class="headerlink" title="ReentrantLock 原理"></a>ReentrantLock 原理</h4><h5 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h5><p><strong>加锁解锁流程</strong></p>
<p>先从构造器开始看，默认为非公平锁实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NonfairSync继承自AQS</p>
<p>没有竞争时</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wX8R8U"><img src="https://s1.ax1x.com/2020/09/22/wX8R8U.png" alt="wX8R8U.png"></a></p>
<p>第一次竞争出现时</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wX84KJ"><img src="https://s1.ax1x.com/2020/09/22/wX84KJ.png" alt="wX84KJ.png"></a></p>
<p>Thread-1 执行了</p>
<ol>
<li>CAS 尝试将 state 由 0 改为 1，结果失败 </li>
<li>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败 </li>
<li>接下来进入 addWaiter 逻辑，构造 Node 队列 <ul>
<li>图中黄色三角表示该 </li>
<li>Node 的 waitStatus 状态，其中 0 为默认正常状态 Node 的创建是懒惰的</li>
<li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wX8O2D"><img src="https://s1.ax1x.com/2020/09/22/wX8O2D.png" alt="wX8O2D.png"></a></p>
<p>当前线程进入 acquireQueued 逻辑 </p>
<ol>
<li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞 </li>
<li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li>
<li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wXGCIP"><img src="https://s1.ax1x.com/2020/09/22/wXGCIP.png" alt="wXGCIP.png"></a></p>
<ol start="4">
<li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li>
<li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true </li>
<li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wXGkRS"><img src="https://s1.ax1x.com/2020/09/22/wXGkRS.png" alt="wXGkRS.png"></a></p>
<p>再次有多个线程经历上述过程竞争失败，变成这个样子</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wXGuaq"><img src="https://s1.ax1x.com/2020/09/22/wXGuaq.png" alt="wXGuaq.png"></a></p>
<p>Thread-0 释放锁，进入 tryRelease 流程，如果成功 </p>
<ul>
<li>设置 exclusiveOwnerThread 为 null </li>
<li>state = 0</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wXGJsJ"><img src="https://s1.ax1x.com/2020/09/22/wXGJsJ.png" alt="wXGJsJ.png"></a></p>
<p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程 </p>
<p>找到队列中离 head 近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1</p>
<p>回到 Thread-1 的 acquireQueued 流程</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wXGDzD"><img src="https://s1.ax1x.com/2020/09/22/wXGDzD.png" alt="wXGDzD.png"></a></p>
<p>如果加锁成功（没有竞争），会设置</p>
<ul>
<li>exclusiveOwnerThread 为 Thread-1，state = 1 </li>
<li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread </li>
<li>原本的 head 因为从链表断开，而可被垃圾回收</li>
</ul>
<p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wXGbes"><img src="https://s1.ax1x.com/2020/09/22/wXGbes.png" alt="wXGbes.png"></a></p>
<p>如果不巧又被 Thread-4 占了先</p>
<ul>
<li>Thread-4 被设置为 exclusiveOwnerThread，state = 1</li>
<li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞 </li>
</ul>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>**ReentrantReadWriteLock **</p>
<p>当读操作远远高于写操作时，这时候使用读写锁让读-读可以并发，提高性能。类似于数据库中的 select … from … lock in share mode</p>
<p>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DataContainer dataContainer = <span class="keyword">new</span> DataContainer();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            dataContainer.read();</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            dataContainer.read();</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rw = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.ReadLock r = rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.WriteLock w = rw.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取读锁...&quot;</span>);</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;释放读锁...&quot;</span>);</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取写锁...&quot;</span>);</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;写入&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;释放写锁...&quot;</span>);</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果，从输出结果看到线程一锁定期间，线程2的读操作不受影响</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取读锁...</span><br><span class="line">获取读锁...</span><br><span class="line">读取</span><br><span class="line">读取</span><br><span class="line">释放读锁...</span><br><span class="line">释放读锁...</span><br></pre></td></tr></table></figure>

<p>测试 读锁-写锁 相互阻塞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DataContainer dataContainer = <span class="keyword">new</span> DataContainer();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    dataContainer.write();</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>写锁-写锁 也是相互阻塞的</p>
<p><strong>注意事项</strong></p>
<ul>
<li>读锁不支持条件变量</li>
<li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    r.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重入降级支持：即持有写锁的情况下去获取读锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line"><span class="comment">// 是否有效，如果失效，需要重新计算</span></span><br><span class="line">    data</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取写锁前必须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = ...</span><br><span class="line">                    cacheValid = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span></span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     <span class="comment">// 自己用完数据, 释放读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**StampedLock **</p>
<p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p>
<p>加解读锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.readLock(); </span><br><span class="line">lock.unlockRead(stamp);</span><br></pre></td></tr></table></figure>

<p>加解写锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.writeLock(); </span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure>

<p>乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通 过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line"><span class="comment">// 锁升级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>StampedLock 不支持条件变量</li>
<li>StampedLock 不支持可重入</li>
</ul>
<p>**Semaphore **</p>
<p>基本使用</p>
<p>信号量，用来限制能同时访问共享资源的线程上限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建 semaphore 对象 </span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 3. 获取许可 </span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                    sleep(<span class="number">1</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 4. 释放许可         </span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">07:35:15.485 c.TestSemaphore [Thread-2] - running...</span><br><span class="line">07:35:15.485 c.TestSemaphore [Thread-1] - running...</span><br><span class="line">07:35:15.485 c.TestSemaphore [Thread-0] - running...</span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-2] - end...</span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-0] - end... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-1] - end...</span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-3] - running... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-5] - running...</span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-4] - running... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-5] - end... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-4] - end... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-3] - end... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-6] - running...</span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-7] - running...</span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-9] - running... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-6] - end...</span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-7] - end... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-9] - end... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-8] - running...</span><br><span class="line">07:35:19.492 c.TestSemaphore [Thread-8] - end...</span><br></pre></td></tr></table></figure>

<h4 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h4><p>用来进行线程同步协作，等待所有线程完成倒计时。</p>
<p>其中构造参数用来初始化等待计数值，await（）用来等待计数归零，countDown（）用来让计数减一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line"> </span><br><span class="line">    log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    latch.await(); </span><br><span class="line">    log.debug(<span class="string">&quot;wait end...&quot;</span>); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">18:44:00.778 c.TestCountDownLatch [main] - waiting...</span><br><span class="line">18:44:00.778 c.TestCountDownLatch [Thread-2] - begin... </span><br><span class="line">18:44:00.778 c.TestCountDownLatch [Thread-0] - begin... </span><br><span class="line">18:44:00.778 c.TestCountDownLatch [Thread-1] - begin... </span><br><span class="line">18:44:01.782 c.TestCountDownLatch [Thread-0] - end...2 </span><br><span class="line">18:44:02.283 c.TestCountDownLatch [Thread-2] - end...1</span><br><span class="line">18:44:02.782 c.TestCountDownLatch [Thread-1] - end...0 </span><br><span class="line">18:44:02.782 c.TestCountDownLatch [main] - wait end...</span><br></pre></td></tr></table></figure>

<p>可以配合线程池使用，改进如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">    ExecutorService service = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>); </span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">            latch.await();</span><br><span class="line">            log.debug(<span class="string">&quot;wait end...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">18:52:25.831 c.TestCountDownLatch [pool-1-thread-3] - begin...</span><br><span class="line">18:52:25.831 c.TestCountDownLatch [pool-1-thread-1] - begin... </span><br><span class="line">18:52:25.831 c.TestCountDownLatch [pool-1-thread-2] - begin...</span><br><span class="line">18:52:25.831 c.TestCountDownLatch [pool-1-thread-4] - waiting...</span><br><span class="line">18:52:26.835 c.TestCountDownLatch [pool-1-thread-1] - end...2</span><br><span class="line">18:52:27.335 c.TestCountDownLatch [pool-1-thread-2] - end...1</span><br><span class="line">18:52:27.835 c.TestCountDownLatch [pool-1-thread-3] - end...0</span><br><span class="line">18:52:27.835 c.TestCountDownLatch [pool-1-thread-4] - wait end... </span><br></pre></td></tr></table></figure>

<p><strong>应用之同步等待多线程准备完毕</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>, (r) -&gt; &#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">&quot;t&quot;</span> + num.getAndIncrement());</span><br><span class="line"> &#125;);</span><br><span class="line">	CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>); String[] all = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">	Random r = <span class="keyword">new</span> Random();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = j;</span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(r.nextInt(<span class="number">100</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                all[x] = Thread.currentThread().getName() + <span class="string">&quot;(&quot;</span> + (i + <span class="string">&quot;%&quot;</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                System.out.print(<span class="string">&quot;\r&quot;</span> + Arrays.toString(all));</span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">&quot;\n游戏开始...&quot;</span>); </span><br><span class="line">service.shutdown();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[t0(100%), t1(100%), t2(100%), t3(100%), t4(100%), t5(100%), t6(100%), t7(100%), t8(100%), t9(100%)]</span><br><span class="line">游戏开始..</span><br></pre></td></tr></table></figure>

<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执 行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>); <span class="comment">// 个数为2时才会继续执行</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;线程1开始..&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	cb.await();</span><br><span class="line"><span class="comment">// 当个数不足时，等待</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;线程1继续向下运行...&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">&#125;).start();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;线程2开始..&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	cb.await();</span><br><span class="line">	<span class="comment">// 2 秒后，线程个数够2，继续运行</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;线程2继续向下运行...&quot;</span>+<span class="keyword">new</span> Date()); &#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的 CyclicBarrier 可以被比 喻为『人满发车]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/22/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7(%E4%BA%8C)/" data-id="ckfo4q45r0013vkvw1olrg40c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java并发编程共享模型之工具(一)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/21/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7(%E4%B8%80)/" class="article-date">
  <time datetime="2020-09-21T07:37:42.304Z" itemprop="datePublished">2020-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/21/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7(%E4%B8%80)/">java并发编程共享模型之工具（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="共享模型之工具（一）"><a href="#共享模型之工具（一）" class="headerlink" title="共享模型之工具（一）"></a>共享模型之工具（一）</h1><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wbmTuF"><img src="https://s1.ax1x.com/2020/09/21/wbmTuF.png" alt="wbmTuF.png"></a></p>
<h4 id="1-线程池状态"><a href="#1-线程池状态" class="headerlink" title="1) 线程池状态"></a>1) 线程池状态</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wbmv36"><img src="https://s1.ax1x.com/2020/09/21/wbmv36.png" alt="wbmv36.png"></a></p>
<p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p>
<p>从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING 这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作 进行赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; c 为旧值， ctlOf 返回结果为新值 ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们 private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>构造方法 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">    TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">    RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p>corePoolSize 核心线程数目 (多保留的线程数)</p>
<p> maximumPoolSize 大线程数目</p>
<p> keepAliveTime 生存时间 - 针对救急线程</p>
<p> unit 时间单位 - 针对救急线程 </p>
<p>workQueue 阻塞队列 </p>
<p>threadFactory 线程工厂 - 可以为线程创建时起个好名字</p>
<p> handler 拒绝策略</p>
<h4 id="工作方式："><a href="#工作方式：" class="headerlink" title="工作方式："></a><strong>工作方式：</strong></h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wbMRqU"><img src="https://s1.ax1x.com/2020/09/21/wbMRqU.png" alt="wbMRqU.png"></a></p>
<p>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。 </p>
<p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排 队，直到有空闲的线程。 </p>
<p>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线 程来救急。 </p>
<p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它 著名框架也提供了实现</p>
<p> AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略<br>CallerRunsPolicy 让调用者运行任务 </p>
<p>DiscardPolicy 放弃本次任务 </p>
<p>DiscardOldestPolicy 放弃队列中早的任务，本任务取而代之 </p>
<p>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方 便定位问题</p>
<p> Netty 的实现，是创建一个新线程来执行任务 ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略 </p>
<p>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略 </p>
<p>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wbQAeS"><img src="https://s1.ax1x.com/2020/09/21/wbQAeS.png" alt="wbQAeS.png"></a></p>
<p>根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池</p>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="**newFixedThreadPool **"></a>**newFixedThreadPool **</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>,</span><br><span class="line">                                  TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()); &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="keyword">private</span> AtomicInteger integer = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Thread(r,<span class="string">&quot;mypool_&quot;</span> + integer.getAndIncrement());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        threadPool.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mypool_1执行了</span><br><span class="line">mypool_2执行了</span><br><span class="line">mypool_1执行了</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>核心线程 == 最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li>阻塞队列是无界的，可以放任意数量的任务</li>
</ul>
<p><strong>评价</strong></p>
<p>适用于任务量已知，相对耗时的任务</p>
<h4 id="newCachedTreadPool"><a href="#newCachedTreadPool" class="headerlink" title="newCachedTreadPool"></a>newCachedTreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;()); &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;putting.....1&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;putted......1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;putting.....2&quot;</span>);</span><br><span class="line">                queue.put(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;putted......2&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;take.....1&quot;</span>);</span><br><span class="line">                queue.take();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;taked......1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;take......2&quot;</span>);</span><br><span class="line">                queue.take();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;taked......2&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t1putting.....<span class="number">1</span></span><br><span class="line">t2take.....<span class="number">1</span></span><br><span class="line">t2taked......<span class="number">1</span></span><br><span class="line">t1putted......<span class="number">1</span></span><br><span class="line">t2take......<span class="number">2</span></span><br><span class="line">t1putting.....<span class="number">2</span></span><br><span class="line">t1putted......<span class="number">2</span></span><br><span class="line">t2taked......<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li><p>核心线程数是0，最大线程数是 Integer.MAX_VALUE.救急线程的空闲生存时间是60秒，意味着</p>
<ul>
<li>全部都是救急线程（60s后可以收回）</li>
<li>救急线程可以无限创建</li>
</ul>
</li>
<li><p>队列采用了 SynchronousQueue实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱，一手交货）</p>
</li>
</ul>
<p><strong>评价</strong></p>
<p>整个线程池表示为线程数会根据任务量不断增长，没有上线，当任务执行完毕，空闲1分钟后释放线程。适合任务数比较密集，但每个任务执行时间较短的情况。</p>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newSingleThreadExecutor();</span><br><span class="line">        pool.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        pool.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        pool.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="number">3</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;pool-1-thread-1&quot; java.lang.ArithmeticException: &#x2F; by zero</span><br><span class="line">1</span><br><span class="line">	at demo01.Test03.lambda$main$0(Test03.java:14)</span><br><span class="line">2</span><br><span class="line">	at demo01.Test03$$Lambda$1&#x2F;650898.run(Unknown Source)</span><br><span class="line">3</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>希望多个任务排队执行。线程数固定为1，任务数多于1时，会放入无界队列排队。任务执行完毕，这是唯一的线程也不会被释放。</p>
<p>区别：</p>
<ul>
<li><p>自己创建一个单线程串执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作。</p>
</li>
<li><p>newSingleThreadExecutor （）线程数始终为1，不能修改</p>
<ul>
<li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因 此不能调用 ThreadPoolExecutor 中特有的方法 </li>
</ul>
</li>
<li><p>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改 </p>
<ul>
<li>对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li>
</ul>
</li>
</ul>
<h4 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行任务</span><br><span class="line">void execute(Runnable command);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 提交任务 task，用返回值 Future 获得任务执行结果 </span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 提交 tasks 中所有任务 </span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 提交 tasks 中所有任务，带超时时间 </span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit) throws InterruptedException;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消 </span><br><span class="line">&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        Future&lt;String&gt; future = pool.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;running....&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">running....</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futures = pool.invokeAll(Arrays.asList(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        ));</span><br><span class="line">        futures.forEach(f -&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin...</span><br><span class="line">begin...</span><br><span class="line">begin...</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        String str = pool.invokeAny(Arrays.asList(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;begin...1&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;end...1&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;begin...2&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;end...2&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;begin...3&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;end...3&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        ));</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin...<span class="number">1</span></span><br><span class="line">begin...<span class="number">2</span></span><br><span class="line">end...<span class="number">2</span></span><br><span class="line">begin...<span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="异步模式之工作线程"><a href="#异步模式之工作线程" class="headerlink" title="异步模式之工作线程"></a>异步模式之工作线程</h4><p>定义：让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现 就是线程池，也体现了经典设计模式中的享元模式。</p>
<p>例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那 么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）</p>
<p>注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率</p>
<p>例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成 服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工 </p>
<p><strong>饥饿</strong></p>
<p>固定大小线程池会有饥饿现象</p>
<ul>
<li><p>两个工人是同一个线程池中的两个线程 </p>
</li>
<li><p>他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作 </p>
<ul>
<li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待 </li>
<li>后厨做菜：没啥说的，做就是了 </li>
</ul>
</li>
<li><p>比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好 </p>
</li>
<li><p>但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class="string">&quot;地三鲜&quot;</span>, <span class="string">&quot;宫保鸡丁&quot;</span>, <span class="string">&quot;辣子鸡丁&quot;</span>, <span class="string">&quot;烤鸡翅&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">cooking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MENU.get(RANDOM.nextInt(MENU.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f = executorService.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;上菜&quot;</span> + f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         <span class="comment">/*executorService.execute(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">             System.out.println(&quot;处理点餐...&quot;);</span></span><br><span class="line"><span class="comment">             Future&lt;String&gt; f = executorService.submit(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">                 System.out.println(&quot;做菜&quot;);</span></span><br><span class="line"><span class="comment">                 return cooking();</span></span><br><span class="line"><span class="comment">         &#125;);</span></span><br><span class="line"><span class="comment">         try &#123;</span></span><br><span class="line"><span class="comment">             System.out.println(&quot;上菜&quot; + f.get());</span></span><br><span class="line"><span class="comment">         &#125; catch (InterruptedException | ExecutionException e) &#123;</span></span><br><span class="line"><span class="comment">               e.printStackTrace();</span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment">          &#125;);*/</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">处理点餐...</span><br><span class="line">做菜</span><br><span class="line">上菜地三鲜</span><br></pre></td></tr></table></figure>

<p>将注释打开后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">处理点餐...</span><br><span class="line">处理点餐...</span><br></pre></td></tr></table></figure>

<p>解决方法可以增加线程池的大小，不过不是根本解决方案，还是前面提到的，不同的任务类型，采用不同的线程池，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class="string">&quot;地三鲜&quot;</span>, <span class="string">&quot;宫保鸡丁&quot;</span>, <span class="string">&quot;辣子鸡丁&quot;</span>, <span class="string">&quot;烤鸡翅&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">cooking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MENU.get(RANDOM.nextInt(MENU.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService waitPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        ExecutorService cookPool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        waitPool.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;上菜&quot;</span> + f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         waitPool.execute(() -&gt; &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">             Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class="line">                 System.out.println(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                 <span class="keyword">return</span> cooking();</span><br><span class="line">         &#125;);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;上菜&quot;</span> + f.get());</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">处理点餐...</span><br><span class="line">做菜</span><br><span class="line">上菜辣子鸡丁</span><br><span class="line">处理点餐...</span><br><span class="line">做菜</span><br><span class="line">上菜地三鲜</span><br></pre></td></tr></table></figure>

<h4 id="创建多少线程池合适"><a href="#创建多少线程池合适" class="headerlink" title="创建多少线程池合适"></a>创建多少线程池合适</h4><ul>
<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿</li>
<li>多大会导致更多地线程上下文切换，占用更多内存</li>
</ul>
<h5 id="CPU-密集型运算"><a href="#CPU-密集型运算" class="headerlink" title="CPU 密集型运算"></a>CPU 密集型运算</h5><p>通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 </p>
<h5 id="I-O-密集型运算"><a href="#I-O-密集型运算" class="headerlink" title="I/O 密集型运算"></a>I/O 密集型运算</h5><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。</p>
<p>经验公式如下</p>
<p>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</p>
<p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式<br>4 * 100% * 100% / 50% = 8</p>
<p>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式</p>
<p>4 * 100% * 100% / 10% = 40</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/21/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7(%E4%B8%80)/" data-id="ckfo4q45q0012vkvwbueb8el4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java并发编程共享模型之不可变" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/20/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98/" class="article-date">
  <time datetime="2020-09-20T12:47:40.145Z" itemprop="datePublished">2020-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/20/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98/">java并发编程共享模型之不可变</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="java并发编程共享模型之不可变"><a href="#java并发编程共享模型之不可变" class="headerlink" title="java并发编程共享模型之不可变"></a>java并发编程共享模型之不可变</h1><h4 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h4><ul>
<li>不可变类的使用</li>
<li>不可变类设计</li>
<li>无状态类设计</li>
</ul>
<h4 id="日期转换的问题"><a href="#日期转换的问题" class="headerlink" title="日期转换的问题"></a>日期转换的问题</h4><p><strong>问题提出</strong></p>
<p>下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Date parse = format.parse(<span class="string">&quot;2020-09-20&quot;</span>);</span><br><span class="line">                    System.out.println(parse);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;Thread-4&quot; Exception in thread &quot;Thread-2&quot; java.lang.NumberFormatException: multiple points</span><br><span class="line">Mon Aug 20 00:00:00 CST 2001</span><br><span class="line">	at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)</span><br><span class="line">Mon Aug 20 00:00:00 CST 2001</span><br><span class="line">	at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)</span><br><span class="line">Mon Aug 20 00:00:00 CST 2001</span><br><span class="line">	at java.lang.Double.parseDouble(Double.java:538)</span><br><span class="line">	at java.text.DigitList.getDouble(DigitList.java:169)</span><br><span class="line">	at java.text.DecimalFormat.parse(DecimalFormat.java:2056)</span><br><span class="line">	at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)</span><br><span class="line">	at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)</span><br><span class="line">	at java.text.DateFormat.parse(DateFormat.java:364)</span><br><span class="line">	at demo.Test04.lambda$main$0(Test04.java:16)</span><br><span class="line">	at demo.Test04$$Lambda$1&#x2F;21338231.run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">java.lang.NumberFormatException: multiple points</span><br><span class="line">	at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)</span><br><span class="line">	at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)</span><br><span class="line">	at java.lang.Double.parseDouble(Double.java:538)</span><br><span class="line">	at java.text.DigitList.getDouble(DigitList.java:169)</span><br><span class="line">	at java.text.DecimalFormat.parse(DecimalFormat.java:2056)</span><br><span class="line">	at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)</span><br><span class="line">	at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)</span><br><span class="line">	at java.text.DateFormat.parse(DateFormat.java:364)</span><br><span class="line">	at demo.Test04.lambda$main$0(Test04.java:16)</span><br><span class="line">	at demo.Test04$$Lambda$1&#x2F;21338231.run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>

<p><strong>思路-同步锁</strong></p>
<p>这样虽能解决问题，但带来的是性能上的损失，并不算很好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (format)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Date parse = format.parse(<span class="string">&quot;2020-09-20&quot;</span>);</span><br><span class="line">                        System.out.println(parse);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sun Sep 20 00:00:00 CST 2020</span><br><span class="line">Sun Sep 20 00:00:00 CST 2020</span><br><span class="line">Sun Sep 20 00:00:00 CST 2020</span><br><span class="line">Sun Sep 20 00:00:00 CST 2020</span><br><span class="line">Sun Sep 20 00:00:00 CST 2020</span><br></pre></td></tr></table></figure>

<p><strong>思路-不可变</strong></p>
<p>如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改！这样的对象在Java中有很多，例如在Java8后，提供了一个新的日期格式化类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.TemporalAccessor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                TemporalAccessor date = formatter.parse(<span class="string">&quot;2020-09-20&quot;</span>);</span><br><span class="line">                System.out.println(date);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;,ISO resolved to 2020-09-20</span><br><span class="line">&#123;&#125;,ISO resolved to 2020-09-20</span><br><span class="line">&#123;&#125;,ISO resolved to 2020-09-20</span><br><span class="line">&#123;&#125;,ISO resolved to 2020-09-20</span><br><span class="line">&#123;&#125;,ISO resolved to 2020-09-20</span><br></pre></td></tr></table></figure>

<p>可以看 DateTimeFormatter 的文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@implSpec</span><br><span class="line">This class is immutable and thread-safe.</span><br></pre></td></tr></table></figure>

<p>不可变对象，实际是另一种避免竞争的方式。</p>
<h4 id="不可变设计"><a href="#不可变设计" class="headerlink" title="不可变设计"></a>不可变设计</h4><p>另一个大家更为熟悉的String类也是不可变的，以它为例，说明一下不可变设计的要素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">	 <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">	 <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">	 <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">	 <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">	 <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">	 <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>final的使用</p>
<p>发现该类、类中所有的属性都是final的</p>
<ul>
<li>属性用final修饰保证了该属性是只读的，不能修改</li>
<li>类用final修饰保证了该类中的方法不能被覆盖，防止子类无意间破环不可变性</li>
</ul>
<h4 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h4><p>但有人说，使用字符串时，也有一些跟修改相关的方法啊，比如substring等，那么下面就看一看这些方法是如何实现的，就以substring为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line">        <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>发现其内部是调用String的构造方法创建了一个新字符串，在进入这个构造看看，是否对final char[] value做出了修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	 	<span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		 <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			 <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">			 	<span class="keyword">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">			 <span class="keyword">return</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">	 	<span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">//生成新的 char[] value，对内容进行复制</span></span><br><span class="line">	 <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果发现没有，构造新字符串对象时，会生成新的char[] value，对内容进行复制。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy)】</p>
<h4 id="模式之享元"><a href="#模式之享元" class="headerlink" title="模式之享元"></a>模式之享元</h4><p>定义：当需要重用数量有限的同一类对象时</p>
<p><strong>体现</strong></p>
<p><strong>包装类</strong></p>
<p>在jdk中Boolean,Byte,Short,Integer,Long,Character等包装类提供了ValueOf方法，例如Long的valueOf会缓存 -128至127之间的Long对象，在这个范围之间会重用对象，大于这个范围，才会新建Long对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">            <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li><p>Byte,Short,Long缓存的范围都是-128至127</p>
</li>
<li><p>Character缓存的范围是0-127</p>
</li>
<li><p>Integer的默认范围是-128至127</p>
<ul>
<li>最小值不能变</li>
<li>但最大值可以通过调整虚拟机参数Djava.lang.Integer,IntegerCache.high来改变</li>
</ul>
</li>
<li><p>Boolean缓存了TRUE和FALSE</p>
</li>
</ul>
<p><strong>String串池</strong></p>
<p><strong>BigDecimal BigInteger</strong></p>
<h4 id="DIY"><a href="#DIY" class="headerlink" title="DIY"></a>DIY</h4><p>例如：一个线上商城应用，QPS达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。这时预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕在还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">/*使用连接池*/</span></span><br><span class="line">        Pool pool = <span class="keyword">new</span> Pool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                Connection conn = pool.borrow();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                pool.free(conn);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Pool&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 连接池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> poolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接对象数组</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray states;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 构造方法初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(<span class="keyword">int</span> poolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="keyword">this</span>.connections = <span class="keyword">new</span> Connection[poolSize];</span><br><span class="line">        <span class="keyword">this</span>.states = <span class="keyword">new</span> AtomicIntegerArray(<span class="keyword">new</span> <span class="keyword">int</span>[poolSize]);<span class="comment">//使用AtomicIntegerArray保证states的线程安全</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            connections[i] = <span class="keyword">new</span> MockConnection(<span class="string">&quot;连接&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 借连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">borrow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取空闲连接</span></span><br><span class="line">                <span class="keyword">if</span>(states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//使用compareAndSet保证线程安全</span></span><br><span class="line">                        log.debug(<span class="string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);</span><br><span class="line">                        <span class="keyword">return</span> connections[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有空闲连接，当前线程进入等待</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 归还连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == conn) &#123;</span><br><span class="line">                states.set(i, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;free &#123;&#125;&quot;</span>, conn);</span><br><span class="line">                    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockConnection</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MockConnection</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MockConnection&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	.........</span><br></pre></td></tr></table></figure>

<p>以上实现没有考虑：</p>
<ul>
<li>连接的动态增长与收缩</li>
<li>连接保活（可用性检测）</li>
<li>等待超时处理</li>
<li>分布式hash</li>
</ul>
<p>对于关系型数据库，有比较成熟的连接池实现，例如c3p0等对于通用的对象池，可以考虑使用apache commons pool，例如redis连接池可以参考jedid中关于连接池的实现</p>
<h4 id="final原理"><a href="#final原理" class="headerlink" title="final原理"></a>final原理</h4><p>设置final变量的原理</p>
<p>理解了volatile原理，在对比final的实现就比较简单了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFinal</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">20</span>; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: aload_0</span><br><span class="line">1: invokespecial #1 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">4: aload_0</span><br><span class="line">5: bipush 20</span><br><span class="line">7: putfield #2 &#x2F;&#x2F; Field a:I</span><br><span class="line"> &lt;-- 写屏障</span><br><span class="line">10: retu</span><br></pre></td></tr></table></figure>

<p>发现final变量的赋值会通过putfield指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为0的情况。</p>
<h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>在web阶段学习时，设计Servlet时为了保证其线程安全，都会有这样的建议，不要为Servlet设置成员变量，这种没有任何成员变量的类是线程安全的</p>
<p>因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/20/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98/" data-id="ckfo4q44t000cvkvwfxh08nt3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-共享模型之CAS无锁（乐观锁，非阻塞）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/20/%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8BCAS%E6%97%A0%E9%94%81%EF%BC%88%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%89/" class="article-date">
  <time datetime="2020-09-20T05:09:46.577Z" itemprop="datePublished">2020-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/20/%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8BCAS%E6%97%A0%E9%94%81%EF%BC%88%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%89/">共享模型之CAS无锁（乐观锁，非阻塞）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="共享模型之CAS无锁（乐观锁，非阻塞）（内容不全）"><a href="#共享模型之CAS无锁（乐观锁，非阻塞）（内容不全）" class="headerlink" title="共享模型之CAS无锁（乐观锁，非阻塞）（内容不全）"></a><strong>共享模型之CAS无锁（乐观锁，非阻塞）（内容不全）</strong></h1><h4 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h4><ul>
<li>CAS与volatile</li>
<li>原子整数</li>
<li>原子引用</li>
<li>原子累加器</li>
<li>Unsafe</li>
</ul>
<p>1、问题提出：转账案例</p>
<p><strong>解决思路-无锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountCas</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger balance;  <span class="comment">//使用原子整形AtomicInteger </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountCas</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = <span class="keyword">new</span> AtomicInteger(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取余额的最新值</span></span><br><span class="line">            <span class="keyword">int</span> prev = balance.get();</span><br><span class="line">            <span class="comment">// 要修改的余额</span></span><br><span class="line">            <span class="keyword">int</span> next = prev - amount;</span><br><span class="line">            <span class="comment">// 真正修改</span></span><br><span class="line">            <span class="keyword">if</span>(balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;	  <span class="comment">//如果最新的余额与之前的余额不一致继续下一轮循环，一致则退出循环	</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CAS 与 volatile</strong></p>
<p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="comment">// 获取余额的最新值</span></span><br><span class="line">          <span class="keyword">int</span> prev = balance.get();</span><br><span class="line">          <span class="comment">// 要修改的余额</span></span><br><span class="line">          <span class="keyword">int</span> next = prev - amount;</span><br><span class="line">         <span class="comment">/* compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值</span></span><br><span class="line"><span class="comment">	 - 不一致了，next 作废，返回 false 表示失败</span></span><br><span class="line"><span class="comment">	 比如，别的线程已经做了减法，当前值已经被减成了 990</span></span><br><span class="line"><span class="comment">	 那么本线程的这次 990 就作废了，进入 while 下次循环重试</span></span><br><span class="line"><span class="comment">	 - 一致，以 next 设置为新值，返回 true 表示成功*/</span></span><br><span class="line">          <span class="comment">// 真正修改</span></span><br><span class="line">          <span class="keyword">if</span>(balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">              <span class="keyword">break</span>;	  <span class="comment">//如果最新的余额与之前的余额不一致继续下一轮循环，一致则退出循环	</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p>
<p><strong>注意</strong></p>
<p>其实CAS的底层是lock cmpxchg指令（x86架构），在单核CPU和多核CPU下都能够保证【计较-交换】的原子性。</p>
<p><strong>volatile</strong></p>
<p>获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰。</p>
<p>它可以用来修饰成员变量和静态变量，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存。即一个线程对volatile变量的修改，对另一个线程可见。</p>
<p><strong>注意</strong></p>
<p>volatile仅仅保证了共享变量的可见性，让其他线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</p>
<p>CAS必须借助volatile才能读取到共享变量的最新值来实现【比较并交换】的效果</p>
<h4 id="为什么无锁效率高"><a href="#为什么无锁效率高" class="headerlink" title="为什么无锁效率高?"></a><strong>为什么无锁效率高?</strong></h4><ul>
<li>无锁情况下，即使重新失败，线程始终在高速运行，没用停歇，而synchronized会让线程在没有获得锁的时候，发生上下文切换，进入阻塞，大打个比喻</li>
<li>线程就好像高速跑道上的赛车，高速运行时，速度超块，一旦发生上下文切换，就好比赛车要减速、熄火等被唤醒又得重新打火、启动、加速…..恢复到高速运行，代价比较大</li>
<li>但无锁情况下，因为线程要保持运行，需要额外CPU的支持，CPU在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，任然会进入可运行状态，还是会导致上下文切换。【线程数低于CPU核数才能发挥优势，不然多出的线程分不到时间片】</li>
</ul>
<h4 id="CAS的特点"><a href="#CAS的特点" class="headerlink" title="CAS的特点"></a><strong>CAS的特点</strong></h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wTFrn0"><img src="https://s1.ax1x.com/2020/09/20/wTFrn0.png" alt="wTFrn0.png"></a></p>
<h4 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h4><p>J.U.C并发包提供了：</p>
<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
<p>以 AtomicInteger 为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">System.out.println(i.getAndIncrement());</span><br><span class="line"><span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">System.out.println(i.incrementAndGet());</span><br><span class="line"><span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">System.out.println(i.decrementAndGet());</span><br><span class="line"><span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">System.out.println(i.getAndDecrement());</span><br><span class="line"><span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line"><span class="comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span></span><br><span class="line"><span class="comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span></span><br><span class="line">System.out.println(i.getAndAccumulate(<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line"><span class="comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.accumulateAndGet(-<span class="number">10</span>, (p, x) -&gt; p + x));</span><br></pre></td></tr></table></figure>

<p>updateAndGet原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(AtomicInteger i, IntUnaryOperator operator)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         <span class="keyword">int</span> prev = i.get();</span><br><span class="line">         <span class="keyword">int</span> next = operator.applyAsInt(prev);</span><br><span class="line">         <span class="keyword">if</span> (i.compareAndSet(prev, next)) &#123;</span><br><span class="line">             <span class="keyword">return</span> next;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>原子引用</strong></p>
<ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference</li>
<li>AtomicStampedReference</li>
</ul>
<p>安全实现-使用CAS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecimalAccountCas</span> <span class="keyword">implements</span> <span class="title">DecimalAccount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecimalAccountCas</span><span class="params">(BigDecimal balance)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line">        <span class="keyword">this</span>.balance = <span class="keyword">new</span> AtomicReference&lt;&gt;(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(BigDecimal amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            BigDecimal prev = balance.get();</span><br><span class="line">            BigDecimal next = prev.subtract(amount);</span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11:29:52.325 c.Test36 [main] - main start... </span><br><span class="line">11:29:52.379 c.Test36 [t1] - change A-&gt;B true </span><br><span class="line">11:29:52.879 c.Test36 [t2] - change B-&gt;A true </span><br><span class="line">11:29:53.880 c.Test36 [main] - change A-&gt;C true</span><br></pre></td></tr></table></figure>

<p><strong>ABA 问题及解决</strong><br> <strong>ABA 问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	 log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">	 <span class="comment">// 获取值 A</span></span><br><span class="line">	 <span class="comment">// 这个共享变量被它线程修改过？</span></span><br><span class="line">	 String prev = ref.get();</span><br><span class="line">	 other();   <span class="comment">//</span></span><br><span class="line">	 sleep(<span class="number">1</span>); </span><br><span class="line">	 <span class="comment">// 尝试改为 C</span></span><br><span class="line">	 log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">	 	log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="string">&quot;B&quot;</span>));</span><br><span class="line">	 &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">	 sleep(<span class="number">0.5</span>)</span><br><span class="line">	 <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">	 	log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="string">&quot;A&quot;</span>));</span><br><span class="line">	 &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11:29:52.325 c.Test36 [main] - main start... </span><br><span class="line">11:29:52.379 c.Test36 [t1] - change A-&gt;B true </span><br><span class="line">11:29:52.879 c.Test36 [t2] - change B-&gt;A true </span><br><span class="line">11:29:53.880 c.Test36 [main] - change A-&gt;C true</span><br></pre></td></tr></table></figure>

<p>主线程仅能判断出共享变量的值与最初值 A 是否相同，<strong>不能感知到这种从 A 改为 B 又 改回 A 的情况</strong>，如果主线程希望： 只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要<strong>再加一个版本号</strong>。</p>
<p><strong>AtomicStampedReference</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	 log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">	 <span class="comment">// 获取值 A</span></span><br><span class="line">	 String prev = ref.getReference();  <span class="comment">//之前是ref.get(),这里是getReference()</span></span><br><span class="line">	 <span class="comment">// 获取版本号</span></span><br><span class="line">	 <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">	 log.debug(<span class="string">&quot;版本 &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">	 <span class="comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span></span><br><span class="line">	 other();</span><br><span class="line">	 sleep(<span class="number">1</span>);</span><br><span class="line">	 <span class="comment">// 尝试改为 C</span></span><br><span class="line">	 log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="string">&quot;C&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		 log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;B&quot;</span>, </span><br><span class="line">		 ref.getStamp(), ref.getStamp() + <span class="number">1</span>));</span><br><span class="line">		 log.debug(<span class="string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());</span><br><span class="line">	 &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">	 sleep(<span class="number">0.5</span>);</span><br><span class="line">	 <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">	 	log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>, </span><br><span class="line">	 	ref.getStamp(), ref.getStamp() + <span class="number">1</span>));</span><br><span class="line">	 	log.debug(<span class="string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());</span><br><span class="line">	 &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> c.Test36 [main] - main start... </span><br><span class="line">15:41:34.894 c.Test36 [main] - 版本 0 </span><br><span class="line">15:41:34.956 c.Test36 [t1] - change A-&gt;B true </span><br><span class="line">15:41:34.956 c.Test36 [t1] - 更新版本为 1 </span><br><span class="line">15:41:35.457 c.Test36 [t2] - change B-&gt;A true </span><br><span class="line">15:41:35.457 c.Test36 [t2] - 更新版本为 2 </span><br><span class="line">15:41:36.457 c.Test36 [main] - change A-&gt;C false</span><br></pre></td></tr></table></figure>

<p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。<br>   但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了：</p>
<p><strong>AtomicMarkableReference</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wTnx7n"><img src="https://s1.ax1x.com/2020/09/20/wTnx7n.png" alt="wTnx7n.png"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GarbageBag</span> </span>&#123;</span><br><span class="line">	 String desc;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="title">GarbageBag</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">this</span>.desc = desc;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">	 	<span class="keyword">this</span>.desc = desc;</span><br><span class="line">	  &#125;</span><br><span class="line">	 <span class="meta">@Override</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 	<span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">&quot; &quot;</span> + desc;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestABAAtomicMarkableReference</span> </span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	 GarbageBag bag = <span class="keyword">new</span> GarbageBag(<span class="string">&quot;装满了垃圾&quot;</span>);</span><br><span class="line">	 <span class="comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span></span><br><span class="line">	 AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="keyword">new</span> AtomicMarkableReference&lt;&gt;(bag, <span class="keyword">true</span>);</span><br><span class="line">	 log.debug(<span class="string">&quot;主线程 start...&quot;</span>);</span><br><span class="line">	 GarbageBag prev = ref.getReference();</span><br><span class="line">	 log.debug(prev.toString());</span><br><span class="line">	 <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		 log.debug(<span class="string">&quot;打扫卫生的线程 start...&quot;</span>);</span><br><span class="line">		 bag.setDesc(<span class="string">&quot;空垃圾袋&quot;</span>);</span><br><span class="line">		 <span class="keyword">while</span> (!ref.compareAndSet(bag, bag, <span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;&#125;</span><br><span class="line">		 log.debug(bag.toString());</span><br><span class="line">	 &#125;).start();</span><br><span class="line">	 Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">	 log.debug(<span class="string">&quot;主线程想换一只新垃圾袋？&quot;</span>);</span><br><span class="line">	 <span class="keyword">boolean</span> success = ref.compareAndSet(prev, <span class="keyword">new</span> GarbageBag(<span class="string">&quot;空垃圾袋&quot;</span>), <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">	 log.debug(<span class="string">&quot;换了么？&quot;</span> + success);</span><br><span class="line">	 log.debug(ref.getReference().toString());</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2019-10-13 15:30:09.264 [main] 主线程 start... </span><br><span class="line">2019-10-13 15:30:09.270 [main] cn.itcast.GarbageBag@5f0fd5a0 装满了垃圾</span><br><span class="line">2019-10-13 15:30:09.293 [Thread-1] 打扫卫生的线程 start... </span><br><span class="line">2019-10-13 15:30:09.294 [Thread-1] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋</span><br><span class="line">2019-10-13 15:30:10.294 [main] 主线程想换一只新垃圾袋？</span><br><span class="line">2019-10-13 15:30:10.294 [main] 换了么？false </span><br><span class="line">2019-10-13 15:30:10.294 [main] cn.itcast.GarbageBag@5f0fd5a0 空垃圾袋</span><br></pre></td></tr></table></figure>

<p>可以注释掉打扫卫生线程代码，再观察输出</p>
<h4 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h4><ul>
<li>AtomicIntegerArray</li>
<li>AtomiclLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 参数1，提供数组、可以是线程不安全数组或线程安全数组</span></span><br><span class="line"><span class="comment"> 参数2，获取数组长度的方法</span></span><br><span class="line"><span class="comment"> 参数3，自增方法，回传 array, index</span></span><br><span class="line"><span class="comment"> 参数4，打印数组的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// supplier 提供者 无中生有 ()-&gt;结果</span></span><br><span class="line"><span class="comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span></span><br><span class="line"><span class="comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	 Supplier&lt;T&gt; arraySupplier,</span></span></span><br><span class="line"><span class="function"><span class="params">	 Function&lt;T, Integer&gt; lengthFun,</span></span></span><br><span class="line"><span class="function"><span class="params">	 BiConsumer&lt;T, Integer&gt; putConsumer,</span></span></span><br><span class="line"><span class="function"><span class="params">	 Consumer&lt;T&gt; printConsumer )</span> </span>&#123;</span><br><span class="line">	 List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	 T array = arraySupplier.get();</span><br><span class="line">	 <span class="keyword">int</span> length = lengthFun.apply(array);</span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">		 <span class="comment">// 每个线程对数组作 10000 次操作</span></span><br><span class="line">		 ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			 <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">			 	putConsumer.accept(array, j%length);</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;));</span><br><span class="line">	 &#125;</span><br><span class="line">	 ts.forEach(t -&gt; t.start()); <span class="comment">// 启动所有线程</span></span><br><span class="line">	 ts.forEach(t -&gt; &#123;</span><br><span class="line">		 <span class="keyword">try</span> &#123;</span><br><span class="line">		 	t.join();</span><br><span class="line">		 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		 	e.printStackTrace();</span><br><span class="line">		 &#125;</span><br><span class="line"> &#125;); <span class="comment">// 等所有线程结束</span></span><br><span class="line"> printConsumer.accept(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不安全的数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">demo(</span><br><span class="line">	 ()-&gt;<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],</span><br><span class="line">	 (array)-&gt;array.length,</span><br><span class="line">	 (array, index) -&gt; array[index]++,</span><br><span class="line">	 array-&gt; System.out.println(Arrays.toString(array))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>安全的数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">demo(</span><br><span class="line">	 ()-&gt; <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>),</span><br><span class="line">	 (array) -&gt; array.length(),</span><br><span class="line">	 (array, index) -&gt; array.getAndIncrement(index),</span><br><span class="line">	 array -&gt; System.out.println(array)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>字段更新器</strong></p>
<ul>
<li>AtomicReferenceFieldUpdaer//域  字段</li>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdater</li>
</ul>
<p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，<strong>只能配合 volatile 修饰的字段使用</strong>，否则会出现异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        AtomicReferenceFieldUpdater fieldUpdater = AtomicReferenceFieldUpdater.newUpdater(Student.class,String.class,&quot;name&quot;);</span><br><span class="line">        System.out.println(fieldUpdater.compareAndSet(stu, <span class="keyword">null</span>, <span class="string">&quot;张三&quot;</span>));</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原子累加器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> </span>&#123;</span><br><span class="line">	 T adder = adderSupplier.get();</span><br><span class="line">	 <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">	 List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	 <span class="comment">// 4 个线程，每人累加 50 万</span></span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">		 ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">500000</span>; j++) &#123;</span><br><span class="line">		 	action.accept(adder);</span><br><span class="line">		 &#125;</span><br><span class="line">		 &#125;));</span><br><span class="line">	 &#125;</span><br><span class="line">	 ts.forEach(t -&gt; t.start());</span><br><span class="line">	 ts.forEach(t -&gt; &#123;</span><br><span class="line">		 <span class="keyword">try</span> &#123;</span><br><span class="line">		 	t.join();</span><br><span class="line">		 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		 	e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;);</span><br><span class="line">	 <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">	 System.out.println(adder + <span class="string">&quot; cost:&quot;</span> + (end - start)/<span class="number">1000_000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较 AtomicLong 与 LongAdder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"> 	demo(() -&gt; <span class="keyword">new</span> LongAdder(), adder -&gt; adder.increment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"> 	demo(() -&gt; <span class="keyword">new</span> AtomicLong(), adder -&gt; adder.getAndIncrement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1000000 cost:43 </span><br><span class="line">1000000 cost:9 </span><br><span class="line">1000000 cost:7 </span><br><span class="line">1000000 cost:7 </span><br><span class="line">1000000 cost:7 </span><br><span class="line"></span><br><span class="line">1000000 cost:31 </span><br><span class="line">1000000 cost:27 </span><br><span class="line">1000000 cost:28 </span><br><span class="line">1000000 cost:24 </span><br><span class="line">1000000 cost:22</span><br></pre></td></tr></table></figure>

<p>性能提升的原因很简单，就是在有竞争时，<strong>设置多个累加单元</strong>，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… <strong>最后将结果汇总</strong>。这样它们在累加时操作的不同的 Cell 变量，因此<strong>减少了 CAS 重试失败</strong>，从而提高性能。</p>
<p><strong>Unsafe</strong></p>
<p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，<strong>只能通过反射获得</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Unsafe类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;  <span class="comment">//私有成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVALID_FIELD_OFFSET = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_BOOLEAN_BASE_OFFSET;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_BYTE_BASE_OFFSET;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_SHORT_BASE_OFFSET;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_CHAR_BASE_OFFSET;</span><br><span class="line">........</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*通过反射获取Unsafe对象*/</span></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeAccessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);//私有变量用getDeclaredField,公有用getField</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>); <span class="comment">//设置可访问私有成员变量</span></span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>); <span class="comment">//由于是静态成员变量为类类型不是对象类型，赋值为null</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Unsafe CAS 操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"> <span class="keyword">volatile</span> <span class="keyword">int</span> id;</span><br><span class="line"> <span class="keyword">volatile</span> String name; </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">Unsafe unsafe = UnsafeAccessor.getUnsafe();</span><br><span class="line">Field id = Student.class.getDeclaredField(&quot;id&quot;);</span><br><span class="line">Field name = Student.class.getDeclaredField(&quot;name&quot;);</span><br><span class="line"><span class="comment">// 获得成员变量的偏移量</span></span><br><span class="line"><span class="keyword">long</span> idOffset = UnsafeAccessor.unsafe.objectFieldOffset(id);</span><br><span class="line"><span class="keyword">long</span> nameOffset = UnsafeAccessor.unsafe.objectFieldOffset(name);</span><br><span class="line"></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">// 使用 cas 方法替换成员变量的值</span></span><br><span class="line">UnsafeAccessor.unsafe.compareAndSwapInt(student, idOffset, <span class="number">0</span>, <span class="number">20</span>); <span class="comment">// 返回 true</span></span><br><span class="line">UnsafeAccessor.unsafe.compareAndSwapObject(student, nameOffset, <span class="keyword">null</span>, <span class="string">&quot;张三&quot;</span>); <span class="comment">// 返回 true</span></span><br><span class="line">System.out.println(student);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student(id&#x3D;20, name&#x3D;张三)</span><br></pre></td></tr></table></figure>

<p>使用自定义的 测试类实现之前线程安全的原子整数 Account 实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test35&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test35</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DecimalAccount.demo(<span class="keyword">new</span> DecimalAccountCas(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;10000&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecimalAccountCas</span> <span class="keyword">implements</span> <span class="title">DecimalAccount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecimalAccountCas</span><span class="params">(BigDecimal balance)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line">        <span class="keyword">this</span>.balance = <span class="keyword">new</span> AtomicReference&lt;&gt;(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(BigDecimal amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            BigDecimal prev = balance.get();</span><br><span class="line">            BigDecimal next = prev.subtract(amount);</span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DecimalAccount</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    <span class="function">BigDecimal <span class="title">getBalance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(BigDecimal amount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">(DecimalAccount account)</span> </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                account.withdraw(BigDecimal.TEN);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w7pZLT"><img src="https://s1.ax1x.com/2020/09/20/w7pZLT.png" alt="w7pZLT.png"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/20/%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8BCAS%E6%97%A0%E9%94%81%EF%BC%88%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%89/" data-id="ckfo4q45r0014vkvwblpp6dwv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java并发编程共享模型之内存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/19/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98/" class="article-date">
  <time datetime="2020-09-19T09:52:17.300Z" itemprop="datePublished">2020-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/19/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98/">java并发编程共享模型之内存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="java并发编程共享模型之内存"><a href="#java并发编程共享模型之内存" class="headerlink" title="java并发编程共享模型之内存"></a>java并发编程共享模型之内存</h1><p>之前的入门篇主要讲解的Monitor主要关注的是访问共享变量时，保证临界区代码的<strong>原子性</strong>，本文我们将进一步深入学习共享变量在多线程间的【<strong>可见性</strong>】问题与多条指令执行时的【<strong>有序性</strong>】问题。</p>
<h4 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a><strong>Java 内存模型</strong></h4><p>JMM 即 Java Memory Model，它定义了<strong>主存、工作内存</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等</p>
<p>JVM体现在以下几个方面</p>
<ul>
<li>原子性-保证指令不会受到线程上下文切换的影响</li>
<li>可见性-保证指令不会受到CPU缓存的影响</li>
<li>有序性-保证指令不会受到CPU指令并行优化的影响</li>
</ul>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h4 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h4><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> 	Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">	 	<span class="keyword">while</span>(run)&#123;</span><br><span class="line">	 	<span class="comment">// ....</span></span><br><span class="line">	 	&#125;</span><br><span class="line"> 	&#125;);</span><br><span class="line"> 	t.start();</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line"> 	run = <span class="keyword">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为什么呢？分析一下：</p>
<p>1、初始状态， t 线程刚开始从<strong>主内存</strong>读取了 run 的值到<strong>工作内存</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wIBtbt"><img src="https://s1.ax1x.com/2020/09/19/wIBtbt.png" alt="wIBtbt.png"></a></p>
<p>2、因为 t 线程要频繁从主内存中读取 run 的值，JIT 即时编译器会将 run 的值缓存至自己工作内存中的<strong>高速缓存</strong>中，减少对主存中 run 的访问，提高效率。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wIB0PS"><img src="https://s1.ax1x.com/2020/09/19/wIB0PS.png" alt="wIB0PS.png"></a></p>
<p>3、1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wIByKs"><img src="https://s1.ax1x.com/2020/09/19/wIByKs.png" alt="wIByKs.png"></a></p>
<p><strong>解决方法</strong></p>
<p><strong>volatile（易变关键字）</strong><br>   它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，<strong>线程操作 volatile 变量都是直接操作主存。</strong></p>
<p><strong>可见性 vs 原子性</strong><br>   前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， <strong>不能保证原子性</strong>，仅用在<strong>一个写线程，多个读线程</strong>的情况： 上例从字节码理解是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true </span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true </span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true </span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true </span></span><br><span class="line">putstatic run <span class="comment">// 线程 main 修改 run 为 false， 仅此一次</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run false</span></span><br></pre></td></tr></table></figure>

<p>比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到最新值，<strong>不能解决指令交错。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设i的初始值为0 </span></span><br><span class="line">getstatic i <span class="comment">// 线程2-获取静态变量i的值 线程内i=0 </span></span><br><span class="line">getstatic i <span class="comment">// 线程1-获取静态变量i的值 线程内i=0 </span></span><br><span class="line">iconst_1 <span class="comment">// 线程1-准备常量1 </span></span><br><span class="line">iadd <span class="comment">// 线程1-自增 线程内i=1 </span></span><br><span class="line">putstatic i <span class="comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1 </span></span><br><span class="line">iconst_1 <span class="comment">// 线程2-准备常量1 </span></span><br><span class="line">isub <span class="comment">// 线程2-自减 线程内i=-1 </span></span><br><span class="line">putstatic i <span class="comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> <strong>synchronized</strong> 语句块<strong>既可以保证代码块的原子性，也同时保证代码块内变量的可见性</strong>。但缺点是synchronized 是属于重量级操作，性能相对更低。</p>
<p>如果在前面示例的死循环中加入 <strong>System.out.println()</strong> 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？<br> <strong>答</strong>：因为System.out.println()底层加了synchronize锁从而保证了可见性。</p>
<p><strong>模式之两阶段终止(volatile改进）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TwoPhaseTermination twoPhaseTermination = <span class="keyword">new</span> TwoPhaseTermination();</span><br><span class="line">        twoPhaseTermination.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        twoPhaseTermination.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseTermination</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        monitor= <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;执行监控日志&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭线程监控</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步模式之Balking"><a href="#同步模式之Balking" class="headerlink" title="同步模式之Balking"></a>同步模式之Balking</h4><p>Balking（犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需在做了，直接结束返回。</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TwoPhaseTermination tpt = <span class="keyword">new</span> TwoPhaseTermination();</span><br><span class="line">        tpt.start();</span><br><span class="line">        tpt.start();</span><br><span class="line">        tpt.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;停止监控&quot;</span>);</span><br><span class="line">        tpt.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseTermination</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread monitorThread;</span><br><span class="line">    <span class="comment">// 停止标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;  <span class="comment">//设置成volatile 因为只有一个线程对stop进行操作</span></span><br><span class="line">    <span class="comment">// 判断是否执行过 start 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> starting = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;    <span class="comment">//需要加锁防止多个线程同时改变starting状态</span></span><br><span class="line">            <span class="keyword">if</span> (starting) &#123; <span class="comment">// false</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        monitorThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Thread current = Thread.currentThread();</span><br><span class="line">                <span class="comment">// 是否被打断</span></span><br><span class="line">                <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行监控记录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;monitor&quot;</span>);</span><br><span class="line">        monitorThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">        monitorThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行监控记录</span><br><span class="line">执行监控记录</span><br><span class="line">执行监控记录</span><br><span class="line">停止监控</span><br><span class="line">料理后事</span><br></pre></td></tr></table></figure>

<h3 id="有序性—–指令重排序"><a href="#有序性—–指令重排序" class="headerlink" title="有序性—–指令重排序"></a>有序性—–指令重排序</h3><h4 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h4><p>现代CPU支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为五级指令流水线。这时CPU可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。</p>
<p><strong>提示</strong></p>
<p>奔腾四(Pentiium4)支持高达35级流水线，但由于功耗太高被废弃。</p>
<h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a><strong>volatile原理</strong></h3><p>1、volatile保证可见性原理</p>
<p>volatile 的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）<br>   ● 对 volatile 变量的<strong>写指令后</strong>会加入<strong>写屏障</strong><br>   ● 对 volatile 变量的<strong>读指令前</strong>会加入<strong>读屏障</strong></p>
<p>(1) 如何保证可见性</p>
<p>  ● 写屏障（sfence）保证在该屏障<strong>之前</strong>的，对<strong>共享变量的改动</strong>，都<strong>同步到主存</strong>当中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">	 num = <span class="number">2</span>;</span><br><span class="line">	 ready = <span class="keyword">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">	 <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ● 而读屏障（lfence）保证在<strong>该屏障之后</strong>，对共享变量的读取，<strong>加载的是主存中最新数据</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 读屏障</span></span><br><span class="line">	 <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">	 <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">		 r.r1 = num + num;</span><br><span class="line">		 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		 r.r1 = <span class="number">1</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）如何保证有序性</p>
<p>  ● 写屏障会确保指令重排序时，<strong>不会将写屏障之前的代码排在写屏障之后</strong><br>   ●读屏障会确保指令重排序时，不<strong>会将读屏障之后的代码排在读屏障之前</strong></p>
<p><strong>不能解决指令交错：</strong></p>
<ul>
<li>写屏障仅仅是保证之后地读能读到最新地结果，但不能保证读跑到他前面去</li>
<li>而有序性地保证也只是保证了本线程内相关代码不被重排序</li>
</ul>
<p><strong>（3）. double-checked locking 问题</strong></p>
<p>以著名的 double-checked locking 单例模式为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">	 <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		 <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">		 <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">		 <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">			 <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">			 	INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">			 &#125; </span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">return</span> INSTANCE;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以上地实现特点是</strong></p>
<ul>
<li>懒惰实例化</li>
<li>首次使用getInstance()才使用synchronized加锁，后继使用时才需加锁</li>
<li>有隐含地，但很关键地一点：第一个if使用了INSTANCE变量，是在同步块之外</li>
</ul>
<p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0: getstatic #2 &#x2F;&#x2F; Field INSTANCE:Lcn&#x2F;itcast&#x2F;n5&#x2F;Singleton;</span><br><span class="line">3: ifnonnull 37</span><br><span class="line">6: ldc #3 &#x2F;&#x2F; class cn&#x2F;itcast&#x2F;n5&#x2F;Singleton</span><br><span class="line">8: dup   &#x2F;&#x2F;复制对象的指针用于后面解锁</span><br><span class="line">9: astore_0</span><br><span class="line">10: monitorenter</span><br><span class="line">11: getstatic #2 &#x2F;&#x2F; Field INSTANCE:Lcn&#x2F;itcast&#x2F;n5&#x2F;Singleton;</span><br><span class="line">14: ifnonnull 27</span><br><span class="line">17: new #3 &#x2F;&#x2F; class cn&#x2F;itcast&#x2F;n5&#x2F;Singleton</span><br><span class="line">20: dup</span><br><span class="line">21: invokespecial #4 &#x2F;&#x2F; Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">24: putstatic #2 &#x2F;&#x2F; Field INSTANCE:Lcn&#x2F;itcast&#x2F;n5&#x2F;Singleton;</span><br><span class="line">27: aload_0</span><br><span class="line">28: monitorexit</span><br><span class="line">29: goto 37</span><br><span class="line">32: astore_1</span><br><span class="line">33: aload_0</span><br><span class="line">34: monitorexit</span><br><span class="line">35: aload_1</span><br><span class="line">36: athrow</span><br><span class="line">37: getstatic #2 &#x2F;&#x2F; Field INSTANCE:Lcn&#x2F;itcast&#x2F;n5&#x2F;Singleton;</span><br><span class="line">40: areturn</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>17表示创建对象，将对象引用入栈//new Singlenton</li>
<li>20表示复制一份对象引用//引用地址</li>
<li>21表示利用一个对象引用，调用构造方法</li>
<li>24表示利用一个对象引用，赋值给 static INSTANCE</li>
</ul>
<p>也许jvm会优化为：先执行24，在执行21.</p>
<p>关键在于0：getstatic这行代码在monitor控制外，它就像之前举例中不守规矩的人，可以越过monitor读取INSTANCE变量的值</p>
<p>这时t1还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么t2拿到的是将是一个未初始化完毕的单例</p>
<p>对INSTANCE使用volatile修饰即可，可以禁用指令重排，但要注意JDK5以上的版本的volatile才会真正有效</p>
<p><strong>double-checked locking 解决</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">	 <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 实例没创建，才会进入内部的 synchronized代码块</span></span><br><span class="line">		 <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; </span><br><span class="line">			 <span class="keyword">synchronized</span> (Singleton.class) &#123; // t2</span><br><span class="line">				 <span class="comment">// 也许有其它线程已经创建实例，所以再判断一次</span></span><br><span class="line">				 <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">				 	INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">			 	&#125;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	 	<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上解决了：<br> ① 使用synchronized 对Singleton.class进行了加<strong>synchronized</strong> 锁，解决了多个线程访问到 INSTANCE = new Singleton();会创建多个单例了。<br> ② 对Singleton实例INSTANCE 加了<strong>volatile</strong>关键字从而保证不会指令重排。</p>
<p><strong>小结：\</strong>① synchronized 既能保证**原子性、可见性、有序性<strong>，其中</strong>有序性<strong>是在该共享变量</strong>完全被synchronized 所接管<strong>（包括共享变量的读写操作），上面的例子中synchronized 外面的 if (INSTANCE == null) 中的INSTANCE读操作没有被synchronized 接管，因此无法保证INSTANCE共享变量的有序性（即不能防止指令重排）。<br>    ② 对共享变量加volatile关键字可以保证</strong>可见性<strong>和</strong>有序性<strong>，但是</strong>不能保证原子性**（即不能防止指令交错）。</p>
<ul>
<li><p>可见性</p>
<ul>
<li>写屏障保证在该屏障之前的t1对共享变量的改动，都同步到主存当中</li>
<li>而写屏障保证在该屏障之后t2对共享变量的读取，加载的是主存中最新数据</li>
</ul>
</li>
<li><p>有序性</p>
<ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在写屏障之前</li>
</ul>
</li>
<li><p>更底层是读写变量时使用lock指令来多核CPU之间的可见性与有序性</p>
</li>
</ul>
<p><strong>(4) happens-before</strong></p>
<p>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是<strong>可见性与有序性的一套规则总结</strong>，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见。 </p>
<p>● 线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> Object m = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">	 <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">	 x = <span class="number">10</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">	 <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">	 System.out.println(x);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> 	x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> 	System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>线程 start 前对变量的写，对该线程开始后对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x; x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> 	System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> 	x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">	t1.start();</span><br><span class="line">	t1.join();</span><br><span class="line">	System.out.println(x)</span><br></pre></td></tr></table></figure>

<p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">		<span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">		sout(x);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">	t2.start();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		x = <span class="number">10</span>;</span><br><span class="line">		t2.interrupt();</span><br><span class="line">	&#125;.<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">	<span class="keyword">while</span>(!t2.isInterrupted())&#123;</span><br><span class="line">		Thread.yield();</span><br><span class="line">	&#125;</span><br><span class="line">	sout(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">	y = <span class="number">10</span>;</span><br><span class="line">	x = <span class="number">20</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">	<span class="comment">//x = 20 对t2可见，同时 y = 10也对t2可见</span></span><br><span class="line">	sout(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p><strong>习题</strong></p>
<p><strong>balking模式习题</strong></p>
<p>希望doInit()方法被调用一次，下面的实现是否有问题，为什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span></span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(initialized)&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		doInit();</span><br><span class="line">		initialized = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInIT</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该使用同步代码块将被有读写操作的数据保护起来。</p>
<p><strong>(4) 线程安全单例习题</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/woTGwV"><img src="https://s1.ax1x.com/2020/09/20/woTGwV.png" alt="woTGwV.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/woTtFU"><img src="https://s1.ax1x.com/2020/09/20/woTtFU.png" alt="woTtFU.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/woTUW4"><img src="https://s1.ax1x.com/2020/09/20/woTUW4.png" alt="woTUW4.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/woTwl9"><img src="https://s1.ax1x.com/2020/09/20/woTwl9.png" alt="woTwl9.png"></a></p>
<h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/woTgYD"><img src="https://s1.ax1x.com/2020/09/20/woTgYD.png" alt="woTgYD.png"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/19/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98/" data-id="ckfo4q45p0011vkvwcdq77q3n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ReentrantLock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/19/ReentrantLock/" class="article-date">
  <time datetime="2020-09-19T02:55:38.433Z" itemprop="datePublished">2020-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/19/ReentrantLock/">ReentrantLock</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>相对于synchronized它具备如下特点</p>
<p>​     ● 可中断<br>  ● 可以设置超时时间<br>  ● 可以设置为公平锁<br>  ● 支持多个条件变量<br>  ● 与 synchronized 一样，都支持可重入</p>
<p><strong>基本语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取锁</span></span><br><span class="line">reentrantLock.lock();<span class="comment">//此行放在try块内和外效果都一样</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">//临界区</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">//释放锁</span></span><br><span class="line">	reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可重入</strong></p>
<p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁；如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">            m1();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;m1执行&quot;</span>);</span><br><span class="line">            m2();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;m2执行&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">尝试获得锁</span><br><span class="line">获得锁</span><br><span class="line">m1执行</span><br><span class="line">m2执行</span><br></pre></td></tr></table></figure>

<p><strong>可打断</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">                lock.lockInterruptibly();<span class="comment">//可打断的一种锁</span></span><br><span class="line">                <span class="comment">//lock.lock();//是不可被打断的</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;被打断&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">            t1.start();</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            t1.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main获得锁</span><br><span class="line">t1尝试获得锁</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">t1被打断</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">898</span>)</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">1222</span>)</span><br><span class="line">	at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">335</span>)</span><br><span class="line">	at Test02.lambda$main$<span class="number">0</span>(Test02.java:<span class="number">13</span>)</span><br><span class="line">	at Test02$$Lambda$<span class="number">1</span>/<span class="number">650898.</span>run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure>

<p>注意如果是不可中断模式，那么即使使用了interrupt也不会让等待中断</p>
<p><strong>锁超时</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得锁失败&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">                System.out.println(<span class="string">&quot;被打断了&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main获得锁</span><br><span class="line">t1尝试获得锁</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">被打断了</span><br><span class="line">main释放锁</span><br></pre></td></tr></table></figure>

<p><strong>锁超时解决哲学家就餐问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Chopstick c1 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Chopstick c2 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Chopstick c3 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        Chopstick c4 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        Chopstick c5 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        Philosopher t1 = <span class="keyword">new</span> Philosopher(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2);</span><br><span class="line">        Philosopher t2 = <span class="keyword">new</span> Philosopher(<span class="string">&quot;柏拉图&quot;</span>, c2, c3);</span><br><span class="line">        Philosopher t3 = <span class="keyword">new</span> Philosopher(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4);</span><br><span class="line">        Philosopher t4 = <span class="keyword">new</span> Philosopher(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5);</span><br><span class="line">        Philosopher t5 = <span class="keyword">new</span> Philosopher(<span class="string">&quot;阿基米德&quot;</span>, c5, c1);</span><br><span class="line">        t1.setName(<span class="string">&quot;苏格拉底&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.setName(<span class="string">&quot;柏拉图&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.setName(<span class="string">&quot;亚里士多德&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.setName(<span class="string">&quot;赫拉克利特&quot;</span>);</span><br><span class="line">        t4.start();</span><br><span class="line">        t5.setName(<span class="string">&quot;阿基米德&quot;</span>);</span><br><span class="line">        t5.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//　尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">if</span> (left.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 尝试获得右手筷子</span></span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock())&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                eat();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chopstick</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>公平锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock(<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<p>对象先入先获得锁</p>
<p>公平锁一般没有必要，会降低并发度，后面会学。</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized中也有条件变量，就是我们将原理时那个waitSet休息室，当条件不满足时进入waitSet等待</p>
<p>ReentrantLock的条件变量比synchronized强大之处在于，它是支持多个条件变量的，这就好比</p>
<ul>
<li>synchronized是那些不满足条件的线程都在一间休息室等消息</li>
<li>而ReentrantLock支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li>
</ul>
<p>使用流程</p>
<ul>
<li>await前需要获得锁</li>
<li>await执行后，会释放锁，进入conditionObject等待</li>
<li>await的线程被唤醒（或打断、或超时）取重新竞争lock锁</li>
<li>竞争lock锁成功后，从await后继续执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasCigarette = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasTakeout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">static</span> ReentrantLock room = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//创建等烟休息室</span></span><br><span class="line">    <span class="keyword">static</span> Condition waitHasCigarette = room.newCondition();</span><br><span class="line">    <span class="comment">//创建等外卖的休息室</span></span><br><span class="line">    <span class="keyword">static</span> Condition waitHasTakeout = room.newCondition();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                room.lock();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有烟吗&quot;</span> + hasCigarette);</span><br><span class="line">                        <span class="keyword">while</span> (!hasCigarette)&#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没烟先歇会&quot;</span>);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                waitHasCigarette.await();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;干活了&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        room.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                room.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有外卖吗&quot;</span> + hasTakeout);</span><br><span class="line">                    <span class="keyword">while</span> (!hasTakeout)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没外卖先歇会&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            waitHasTakeout.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    room.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                room.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    hasTakeout= <span class="keyword">true</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有外卖了奥！&quot;</span>);</span><br><span class="line">                    waitHasTakeout.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    room.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                room.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    hasCigarette= <span class="keyword">true</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有烟了奥！&quot;</span>);</span><br><span class="line">                    waitHasCigarette.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    room.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">小南有烟吗<span class="keyword">false</span></span><br><span class="line">小南没烟先歇会</span><br><span class="line">小女有外卖吗<span class="keyword">false</span></span><br><span class="line">小女没外卖先歇会</span><br><span class="line">送外卖的有外卖了奥！</span><br><span class="line">小女干活了</span><br><span class="line">送烟的有烟了奥！</span><br><span class="line">小南干活了</span><br></pre></td></tr></table></figure>

<h4 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h4><h5 id="固定运行顺序"><a href="#固定运行顺序" class="headerlink" title="固定运行顺序"></a><strong>固定运行顺序</strong></h5><p>比如：必须先2后1打印</p>
<p><strong>wait notify版</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> t2Runned = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (!t2Runned)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                    t2Runned = <span class="keyword">true</span>;</span><br><span class="line">                    lock.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>park/unpark版</strong></p>
<p>(简洁,没有锁的概念，以线程为单位，唤醒线程)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                LockSupport.unpark(t1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>ReentrantLock版</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> t2Runned = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!t2Runned)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            condition.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                    t2Runned = <span class="keyword">true</span>;</span><br><span class="line">                    condition.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h5 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h5><p>线程1输出a5次，线程2输出b5次，线程3输出c5次，现在要求输出abcabcabcabcabc怎么实现。</p>
<p><strong>使用wait/notify版</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitNotify wn = <span class="keyword">new</span> WaitNotify(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            wn.print(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            wn.print(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            wn.print(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str,<span class="keyword">int</span> falg,<span class="keyword">int</span> nextFalg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">this</span>.falg != falg)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                <span class="keyword">this</span>.falg = nextFalg;</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line">    <span class="comment">//标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> falg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitNotify</span><span class="params">(<span class="keyword">int</span> loopNumber, <span class="keyword">int</span> falg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">        <span class="keyword">this</span>.falg = falg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果；</span><br><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure>

<p><strong>使用ReentrantLock （休息室Condition</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AwaitSignal awaitSignal = <span class="keyword">new</span> AwaitSignal(<span class="number">5</span>);</span><br><span class="line">        Condition a = awaitSignal.newCondition();</span><br><span class="line">        Condition b = awaitSignal.newCondition();</span><br><span class="line">        Condition c = awaitSignal.newCondition();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;a&quot;</span>,a,b);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;b&quot;</span>,b,c);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;c&quot;</span>,c,a);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开始------------------&quot;</span>);</span><br><span class="line">            a.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str,Condition condition,Condition next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwaitSignal</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">开始------------------</span><br><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure>

<p><strong>使用park/unpark(简洁,没有锁的概念，以线程为单位，唤醒线程)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test07</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Thread t1;</span><br><span class="line">    <span class="keyword">static</span> Thread t2;</span><br><span class="line">    <span class="keyword">static</span> Thread t3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ParkUnpark pu = <span class="keyword">new</span> ParkUnpark(<span class="number">5</span>);</span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            pu.print(<span class="string">&quot;a&quot;</span>,t2);</span><br><span class="line">        &#125;);</span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            pu.print(<span class="string">&quot;b&quot;</span>,t3);</span><br><span class="line">        &#125;);</span><br><span class="line">        t3 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            pu.print(<span class="string">&quot;c&quot;</span>,t1);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkUnpark</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str,Thread next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParkUnpark</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure>

<h4 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wI3v80"><img src="https://s1.ax1x.com/2020/09/19/wI3v80.png" alt="wI3v80.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wI8pKU"><img src="https://s1.ax1x.com/2020/09/19/wI8pKU.png" alt="wI8pKU.png"></a></p>
<p>保护性暂停：一个线程需要等待另一个线程的结果，—对应关系</p>
<p>生产者消费者：不是一一对应关系</p>
<p>顺序控制：控制线程的执行顺序。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/19/ReentrantLock/" data-id="ckfo4q45p0010vkvw1qcqd3ug" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程共享模型之管程（二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time datetime="2020-09-18T01:01:25.895Z" itemprop="datePublished">2020-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/">Java并发编程共享模型之管程（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="Java并发编程共享模型之管程（二）"><a href="#Java并发编程共享模型之管程（二）" class="headerlink" title="Java并发编程共享模型之管程（二）"></a>Java并发编程共享模型之管程（二）</h1><h4 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h4><p>本文主要记录wait/notify的正确使用姿势、park/unpark、jion()的原理、模式之生产者-消费者模式（异步）、保护性暂停模式（同步）、线程状态转换的流程、死锁和活锁以及如何检查死锁等。</p>
<h4 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait notify"></a>wait notify</h4><p><strong>小故事-为什么需要wait</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfLZTS"><img src="https://s1.ax1x.com/2020/09/18/wfLZTS.png" alt="wfLZTS.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfLmFg"><img src="https://s1.ax1x.com/2020/09/18/wfLmFg.png" alt="wfLmFg.png"></a></p>
<p><strong>原理之wait/notify</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfLuWj"><img src="https://s1.ax1x.com/2020/09/18/wfLuWj.png" alt="wfLuWj.png"></a></p>
<p>*Owner线程发现条件不满足，调用wait方法，即可进入WaitSet变为WAITING状态</p>
<p>*BLOCKED和WAITING的线程都处于阻塞状态，不占用CPU时间片</p>
<p>*BLOCKED线程会在Owner线程释放锁时唤醒</p>
<p>*WAITING线程会在Owner线程调用notify或notifyAll时唤醒，但唤醒后并不意味立即获得锁，仍需进入EntryList重新竞争。</p>
<h4 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h4><p>*obj.wait()让进入object监视器的线程到waitSet等待</p>
<p>*obj.notify()在object上在waitSet等待的线程中挑一个唤醒</p>
<p>*obj.notifyAll()让object上正在waitSet等待全部唤醒</p>
<p>它们都是线程之间进行协作的手段，都属于Object对象的方法。<strong>必须获得此对象的锁</strong>，才能调用这几个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1线程执行....&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1线程醒了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2线程执行....&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2线程醒了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line"><span class="comment">//            lock.notify();//随机唤醒waitSet中的一个线程</span></span><br><span class="line">            lock.notifyAll();<span class="comment">//唤醒所有waitSet中的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">t1线程执行....</span><br><span class="line">t2线程执行....</span><br><span class="line">t2线程醒了</span><br><span class="line">t1线程醒了</span><br></pre></td></tr></table></figure>

<h4 id="使用wait-notify的正确姿势"><a href="#使用wait-notify的正确姿势" class="headerlink" title="使用wait notify的正确姿势"></a>使用wait notify的正确姿势</h4><p>开始之前先看看</p>
<p><strong>sleep(long n)和wait(long n)的区别</strong></p>
<p>1）sleep是Thread方法，而wait是Object的方法</p>
<p>2）sleep不需要强制和sychronezed配合使用，但wait需要和synchronized一起用</p>
<p>3）sleep在睡眠的同时，不会释放对象锁，但wait在等待的时候会释放对象锁、</p>
<p><strong>相同点</strong></p>
<p>4）它们的状态都是TIMED_WAITING</p>
<p><strong>step1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object room = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> hasCigarette = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> hasTakeout = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<p>思考下面的解决方案好不好，为什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasCigarette = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasTakeout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有烟吗&quot;</span> + hasCigarette);</span><br><span class="line">                    <span class="keyword">if</span> (!hasCigarette)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没烟先歇会&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;有烟吗&quot;</span> + hasCigarette);</span><br><span class="line">                    <span class="keyword">if</span> (hasCigarette)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;干活了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+(<span class="string">&quot;开始干活&quot;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;其他人&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            hasCigarette = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有烟了奥！&quot;</span>);</span><br><span class="line">            <span class="comment">/*synchronized (lock)&#123;</span></span><br><span class="line"><span class="comment">                hasCigarette = true;</span></span><br><span class="line"><span class="comment">                System.out.println(Thread.currentThread().getName()+&quot;有烟了奥！&quot;);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">小南有烟吗<span class="keyword">false</span></span><br><span class="line">小南没烟先歇会</span><br><span class="line">送烟的有烟了奥！</span><br><span class="line">有烟吗<span class="keyword">true</span></span><br><span class="line">小南干活了</span><br><span class="line">其他人开始干活</span><br><span class="line">其他人开始干活</span><br><span class="line">其他人开始干活</span><br><span class="line">其他人开始干活</span><br><span class="line">其他人开始干活</span><br></pre></td></tr></table></figure>

<p>*其它干活的线程，都要一直阻塞，效率太低</p>
<p>*小南线程必须睡足2s后才能醒来，就算烟提前送到，也无法立刻醒来</p>
<p>*加了synchronized(lock)后，就好比小南在里面反锁了门睡觉，烟根本没法送进门，main没加synchronized就好像main线程是翻窗户进来的</p>
<p>*解决方案，使用wait-notify机制</p>
<p><strong>step2</strong></p>
<p>思考下面的实现行吗，为什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasCigarette = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasTakeout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有烟吗&quot;</span> + hasCigarette);</span><br><span class="line">                    <span class="keyword">if</span> (!hasCigarette)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没烟先歇会&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;有烟吗&quot;</span> + hasCigarette);</span><br><span class="line">                    <span class="keyword">if</span> (hasCigarette)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;干活了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+(<span class="string">&quot;开始干活&quot;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;其他人&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                hasCigarette = <span class="keyword">true</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有烟了奥！&quot;</span>);</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">其他人开始干活</span><br><span class="line">其他人开始干活</span><br><span class="line">其他人开始干活</span><br><span class="line">小南有烟吗<span class="keyword">false</span></span><br><span class="line">小南没烟先歇会</span><br><span class="line">其他人开始干活</span><br><span class="line">其他人开始干活</span><br><span class="line">送烟的有烟了奥！</span><br><span class="line">有烟吗<span class="keyword">true</span></span><br><span class="line">小南干活了</span><br></pre></td></tr></table></figure>

<p>*解决了其它干活的线程阻塞的问题</p>
<p>*但如果有其他线程也在等待条件呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasCigarette = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasTakeout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有烟吗&quot;</span> + hasCigarette);</span><br><span class="line">                    <span class="keyword">if</span> (!hasCigarette)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没烟先歇会&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;有烟吗&quot;</span> + hasCigarette);</span><br><span class="line">                    <span class="keyword">if</span> (hasCigarette)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;干活了&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没干成活&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有外卖吗&quot;</span> + hasTakeout);</span><br><span class="line">                    <span class="keyword">if</span> (!hasTakeout)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没外卖先歇会&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有外卖吗&quot;</span> + hasTakeout);</span><br><span class="line">                    <span class="keyword">if</span> (hasTakeout)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;干活了&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没干成活&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                hasTakeout= <span class="keyword">true</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有外卖了奥！&quot;</span>);</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">小南有烟吗<span class="keyword">false</span></span><br><span class="line">小南没烟先歇会</span><br><span class="line">小女有外卖吗<span class="keyword">false</span></span><br><span class="line">小女没外卖先歇会</span><br><span class="line">送外卖的有外卖了奥！</span><br><span class="line">有烟吗<span class="keyword">false</span></span><br><span class="line">小南没干成活</span><br></pre></td></tr></table></figure>

<p>*notify只能随机唤醒一个WaitSet中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程，称之为【虚假唤醒】</p>
<p>*解决方法，改为notifyAll</p>
<p><strong>step4</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasCigarette = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasTakeout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有烟吗&quot;</span> + hasCigarette);</span><br><span class="line">                    <span class="keyword">if</span> (!hasCigarette)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没烟先歇会&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;有烟吗&quot;</span> + hasCigarette);</span><br><span class="line">                    <span class="keyword">if</span> (hasCigarette)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;干活了&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没干成活&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有外卖吗&quot;</span> + hasTakeout);</span><br><span class="line">                    <span class="keyword">if</span> (!hasTakeout)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没外卖先歇会&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有外卖吗&quot;</span> + hasTakeout);</span><br><span class="line">                    <span class="keyword">if</span> (hasTakeout)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;干活了&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没干成活&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                hasTakeout= <span class="keyword">true</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有外卖了奥！&quot;</span>);</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">小南有烟吗<span class="keyword">false</span></span><br><span class="line">小南没烟先歇会</span><br><span class="line">小女有外卖吗<span class="keyword">false</span></span><br><span class="line">小女没外卖先歇会</span><br><span class="line">送外卖的有外卖了奥！</span><br><span class="line">小女有外卖吗<span class="keyword">true</span></span><br><span class="line">小女没干成活</span><br><span class="line">有烟吗<span class="keyword">false</span></span><br><span class="line">小南没干成活</span><br></pre></td></tr></table></figure>

<p>*用notifyAll仅解决某个线程的唤醒问题，但使用if + wait判断仅有一次机会，一旦条件不成立，就没有重新判断的机会了</p>
<p>*解决方法，用while+wait当条件不成立，再次wait。</p>
<p><strong>step5</strong></p>
<p>将if改为while</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo05</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasCigarette = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> hasTakeout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有烟吗&quot;</span> + hasCigarette);</span><br><span class="line">                    <span class="keyword">while</span> (!hasCigarette)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没烟先歇会&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;有烟吗&quot;</span> + hasCigarette);</span><br><span class="line">                    <span class="keyword">if</span> (hasCigarette)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;干活了&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没干成活&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有外卖吗&quot;</span> + hasTakeout);</span><br><span class="line">                    <span class="keyword">while</span> (!hasTakeout)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没外卖先歇会&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有外卖吗&quot;</span> + hasTakeout);</span><br><span class="line">                    <span class="keyword">if</span> (hasTakeout)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;干活了&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;没干成活&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                hasTakeout= <span class="keyword">true</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;有外卖了奥！&quot;</span>);</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">小南有烟吗<span class="keyword">false</span></span><br><span class="line">小南没烟先歇会</span><br><span class="line">小女有外卖吗<span class="keyword">false</span></span><br><span class="line">小女没外卖先歇会</span><br><span class="line">送外卖的有外卖了奥！</span><br><span class="line">小女有外卖吗<span class="keyword">true</span></span><br><span class="line">小女干活了</span><br><span class="line">小南没烟先歇会</span><br></pre></td></tr></table></figure>

<p>wait/notify的正确使用姿势</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">synchronezed(lock)&#123;</span><br><span class="line">	<span class="keyword">while</span>(条件不成立)&#123;</span><br><span class="line">		lock.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//干活</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">	lock.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="模式篇"><a href="#模式篇" class="headerlink" title="模式篇"></a>模式篇</h1><h4 id="1、保护性暂停"><a href="#1、保护性暂停" class="headerlink" title="1、保护性暂停"></a>1、保护性暂停</h4><h4 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h4><p>定义：即Guarded Suspension,用在一个线程等待另一个线程的执行结果</p>
<p><strong>要点</strong></p>
<p>*有一个结果需要从一个线程传递到另一个线程，让他们关联同一个Guarded Object</p>
<p>*如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</p>
<p>*JDK中，join的实现，Future的实现，采用的就是此模式</p>
<p>*因为要等待另一方的结果，因此归类到同步模式</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/whxxU0"><img src="https://s1.ax1x.com/2020/09/18/whxxU0.png" alt="whxxU0.png"></a></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGurad</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GuardedObject guardedObject = <span class="keyword">new</span> GuardedObject();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//等待结果</span></span><br><span class="line">            Object o = guardedObject.get();</span><br><span class="line">            <span class="keyword">int</span> sum = (<span class="keyword">int</span>)o;</span><br><span class="line">            System.out.println(sum);<span class="comment">//9</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//执行操作返回结果</span></span><br><span class="line">            <span class="keyword">int</span> sum = Sum.sum(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">            guardedObject.complete(sum);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>好处</strong></p>
<p>*返回值的线程不用结束，还能干别的事</p>
<p>*这里的变量都是局部变量</p>
<p><strong>增加超时效果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuardedSuspensionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GuardedObject1 guardedObject = <span class="keyword">new</span> GuardedObject1();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//等待结果</span></span><br><span class="line">            Object o = guardedObject.get(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(o);<span class="comment">//null</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//执行操作返回结果</span></span><br><span class="line">            <span class="keyword">int</span> sum = Sum.sum(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">            guardedObject.complete(sum);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuardedObject1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> passTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//waitTime为这一轮循环应该等待的时间</span></span><br><span class="line">                <span class="keyword">long</span> waitTime = timeout - passTime;</span><br><span class="line">                <span class="comment">//经历的时间超过超时时间就退出循环不再等待</span></span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait(waitTime);<span class="comment">//避免虚假唤醒的情况，下一轮就不用等待timeout这么多时间了</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                passTime = System.currentTimeMillis() - begin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="join-的原理"><a href="#join-的原理" class="headerlink" title="join()的原理"></a>join()的原理</h4><p>join()方法的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>多任务版GuardObject(一个线程对应一个GuardObject)</strong></p>
<p>图中Futures就好比居民楼一层的信箱（每个信箱有房间编号），左侧的t0,t2,t4,就好比等待邮件的居民，右侧的t1,t3,t5就好比邮递员</p>
<p>如果需要在多个类之间使用GuardObject对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/whx5UP"><img src="https://s1.ax1x.com/2020/09/18/whx5UP.png" alt="whx5UP.png"></a></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Person().start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;</span><br><span class="line">            <span class="keyword">new</span> Postman(id,<span class="string">&quot;内容&quot;</span> + id).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//收信</span></span><br><span class="line">        GuardedObject2 guardedObject2 = Mailboxes.createGuardedObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始收信id:&quot;</span> + guardedObject2.getId());</span><br><span class="line">        Object mail = guardedObject2.get(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;收到信id:&quot;</span> + guardedObject2.getId() + <span class="string">&quot;收到信内容：&quot;</span> + mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Postman</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String mail;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Postman</span><span class="params">(<span class="keyword">int</span> id,String mail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.mail = mail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GuardedObject2 guardedObject2 = Mailboxes.getGuardedObject(id);</span><br><span class="line">        System.out.println(<span class="string">&quot;送信id:&quot;</span> + id + <span class="string">&quot;内容：&quot;</span>+ mail);</span><br><span class="line">        guardedObject2.complete(mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//信箱</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mailboxes</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,GuardedObject2&gt; boxes = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    <span class="comment">// 产生唯一 id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">generateId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GuardedObject2 <span class="title">getGuardedObject</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据id获取到box并删除对应的key和value,避免堆内存爆了</span></span><br><span class="line">        <span class="keyword">return</span> boxes.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GuardedObject2 <span class="title">createGuardedObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        GuardedObject2 go = <span class="keyword">new</span> GuardedObject2(generateId());</span><br><span class="line">        boxes.put(go.getId(),go);</span><br><span class="line">        <span class="keyword">return</span> go;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title">getIds</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuardedObject2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GuardedObject2</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> passTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//waitTime为这一轮循环应该等待的时间</span></span><br><span class="line">                <span class="keyword">long</span> waitTime = timeout - passTime;</span><br><span class="line">                <span class="comment">//经历的时间超过超时时间就退出循环不再等待</span></span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait(waitTime);<span class="comment">//避免虚假唤醒的情况，下一轮就不用等待timeout这么多时间了</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                passTime = System.currentTimeMillis() - begin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">开始收信id:<span class="number">2</span></span><br><span class="line">开始收信id:<span class="number">1</span></span><br><span class="line">开始收信id:<span class="number">3</span></span><br><span class="line">送信id:<span class="number">3</span>内容：内容<span class="number">3</span></span><br><span class="line">送信id:<span class="number">1</span>内容：内容<span class="number">1</span></span><br><span class="line">收到信id:<span class="number">3</span>收到信内容：内容<span class="number">3</span></span><br><span class="line">收到信id:<span class="number">1</span>收到信内容：内容<span class="number">1</span></span><br><span class="line">送信id:<span class="number">2</span>内容：内容<span class="number">2</span></span><br><span class="line">收到信id:<span class="number">2</span>收到信内容：内容<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="异步模式之生产者-消费者"><a href="#异步模式之生产者-消费者" class="headerlink" title="异步模式之生产者/消费者"></a>异步模式之生产者/消费者</h4><p><strong>要点</strong></p>
<p>*与前面的保护性暂停中的GuardedObject不同，不需要产生结果和消费结果的线程一一对应。</p>
<p>*消费队列可以用来平衡生产和消费的线程资源。</p>
<p>*生产者仅负责产生数据，不关心数据该如何处理，而消费者专心处理数据。</p>
<p>*消息队列是有容量限制的，满时不会再加数据，空时不会在消耗数据。</p>
<p>*JDK中各种阻塞队列，采用的就是这种模式。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w4SxpT"><img src="https://s1.ax1x.com/2020/09/18/w4SxpT.png" alt="w4SxpT.png"></a></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = <span class="keyword">new</span> MessageQueue(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                queue.put(<span class="keyword">new</span> Message(id,id ));</span><br><span class="line">            &#125;,<span class="string">&quot;生产者&quot;</span> + id).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                queue.take();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消息队列类，Java线程之间通信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span></span>&#123;</span><br><span class="line">    <span class="comment">//消息的队列集合</span></span><br><span class="line">    LinkedList&lt;Message&gt; list = <span class="keyword">new</span> LinkedList&lt;Message&gt;();</span><br><span class="line">    <span class="comment">//队列的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capcity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageQueue</span><span class="params">(<span class="keyword">int</span> capcity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">take</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 检查队列是否为空</span></span><br><span class="line">        <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">            <span class="keyword">while</span> (list.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;队列为空，消费者进入等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从队列头部获取消息并返回</span></span><br><span class="line">            Message message = list.removeFirst();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;以消费消息&quot;</span> + message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">            <span class="comment">// 检查对象是否已满</span></span><br><span class="line">            <span class="keyword">while</span> (list.size() == capcity)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;队列已满，生产者进入等待&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将消息加入队列尾部</span></span><br><span class="line">            list.addLast(message);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;以生产消息&quot;</span>);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">int</span> id, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Message&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">生产者<span class="number">2</span>以生产消息</span><br><span class="line">生产者<span class="number">0</span>以生产消息</span><br><span class="line">生产者<span class="number">1</span>队列已满，生产者进入等待</span><br><span class="line">消费者以消费消息Message&#123;id=<span class="number">2</span>, value=<span class="number">2</span>&#125;</span><br><span class="line">生产者<span class="number">1</span>以生产消息</span><br><span class="line">消费者以消费消息Message&#123;id=<span class="number">0</span>, value=<span class="number">0</span>&#125;</span><br><span class="line">消费者以消费消息Message&#123;id=<span class="number">1</span>, value=<span class="number">1</span>&#125;</span><br><span class="line">消费者队列为空，消费者进入等待</span><br></pre></td></tr></table></figure>

<h4 id="Park-amp-Unpark"><a href="#Park-amp-Unpark" class="headerlink" title="Park&amp;Unpark"></a>Park&amp;Unpark</h4><p><strong>基本使用</strong></p>
<p>他们是LockSupport类中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暂停当前线程</span></span><br><span class="line">LockSupport.park();</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(暂停线程对象);</span><br></pre></td></tr></table></figure>

<p>先park在unpark</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParkUnpark</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;start.....&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;park.....&quot;</span>);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">&quot;repark.....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">start.....</span><br><span class="line">park.....</span><br><span class="line">repark.....</span><br></pre></td></tr></table></figure>

<p><strong>park/unpark与wait/notify的区别</strong></p>
<p><strong>特点</strong></p>
<p>1、wait,notify和notifyAll必须配合Object Monitor一起使用，而park,unpark不必</p>
<p>2、park&amp;unpark是以线程为单位来【阻塞】和【唤醒】线程，而notify只能随机唤醒一个等待线程。</p>
<p>3、park&amp;unpark可以先unpark，而wait&amp;notify不能先notify</p>
<h4 id="原理之park-amp-unpark"><a href="#原理之park-amp-unpark" class="headerlink" title="原理之park&amp;unpark"></a>原理之park&amp;unpark</h4><p>每个线程都有自己的一个Parker对象，由三部分组成_counter , _cond和 _mutex 打个比喻</p>
<p>*线程就像一个旅人，Parker就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter就好比背包中的备用干粮（0为耗尽，1为充足）</p>
<p>*调用park就是要看需不需要停下来歇息</p>
<p>​    *如果备用干粮耗尽，那么钻进帐篷歇息</p>
<p>​    *如果备用干粮充足，那么不需要停留，继续前进</p>
<p>*调用unpark，就好比令干粮充足</p>
<p>​    *如果这时线程还在帐篷，就唤醒让他继续前进</p>
<p>​    *如果这时线程还在运行，那么下次调用park时，仅是消耗掉备用干粮，不需停留继续前进</p>
<p>​        *因为背包空间有限，多次调用unpark仅会补充一份备用干粮</p>
<p>两种情况：</p>
<p>**①先调用park，在调用unpark</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w42AXQ"><img src="https://s1.ax1x.com/2020/09/18/w42AXQ.png" alt="w42AXQ.png"></a></p>
<p>1、当前线程调用Undafe.park方法</p>
<p>2、检查__counter,本情况为0，这时获得_mutex 互斥锁</p>
<p>3、线程进入_cond条件变量阻塞。</p>
<p>4、设置_counter=0</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w42Y7R"><img src="https://s1.ax1x.com/2020/09/18/w42Y7R.png" alt="w42Y7R.png"></a></p>
<p>1、调用Unsafe.unpark(Thread_0)方法，设置_counter为1</p>
<p>2、唤醒_cond条件变量中的Thread_0</p>
<p>3、Thread_0恢复运行</p>
<p>4、设置_counter为0</p>
<p>**②先调用unpark，在调用park</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w42w9K"><img src="https://s1.ax1x.com/2020/09/18/w42w9K.png" alt="w42w9K.png"></a></p>
<p>1、调用Unsafe.unpark(Thread_0)方法，设置_counter为1</p>
<p>2、当前线程调用Unsafe.park()方法</p>
<p>3、检查_counter，本情况为1，这时线程无需阻塞，继续运行</p>
<p>4、设置_counter为0</p>
<h4 id="重新理解线程状态转换"><a href="#重新理解线程状态转换" class="headerlink" title="重新理解线程状态转换"></a>重新理解线程状态转换</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w422Nt"><img src="https://s1.ax1x.com/2020/09/18/w422Nt.png" alt="w422Nt.png"></a></p>
<p>假设有线程Thread t</p>
<p><strong>情况1 NEW –&gt; RUNNABLE</strong></p>
<p>*当调用t.start()方法时，由NEW –&gt; RUNNABLE</p>
<p><strong>情况2 RUNNABLE  &lt;–&gt;WAITING</strong></p>
<p>t线程用synchronized(obj)获取对象锁后</p>
<p>​    *调用obj.wait()方法时，t线程从RUNNABLE –&gt;WAITING</p>
<p>​    *调用obj.notify(),obj.notifyAll(),t.interrupt()时</p>
<p>​        *竞争成功，t线程从WAITING–&gt;RUNNABLE</p>
<p>​        *竞争锁失败，t线程从WAITING–&gt;BLOCKED</p>
<p><strong>情况3 RUNNABLE &lt;–&gt;WAITING</strong></p>
<p>*当前线程调用t.join()方法时，当前线程RUNNABLE –&gt;WAITING</p>
<p>​    *注意是当前线程在t线程对象的监视器上等待</p>
<p>*t线程运行结束，或调用了当前线程的 interrupt（）时，当前线程从 WAITING–&gt;RUNNABLE</p>
<p><strong>情况4 RUNNABLE &lt;–&gt;WAITING</strong></p>
<p>*当前线程调用 LockSupport.park() 方法会让当前线程从RUNNABLE –&gt;WAITING</p>
<p>*调用 LockSupport.unpark(目标线程)或调用了线程的 interrupt()，会让目标线程从WAITING–&gt;RUNNABLE</p>
<p><strong>情况5 RUNNABLE &lt;–&gt;TIME_WAITING</strong></p>
<p>t线程用synchronized(obj)获取对象锁后</p>
<p>​    *调用obj.wait(long n)方法时，t线程从RUNNABLE –&gt;TIME_WAITING</p>
<p>​    *t线程等待时间超过了n毫秒，或调用obj.notify(),obj.notifyAll(),t.interrupt()时</p>
<p>​        *竞争成功，t线程从TIME_WAITING–&gt;RUNNABLE</p>
<p>​        *竞争锁失败，t线程从TIME_WAITING–&gt;BLOCKED</p>
<p><strong>情况6 RUNNABLE &lt;–&gt;TIME_WAITING</strong></p>
<p>*当前线程调用t.join(long n)方法时，当前线程RUNNABLE –&gt;TIME_WAITING</p>
<p>​    *注意是当前线程在t线程对象的监视器上等待</p>
<p>*当前线程等待时间超过了n毫秒，或t线程运行结束，或调用了当前线程的 interrupt（）时，当前线程从 TIME_WAITING–&gt;RUNNABLE</p>
<p><strong>情况7 RUNNABLE &lt;–&gt;TIME_WAITING</strong></p>
<p>*当前线程调用 Thread.sleep(long n),当前线程从RUNNABLE –&gt;TIME_WAITING </p>
<p>*当前线程等待时间超过了n毫秒，当前线程从 TIME_WAITING–&gt;RUNNABLE</p>
<p><strong>情况8 RUNNABLE &lt;–&gt;TIME_WAITING</strong></p>
<p>*当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis)时，当前线程从RUNNABLE – &gt;TIME_WAITING</p>
<p>*调用 LockSupport.unpark(目标线程) 或调用了线程的 inerrrupt(); 或是等待超时，或让目标线程从TIME_WAITING–&gt;RUNNABLE</p>
<p><strong>情况9 RUNNABLE &lt;–&gt;BLOCKED</strong></p>
<p>*t线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从RUNNABLE –&gt;BLOCKED</p>
<p>*持obj锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中t线程竞争成功，从 BLOCKED–&gt;RUNNABLE ，其它失败的线程仍然 BLOCKED</p>
<p><strong>情况10 RUNNABLE –&gt;TERMINATED</strong></p>
<p>当前线程所有代码运行完毕，进入TERMINATED</p>
<h4 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h4><p><strong>多把不相干的锁</strong></p>
<p>一间大屋子有两个功能：睡觉、学习，互不相干。</p>
<p>现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低</p>
<p>解决方法是准备多个房间（多个对象锁）</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigRoom</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">			sout(<span class="string">&quot;sleeping&quot;</span>);</span><br><span class="line">        	Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">			sout(<span class="string">&quot;studying&quot;</span>)</span><br><span class="line">            Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigRoom</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object studyRoom = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object bedRoom = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(bedRoom)&#123;</span><br><span class="line">			sout(<span class="string">&quot;sleeping&quot;</span>);</span><br><span class="line">        	Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(studyRoom)&#123;</span><br><span class="line">			sout(<span class="string">&quot;studying&quot;</span>)</span><br><span class="line">            Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将锁的粒度细分</p>
<p>*好处，是可以增强并发度</p>
<p>*坏处，如果是一个线程需要同时获得多把锁，就容易发生死锁</p>
<h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4><p><strong>死锁</strong></p>
<p>有这样的情况：一个线程需要同时获得多把锁，这时就容易发生死锁</p>
<p>t1线程获得A对象锁，接下来想获取B对象的锁</p>
<p>t2线程获得B对象锁，接下来获取A对象的锁</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;obj1...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;obj2....&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;obj2...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;obj1....&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj1...</span><br><span class="line">obj2...</span><br></pre></td></tr></table></figure>

<p><strong>定位死锁</strong></p>
<p>*检测死锁可以使用 jconsole工具，或者使用jps定位进程id，再用 jstack定位死锁。</p>
<p>*避免死锁要注意加锁顺序</p>
<p>*另外如果由于某个线程进入死循环，导致其它线程一直等待，对于这种情况Linux下可以通过top先定位到CPU占用高的Java进程，再利用top-Hp进程id 来定位是哪个线程，最后再用jstack排查。</p>
<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w4XZxH"><img src="https://s1.ax1x.com/2020/09/18/w4XZxH.png" alt="w4XZxH.png"></a></p>
<p>有五位哲学家，围坐在圆桌旁。</p>
<p>*它们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。</p>
<p>*吃饭时要用两根筷子吃，桌子共有5根筷子，每位哲学家左右手边各有一根筷子。</p>
<p>*如果筷子被身边的人拿走，自己就得等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Chopstick c1 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Chopstick c2 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Chopstick c3 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        Chopstick c4 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        Chopstick c5 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        Philosopher t1 = <span class="keyword">new</span> Philosopher(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2);</span><br><span class="line">        Philosopher t2 = <span class="keyword">new</span> Philosopher(<span class="string">&quot;柏拉图&quot;</span>, c2, c3);</span><br><span class="line">        Philosopher t3 = <span class="keyword">new</span> Philosopher(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4);</span><br><span class="line">        Philosopher t4 = <span class="keyword">new</span> Philosopher(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5);</span><br><span class="line">        Philosopher t5 = <span class="keyword">new</span> Philosopher(<span class="string">&quot;阿基米德&quot;</span>, c5, c1);</span><br><span class="line">        t1.setName(<span class="string">&quot;苏格拉底&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.setName(<span class="string">&quot;柏拉图&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.setName(<span class="string">&quot;亚里士多德&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.setName(<span class="string">&quot;赫拉克利特&quot;</span>);</span><br><span class="line">        t4.start();</span><br><span class="line">        t5.setName(<span class="string">&quot;阿基米德&quot;</span>);</span><br><span class="line">        t5.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//　尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                <span class="comment">// 尝试获得右手筷子</span></span><br><span class="line">                <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        eat();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chopstick</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序有死锁现象，后面在学</p>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束。</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLiveLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;count:&quot;</span>+ count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;count:&quot;</span>+ count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">t2count:<span class="number">10</span></span><br><span class="line">t1count:<span class="number">10</span></span><br><span class="line">t1count:<span class="number">10</span></span><br><span class="line">t2count:<span class="number">10</span></span><br><span class="line">t1count:<span class="number">11</span></span><br><span class="line">t2count:<span class="number">11</span></span><br><span class="line">t1count:<span class="number">10</span></span><br><span class="line">t2count:<span class="number">11</span></span><br><span class="line">t1count:<span class="number">11</span></span><br><span class="line">t2count:<span class="number">11</span></span><br><span class="line">t1count:<span class="number">11</span></span><br><span class="line">t2count:<span class="number">11</span></span><br><span class="line">t1count:<span class="number">11</span></span><br><span class="line">t2count:<span class="number">11</span></span><br><span class="line">t2count:<span class="number">11</span></span><br><span class="line">t1count:<span class="number">11</span></span><br><span class="line">t1count:<span class="number">12</span></span><br><span class="line">t2count:<span class="number">12</span></span><br><span class="line">t1count:<span class="number">13</span></span><br></pre></td></tr></table></figure>



<h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到CPU调度执行，也不能够结束。</p>
<p>线程饥饿的例子，先来看看使用顺序加锁的方式解决之前的死锁问题：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w5UepR"><img src="https://s1.ax1x.com/2020/09/19/w5UepR.png" alt="w5UepR.png"></a></p>
<p>顺序加锁的解决方案</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w5UQ0O"><img src="https://s1.ax1x.com/2020/09/19/w5UQ0O.png" alt="w5UQ0O.png"></a></p>
<p>将上面哲学家就餐的例子做一下改动就能出现饥饿现象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Chopstick c1 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       Chopstick c2 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">       Chopstick c3 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">       Chopstick c4 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">       Chopstick c5 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">       <span class="keyword">new</span> Philosopher(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line">       <span class="keyword">new</span> Philosopher(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line">       <span class="keyword">new</span> Philosopher(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line">       <span class="keyword">new</span> Philosopher(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line">       <span class="keyword">new</span> Philosopher(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="ckfo4q4ay0019vkvw9uqg6hxc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程共享模型之管程（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2020-09-16T08:30:01.809Z" itemprop="datePublished">2020-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/">Java并发编程共享模型之管程（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="Java并发编程共享模型之管程"><a href="#Java并发编程共享模型之管程" class="headerlink" title="Java并发编程共享模型之管程"></a>Java并发编程共享模型之管程</h1><h4 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h4><p>共享问题</p>
<p>synchronized</p>
<p>线程安全分析</p>
<p>Monitor</p>
<h4 id="共享带来的问题"><a href="#共享带来的问题" class="headerlink" title="共享带来的问题"></a>共享带来的问题</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wggnaD"><img src="https://s1.ax1x.com/2020/09/16/wggnaD.png" alt="wggnaD.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wggJqf"><img src="https://s1.ax1x.com/2020/09/16/wggJqf.png" alt="wggJqf.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wggtZ8"><img src="https://s1.ax1x.com/2020/09/16/wggtZ8.png" alt="wggtZ8.png"></a></p>
<p><img src="https://s1.ax1x.com/2020/09/16/wggdiQ.png" alt="wggdiQ.png"></p>
<p><strong>Java的体现</strong></p>
<p>两个线程对初始值为0的静态变量一个做自增，一个做自减，各做5000次，结果是0吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;count的值是：&quot;</span> + count);<span class="comment">//count的值是：-1089   count的值是：0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次执行的结果几乎都不一样。</p>
<p><strong>问题分析</strong></p>
<p>以上的结果可能是正数、负数、零。为什么呢？因为Java中对静态变量的自增，自减并不是原子操作，要彻底理解，必须从字节码来进行分析。</p>
<p>例如对于i++而言（i为静态变量），实际会产生如下的JVM字节码指令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic	i <span class="comment">//获取静态变量i的值</span></span><br><span class="line">iconst_1	  <span class="comment">//准备常量1</span></span><br><span class="line">iadd	  	  <span class="comment">//自增</span></span><br><span class="line">putstatic     <span class="comment">//检修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure>

<p>而对应i–也是类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic	i <span class="comment">//获取静态变量i的值</span></span><br><span class="line">iconst_1	  <span class="comment">//准备常量1</span></span><br><span class="line">isub	  	  <span class="comment">//自减</span></span><br><span class="line">putstatic     <span class="comment">//检修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure>

<p>而Java的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wg4HeI"><img src="https://s1.ax1x.com/2020/09/16/wg4HeI.png" alt="wg4HeI.png"></a></p>
<p>如果是单线程以上代码是顺序执行（不会交错）没有问题：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wg5m6J"><img src="https://s1.ax1x.com/2020/09/16/wg5m6J.png" alt="wg5m6J.png"></a></p>
<p>但多线程以上代码可能交错运行：</p>
<p>出现负数的情况</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wgIVEt"><img src="https://s1.ax1x.com/2020/09/16/wgIVEt.png" alt="wgIVEt.png"></a></p>
<p>出现正数的情况</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wgIJU0"><img src="https://s1.ax1x.com/2020/09/16/wgIJU0.png" alt="wgIJU0.png"></a></p>
<p><strong>临界区Critical Section</strong></p>
<p>*一个程序运行多个线程本身是没有问题的</p>
<p>*问题出在多个线程访问共享资源</p>
<p>​    *多个线程读共享资源其实也没有问题</p>
<p>​    *在多线程对共享资源读写操作时发生指令交错，就会出现问题</p>
<p>*一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区</p>
<p>例如，下面代码中的临界区</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//临界区</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//临界区</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>竞态条件</strong></p>
<p>多个线程在临界区内执行，由于代码的<strong>执行序列不同</strong>而导致结果无法预测，称之为发生了<strong>竞态条件</strong>。</p>
<h4 id="synchronized解决方法"><a href="#synchronized解决方法" class="headerlink" title="synchronized解决方法"></a>synchronized解决方法</h4><p><strong>应用之互斥</strong></p>
<p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p>
<p>*阻塞式的解决方案：synchronized,Lock</p>
<p>*非阻塞式的解决方案：原子变量</p>
<p>本章使用阻塞式的解决方法：synchronized,来解决上述问题，即俗称【对象锁】，它采用互斥的方式让同一时刻至多只用一个线程持有【对象锁】，其它线程在想获取这个【对象锁】时就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p>
<p><strong>注意</strong></p>
<p>虽然Java中互斥和同步都可以用synchronized关键字来完成，但它们还是有区别的：</p>
<p>1、互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</p>
<p>2、同步是由于线程执行的先后，顺序不同，需要一个线程等待其它线程运行到某个点。</p>
<p><strong>synchronized</strong></p>
<p>语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>（对象）&#123;</span><br><span class="line">	临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;count的值是：&quot;</span> + count);<span class="comment">//count的值是：0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>图解原理</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w2eMDg"><img src="https://s1.ax1x.com/2020/09/16/w2eMDg.md.png" alt="w2eMDg.md.png"></a></p>
<p>synchronized实际使用<strong>对象</strong>保证了<strong>临界区内代码的原子性</strong>，临界区内的代码对外是不可分割的，不会被线程切换所打断。</p>
<p>为了加深理解，请思考下面的问题</p>
<p>1、如果把synchronized（obj）放在for循环的外面，如何理解？–原子性</p>
<p>答：for循环也加了锁，没有锁的for循环，这次就执行不进去，之前是能执行到的，到了加锁的地方才被阻塞住。</p>
<p>2、如果t1 synchronized（obj1）而synchronized（obj2)会怎样运作？–锁对象</p>
<p>没加一样，加锁必须是同一把</p>
<p>3、如果t1 synchronized（obj）而t2没有加会怎么样？如何理解？–锁对象</p>
<p>没加一样，加锁必须是同一把</p>
<p><strong>面向对象的改进</strong></p>
<p>把需要保护的共享变量放入一个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Room room = <span class="keyword">new</span> Room();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                    room.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                    room.decrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;count的值是：&quot;</span> + room.getCount());<span class="comment">//count的值是：0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法上的synchronized"><a href="#方法上的synchronized" class="headerlink" title="方法上的synchronized"></a>方法上的synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(Test.class)&#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不加synchronized的方法</strong></p>
<p>不加synchronized的方法就好比不遵守规则的人，不老实排队（好比翻窗户进去的）</p>
<p><strong>所谓的“线程八锁”</strong></p>
<p>其实就是考察synchronized锁住的是哪个对象，分清this和类对象就可以了。</p>
<h4 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h4><p><strong>成员变量和静态变量是否线程安全？</strong></p>
<p>*如果它们没有共享，则线程安全</p>
<p>*如果它们被共享了。根据它们的状态是否能够改变，又分两种情况</p>
<p>​    *如果只用读操作，则线程安全</p>
<p>​    *如果有读写操作，则这段代码是临界区，需要考虑线程安全</p>
<p><strong>局部变量是否线程安全？</strong></p>
<p>*局部变量是线程安全的</p>
<p>*但局部变量应用的对象则未必</p>
<p>​    *如果该对象没有逃离方法的作用访问，它是线程安全的</p>
<p>​    *如果该对象逃离方法的作用范围，需要考虑线程安全</p>
<p><strong>局部变量线程安全分析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">	i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程调用test1（）方法时局部变量i，会在每个线程的栈帧内存中被创建多分，因此不存在共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	desrciptor: ()v</span><br><span class="line">	flags: ACC_PUBLIC,ACC_STATIC</span><br><span class="line">	Code:</span><br><span class="line">		stack = <span class="number">1</span>,locals=<span class="number">1</span>,args_size=<span class="number">0</span></span><br><span class="line">			<span class="number">0</span>:bipush	<span class="number">10</span></span><br><span class="line">			<span class="number">2</span>:istore_0</span><br><span class="line">			<span class="number">3</span>:iinc		<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">			<span class="number">6</span>:<span class="keyword">return</span></span><br><span class="line">		LineNumberTable:</span><br><span class="line">			line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">			line <span class="number">11</span>: <span class="number">3</span></span><br><span class="line">			line <span class="number">12</span>: <span class="number">6</span></span><br><span class="line">		LocalVariableTable:</span><br><span class="line">			Start	Length	Slot	Name	Signature</span><br><span class="line">				<span class="number">3</span>		<span class="number">4</span>		<span class="number">0</span>		i	I	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w2siqO"><img src="https://s1.ax1x.com/2020/09/16/w2siqO.png" alt="w2siqO.png"></a></p>
<p><strong>局部变量的引用稍有不同</strong></p>
<p>先看一个成员变量的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUMBER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOOP_NUMBER = <span class="number">200</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadUnsafe test = <span class="keyword">new</span> ThreadUnsafe();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    test.method1(LOOP_NUMBER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;thread&quot;</span> + (i + <span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafe</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNunber)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNunber; i++) &#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果其中一种情况是，如果线程2还未add，线程1remove就会报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;thread2&quot;</span> Exception in thread <span class="string">&quot;thread1&quot;</span> java.lang.ArrayIndexOutOfBoundsException: -<span class="number">1</span></span><br><span class="line">	at java.util.ArrayList.remove(ArrayList.java:<span class="number">501</span>)</span><br><span class="line">	at demo.ThreadUnsafe.method3(demo04.java:<span class="number">35</span>)</span><br><span class="line">	at demo.ThreadUnsafe.method1(demo04.java:<span class="number">28</span>)</span><br><span class="line">	at demo.demo04$<span class="number">1.</span>run(demo04.java:<span class="number">17</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException: -<span class="number">1</span></span><br><span class="line">	at java.util.ArrayList.add(ArrayList.java:<span class="number">459</span>)</span><br><span class="line">	at demo.ThreadUnsafe.method2(demo04.java:<span class="number">32</span>)</span><br><span class="line">	at demo.ThreadUnsafe.method1(demo04.java:<span class="number">27</span>)</span><br><span class="line">	at demo.demo04$<span class="number">1.</span>run(demo04.java:<span class="number">17</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>*无论哪个线程中的method2引用的都是同一个对象中的list成员变量</p>
<p>*method3与method2分析相同</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w2cdyt"><img src="https://s1.ax1x.com/2020/09/16/w2cdyt.png" alt="w2cdyt.png"></a></p>
<p><strong>将list修改为局部变量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo05</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUMBER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOOP_NUMBER = <span class="number">200</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Threadsafe test = <span class="keyword">new</span> Threadsafe();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    test.method1(LOOP_NUMBER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;thread&quot;</span> + (i + <span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Threadsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNunber)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNunber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么就不会有上述问题了</p>
<p><strong>分析</strong></p>
<p>1、list是局部变量，每个线程调用时会创建其不同实例，没有共享</p>
<p>2、而method2的参数是从method1中传递过来的，与method1中引用同一个对象</p>
<p>3、method3的参数分析与method2相同</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w22XdK"><img src="https://s1.ax1x.com/2020/09/16/w22XdK.png" alt="w22XdK.png"></a></p>
<p>方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会代理线程安全问题？<br> *情况1：有其它线程调用 method2 和 method3  （不会有线程安全问题）<br> *情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法。会有线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> </span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">		 ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">		 method2(list);</span><br><span class="line">		 method3(list);</span><br><span class="line">	 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">	 	list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">	 <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">	 	list.remove(<span class="number">0</span>);</span><br><span class="line">	 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">	 <span class="meta">@Override</span></span><br><span class="line">		 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">			 <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			 	list.remove(<span class="number">0</span>);</span><br><span class="line">		 		&#125;).start();</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个例子可以看出private或final提供【安全】的意义所在，请体会开闭原则中的【闭】</p>
<p><strong>常见线程安全类</strong></p>
<p>String</p>
<p>Integer</p>
<p>StringBuffer</p>
<p>Random</p>
<p>Vector</p>
<p>Hashtable</p>
<p>java.util.concurrent包下的类</p>
<p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为</p>
<p> *它们的每个方法是原子的<br> *但注意它们多个方法的组合不是原子的，见后面分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hashtable table = <span class="keyword">new</span> Hashtable();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> table.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> table.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p><strong>线程安全类方法的组合</strong></p>
<p>分析下面代码是否线程安全？(不安全)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable table = <span class="keyword">new</span> Hashtable();</span><br><span class="line"><span class="comment">// 线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span>( table.get(<span class="string">&quot;key&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line"> 	table.put(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w2fnrn"><img src="https://s1.ax1x.com/2020/09/16/w2fnrn.png" alt="w2fnrn.png"></a></p>
<h4 id="不可变类线程安全"><a href="#不可变类线程安全" class="headerlink" title="不可变类线程安全"></a>不可变类线程安全</h4><p>String、Integer等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的。</p>
<p>有同学或许有疑问，String有substring等方法【可以】改变值啊，那么这些方法又是如何保证线程安全的呢？</p>
<p><strong>实例分析</strong></p>
<p>例1：Servlet运行在Tomcat环境下并只有一个实例，因此会被Tomcat的多个线程共享使用，因此存在成员变量的共享问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 是否安全？  否：HashMap不是线程安全的，HashTable是</span></span><br><span class="line">	 Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	 <span class="comment">// 是否安全？  是:String 为不可变类，线程安全</span></span><br><span class="line">	 String S1 = <span class="string">&quot;...&quot;</span>;</span><br><span class="line">	 <span class="comment">// 是否安全？ 是</span></span><br><span class="line">	 <span class="keyword">final</span> String S2 = <span class="string">&quot;...&quot;</span>;</span><br><span class="line">	 <span class="comment">// 是否安全？ 否：不是常见的线程安全类</span></span><br><span class="line">	 Date D1 = <span class="keyword">new</span> Date();</span><br><span class="line">	 <span class="comment">// 是否安全？  否：引用值D2不可变，但是日期里面的其它属性比如年月日可变。与字符串的最大区别是Date里面的属性可变。</span></span><br><span class="line">	 <span class="keyword">final</span> Date D2 = <span class="keyword">new</span> Date();</span><br><span class="line"> </span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, 		HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">	  <span class="comment">// 使用上述变量</span></span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 是否安全？  否：Servlet只有一份，userService为其成员变量也只有一份，所以会有多个线程共享使用。</span></span><br><span class="line">	 <span class="keyword">private</span> UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">	 </span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">	 	userService.update(...);</span><br><span class="line">	 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">		 <span class="comment">// 记录调用次数   否：成员变量只有一份</span></span><br><span class="line">		 <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		 </span><br><span class="line">		 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			 <span class="comment">// ...  临界区</span></span><br><span class="line">			 count++;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 是否安全？  否：Spring中没有加Scope默认为单例，因此为成员变量MyAspect会被共享，其成员变量也会被共享。解决：使用环绕通知，将开始时间和结束时间作为环绕通知的局部变量。</span></span><br><span class="line">	 <span class="keyword">private</span> <span class="keyword">long</span> start = <span class="number">0L</span>;</span><br><span class="line">	 </span><br><span class="line">	 <span class="meta">@Before(&quot;execution(* *(..))&quot;)</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 	start = System.nanoTime();</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 <span class="meta">@After(&quot;execution(* *(..))&quot;)</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">		 System.out.println(<span class="string">&quot;cost time:&quot;</span> + (end-start));</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例4：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">		 <span class="comment">// 是否安全    是：UserService不可变，没有地方修改它</span></span><br><span class="line">		 <span class="keyword">private</span> UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">		 </span><br><span class="line">		 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">		 	userService.update(...);</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">		 <span class="comment">// 是否安全     是：Dao不可变</span></span><br><span class="line">		 <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">		 </span><br><span class="line">		 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		 userDao.update();</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123; </span><br><span class="line">		 <span class="comment">// 是否安全   是：没有成员变量，无法修改其状态和属性</span></span><br><span class="line">		 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		 	String sql = <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">		 	<span class="comment">// 是否安全   是：不同线程创建的conn各不相同，都在各自的栈内存中</span></span><br><span class="line">		 	<span class="keyword">try</span> (Connection conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">		 	<span class="comment">// ...</span></span><br><span class="line">		 	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		 	<span class="comment">// ...</span></span><br><span class="line">		 	&#125;</span><br><span class="line">		 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例5：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 是否安全</span></span><br><span class="line">	 <span class="keyword">private</span> UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">	 	userService.update(...);</span><br><span class="line">	 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">	 	<span class="comment">// 是否安全</span></span><br><span class="line">		 <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">		 </span><br><span class="line">		 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		 userDao.update();</span><br><span class="line">		 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">		 <span class="comment">// 是否安全    否：conn为成员变量被多个线程共享</span></span><br><span class="line">		 <span class="keyword">private</span> Connection conn = <span class="keyword">null</span>;</span><br><span class="line">		 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		 String sql = <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">		 conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">		 <span class="comment">// ...</span></span><br><span class="line">		 conn.close();</span><br><span class="line">		 &#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>例6：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 是否安全   是</span></span><br><span class="line">	 <span class="keyword">private</span> UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">	 	userService.update(...);</span><br><span class="line">	 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123; </span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 <span class="comment">//是否安全：   是：因为userDao为局部变量，每个线程创建的都不一样（但不推荐，建议把conn作为线程内的局部变量）</span></span><br><span class="line">	 UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">	 	userDao.update();</span><br><span class="line">	 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 是否安全  </span></span><br><span class="line">	 <span class="keyword">private</span> Connection = <span class="keyword">null</span>;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">	 String sql = <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">	 conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">	 <span class="comment">// ...</span></span><br><span class="line">	 conn.close();</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例7：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 是否安全  否：虽然sdf 是局部变量，但是还要看是否暴露给其它线程</span></span><br><span class="line">	 SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">	 foo(sdf);</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title">foo</span><span class="params">(SimpleDateFormat sdf)</span></span>;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">new</span> Test().bar();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为<strong>外星方法</strong>。不想往外暴露方法设置为final或者private，String类加final就是防止子类将其属性或者状态覆盖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(SimpleDateFormat sdf)</span> </span>&#123;</span><br><span class="line">	 String dateStr = <span class="string">&quot;1999-10-11 00:00:00&quot;</span>;</span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">		 <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		 <span class="keyword">try</span> &#123;</span><br><span class="line">		 	sdf.parse(dateStr);</span><br><span class="line">		 &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">		 	e.printStackTrace();</span><br><span class="line">		 &#125;</span><br><span class="line">		 &#125;).start();</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例8：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer i = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	 List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">		 Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5000</span>; k++) &#123;</span><br><span class="line">		 	<span class="keyword">synchronized</span> (i) &#123;</span><br><span class="line">		 	i++;</span><br><span class="line">		 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;, <span class="string">&quot;&quot;</span> + j);</span><br><span class="line">	 list.add(thread);</span><br><span class="line">	 &#125;</span><br><span class="line">	 list.stream().forEach(t -&gt; t.start());</span><br><span class="line">	 list.stream().forEach(t -&gt; &#123;</span><br><span class="line">		 <span class="keyword">try</span> &#123;</span><br><span class="line">		 	t.join();</span><br><span class="line">		 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		 	e.printStackTrace();</span><br><span class="line">		 &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">  	log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><p><strong>买票练习</strong></p>
<p>测试下面代码是否存在线程安全问题，并尝试改正</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExerciseSellDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//模拟多人卖票</span></span><br><span class="line">        TicketWindow window = <span class="keyword">new</span> TicketWindow(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 所有线程的集合（由于threadList在主线程中，不被共享，因此使用ArrayList不会出现线程安全问题）</span></span><br><span class="line">        List&lt;Thread&gt; threadList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 卖出的票数统计(Vector为线程安全类)</span></span><br><span class="line">        List&lt;Integer&gt; amountList = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> amount = window.sell(random.nextInt(<span class="number">5</span>) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    amountList.add(amount);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threadList.add(thread);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计剩余票数和卖出去的票</span></span><br><span class="line">        System.out.println(<span class="string">&quot;剩余票数：&quot;</span> + window.getCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;卖出去的票数：&quot;</span> + amountList.stream().mapToInt(i -&gt; i).sum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//买票窗口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketWindow</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取票余数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//售票</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">sell</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= amount)&#123;</span><br><span class="line">            <span class="keyword">this</span>.count -= amount;</span><br><span class="line">            <span class="keyword">return</span> amount;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">剩余票数：<span class="number">0</span></span><br><span class="line">卖出去的票数：<span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p><strong>这行代码没成功</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /L %n (<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>) <span class="keyword">do</span> java ExerciseSellDemo</span><br></pre></td></tr></table></figure>

<p><strong>转账练习</strong></p>
<p>测试下面代码是否存在线程安全问题，并尝试改正</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExerciseTransfer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        Account a = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line">        Account b = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                a.transfer(b, random.nextInt(<span class="number">5</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                b.transfer(a, random.nextInt(<span class="number">5</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="comment">// 查看转账2000次后的总金额</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total:&quot;</span>+ (a.getMoney() + b.getMoney()));<span class="comment">//total:2000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Account.class) &#123;   //锁住Account类，因为涉及到A.money和B.money。</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.money &gt;= amount) &#123;</span><br><span class="line">                <span class="keyword">this</span>.setMoney(<span class="keyword">this</span>.getMoney() - amount);</span><br><span class="line">                target.setMoney(target.getMoney() + amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Monintor概念"><a href="#Monintor概念" class="headerlink" title="Monintor概念"></a>Monintor概念</h4><p><strong>对象头</strong></p>
<p>以32位虚拟机为例</p>
<p>普通对象</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfpUc4"><img src="https://s1.ax1x.com/2020/09/17/wfpUc4.png" alt="wfpUc4.png"></a></p>
<p>数组对象</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfpsN6"><img src="https://s1.ax1x.com/2020/09/17/wfpsN6.png" alt="wfpsN6.png"></a></p>
<p>Mark Word结构</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfphDA"><img src="https://s1.ax1x.com/2020/09/17/wfphDA.png" alt="wfphDA.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wf98rd"><img src="https://s1.ax1x.com/2020/09/17/wf98rd.png" alt="wf98rd.png"></a></p>
<p><strong>Monintor</strong></p>
<p>Monintor被翻译为<strong>监视器</strong>或<strong>管程</strong></p>
<p>每个Java对象都可以关联一个Monintor对象，如果使用synchronized给对象（重量级）之后，该对象头的Mark Word中就没设置指向Monintor对象的指针</p>
<p>Monintor结构如下：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfF9eJ"><img src="https://s1.ax1x.com/2020/09/17/wfF9eJ.png" alt="wfF9eJ.png"></a></p>
<p>*刚开始Monintor中Owner位null</p>
<p>*当Thread-2执行sychronized(obj)就会将Monintor的所有者Owner置为Thread-2，Monintor中只能有一个Owner</p>
<p>*在Thread-2上锁的过程中，如果Thread-3,Thread-4,Thread-5也来执行sychronized(obj)，就会进入EntryListBLOCKED</p>
<p>*Thread-2执行完同步代码块的内容，然后唤醒EntryList中等待的竞争锁，竞争时非公平的</p>
<p>*图中WaitSet中的Thread-0,Thread-1是之前获得过锁，但条件不满足进入WAITING状态的线程，后面讲wait-notify时会分析</p>
<p><strong>注意</strong></p>
<p>*synchronized必须是进入同一个对象的monitor才有上述的效果</p>
<p>*不加synchronized的对象不会关联监视器，不遵从以上规则</p>
<p><strong>原理之synchronized</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">		counter++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码为：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfFcXF"><img src="https://s1.ax1x.com/2020/09/17/wfFcXF.png" alt="wfFcXF.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfF4t1"><img src="https://s1.ax1x.com/2020/09/17/wfF4t1.png" alt="wfF4t1.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfkCjS"><img src="https://s1.ax1x.com/2020/09/17/wfkCjS.png" alt="wfkCjS.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfkg8P"><img src="https://s1.ax1x.com/2020/09/17/wfkg8P.png" alt="wfkg8P.png"></a></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁的使用场景：如果一个对象虽然有对线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化</p>
<p>轻量级锁对使用者是透明的，即语法依然是synchronized</p>
<p>假设有两个方法同步块，利用同一个对象加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mehtod1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">		<span class="comment">//同步块A</span></span><br><span class="line">		method2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">		<span class="comment">//同步块B</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*创建锁记录（Lock Record)对象，每个线程的栈帧都会包含一个锁记录的结构，内存可以储存锁定对象的Mark Word</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfemOf"><img src="https://s1.ax1x.com/2020/09/17/wfemOf.png" alt="wfemOf.png"></a></p>
<p>*让记录中Object reference指向锁对象，并尝试用cas替换Object的Mark Word,将Mark Word的值存入锁记录</p>
<p><img src="https://s1.ax1x.com/2020/09/17/wfeY60.png" alt="wfeY60.png"></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfeY60"></a></p>
<p>*如果cas替换成功，对象头存储了锁记录地址和状态00.表示由线程给对象加锁，这时图示如下</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfKkHf"><img src="https://s1.ax1x.com/2020/09/17/wfKkHf.png" alt="wfKkHf.png"></a></p>
<p>*如果cas失败，有两种情况</p>
<p>​    *如果其它线程已经持有了该Object的轻量级锁，这时表明有竞争，进入锁膨胀的过程</p>
<p>​    *如果是自己执行了synchronized锁重入，那么在添加一条Lock Record作为重入的计数。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfK1bV"><img src="https://s1.ax1x.com/2020/09/17/wfK1bV.png" alt="wfK1bV.png"></a></p>
<p>*当退出synchronized代码块（解锁时）如果有取值为null的锁记录，表示有重入，这时重置锁记录，表示重入计数减一。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfKugs"><img src="https://s1.ax1x.com/2020/09/17/wfKugs.png"></a></p>
<p>*当退出synchronized代码块（解锁时）锁记录的值不为null，这时使用cas将Mark Word的值恢复给对象头</p>
<p>​    *成功，则解锁成功</p>
<p>​    *失败，说明轻量级锁进行了膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>
<h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a><strong>锁膨胀</strong></h4><p>如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sychronezed(obj)&#123;</span><br><span class="line">		<span class="comment">//同步块</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfQAfg"><img src="https://s1.ax1x.com/2020/09/17/wfQAfg.png" alt="wfQAfg.png"></a></p>
<p>*这时Thread-1加轻量级锁失败，进入<strong>膨胀流程</strong></p>
<p>​    *即为Object对象<strong>申请Monitor锁</strong>，让Object指向重量级锁地址。</p>
<p>​    *然后自己进入Monitor的EntryListBLOCKED</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfQlkT"><img src="https://s1.ax1x.com/2020/09/17/wfQlkT.png" alt="wfQlkT.png"></a></p>
<p>*当Thread-0推出同步块解锁时，使用cas将Mark Word的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中BLOCKED线程</p>
<h4 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h4><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p>
<p>自旋重试成功的情况</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wf3VpD"><img src="https://s1.ax1x.com/2020/09/17/wf3VpD.png" alt="wf3VpD.png"></a></p>
<p>自旋重试失败的情况</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wf3e6H"><img src="https://s1.ax1x.com/2020/09/17/wf3e6H.png" alt="wf3e6H.png"></a></p>
<p>*在Java6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p>
<p>*自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势。</p>
<p>*Java7之后不能控制是否开启自旋功能。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行CAS操作。</p>
<p>Java6中引入了偏向锁来做进一步优化：只用每一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就归该线程所有</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">		<span class="comment">//同步块A</span></span><br><span class="line">		m2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">		<span class="comment">//同步块B</span></span><br><span class="line">		m3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">		<span class="comment">//同步块C</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>轻量级锁<img src="https://s1.ax1x.com/2020/09/17/wfGFzD.png" alt="wfGFzD.png"></p>
<p>偏向锁</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfGmdI"><img src="https://s1.ax1x.com/2020/09/17/wfGmdI.png" alt="wfGmdI.png"></a></p>
<p><strong>偏向状态</strong></p>
<p>回忆一下对象头格式</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfNHv8"><img src="https://s1.ax1x.com/2020/09/17/wfNHv8.png" alt="wfNHv8.png"></a></p>
<p>一个对象创建时：</p>
<p>*如果开启了偏向锁（默认开启），那么对象创建后，<strong>mark word值为0x05即最后3位为101</strong>，这时它的thread、epoch、age都为0</p>
<p>*偏向锁是<strong>默认是延迟的</strong>，不会在程序启动时立即生效，如果想避免延迟，可以加JVM参数-xx:BiasedLockingStartupDelay=0来禁用延迟</p>
<p>*如果没有开启偏向锁，那么对象创建后，mark word值为0x01即最后3位001，这时它的hashcode、age都为0，第一次用到hashcode时才会赋值。</p>
<p>1）测试延迟特性</p>
<p>2）测试偏向锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>利用jol第三方工具来查看对象头信息（注意这里我扩展了jal让他输出更为简洁）</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfNLDg"><img src="https://s1.ax1x.com/2020/09/17/wfNLDg.png" alt="wfNLDg.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfUSCq"><img src="https://s1.ax1x.com/2020/09/17/wfUSCq.png" alt="wfUSCq.png"></a></p>
<p><strong>注意</strong></p>
<p>处于偏向锁的对象锁后，线程id仍存储于对象头中</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfUiKU"><img src="https://s1.ax1x.com/2020/09/17/wfUiKU.png" alt="wfUiKU.png"></a></p>
<p>4）</p>
<p>使用hashcode会禁用偏向锁</p>
<p><strong>撤销偏向锁</strong></p>
<p>优先状态：偏向锁–&gt;轻量级锁–&gt;重量级锁</p>
<p><strong>撤销-调用对象hashCode</strong></p>
<p>调用了对象的hashCode,但偏向锁的对象mark word中存储的是线程id，如果调用hashCode会导致偏向锁被撤销</p>
<p>*轻量级锁会在锁记录中记录hashCode</p>
<p>*重量级锁会在Monitor中记录hashCode</p>
<p>在调用hashCode后使用偏向锁，记得去掉-xx:UseBiasedLocking</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfUodJ"><img src="https://s1.ax1x.com/2020/09/17/wfUodJ.png" alt="wfUodJ.png"></a></p>
<p><strong>撤销-其它线程使用对象</strong></p>
<p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfUHiR"><img src="https://s1.ax1x.com/2020/09/17/wfUHiR.png" alt="wfUHiR.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfa4pt"><img src="https://s1.ax1x.com/2020/09/17/wfa4pt.png" alt="wfa4pt.png"></a></p>
<p><strong>撤销-调用wait/notify</strong></p>
<p>撤销-调用wait/notify也会使得偏向锁/轻量级锁升级为重量级锁，因为wait/notify为重量级锁的机制。</p>
<p><strong>批量重偏向</strong></p>
<p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程t1的对象仍有机会重新偏向t2，重偏向重置对象的Thread ID</p>
<p><strong>当撤销偏向锁阙值超过20次后</strong>，就、jvm会这样觉得，我是不是偏向错了呢，于是会给这些对象加锁时重新偏向至加锁线程</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wf0511"><img src="https://s1.ax1x.com/2020/09/17/wf0511.png" alt="wf0511.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wf07nK"><img src="https://s1.ax1x.com/2020/09/17/wf07nK.png" alt="wf07nK.png"></a></p>
<p><strong>批量撤销</strong></p>
<p>当撤销偏向阙值超过40次后，jvm会这样觉得，自己确实偏向错了，根本不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wf0b7D"><img src="https://s1.ax1x.com/2020/09/17/wf0b7D.png" alt="wf0b7D.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wf0LAe"><img src="https://s1.ax1x.com/2020/09/17/wf0LAe.png" alt="wf0LAe.png"></a></p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfbVjP"><img src="https://s1.ax1x.com/2020/09/18/wfbVjP.png" alt="wfbVjP.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wfbenf"><img src="https://s1.ax1x.com/2020/09/18/wfbenf.png" alt="wfbenf.png"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/" data-id="ckfo4q4ay0018vkvw5qkf88m4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程之线程基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2020-09-15T07:47:19.713Z" itemprop="datePublished">2020-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">Java并发编程之线程基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>1、程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备，进程就是用来加载指令、管理内存、管理IO的</p>
<p>2、当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</p>
<p>3、进程就可以视为成程序的一个实例，大部分程序可以同时运行对个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360安全卫士等）</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>1、一个进程之内可以分为一到对个线程。</p>
<p>2、一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行。</p>
<p>3、在Java中，线程作为最小调度单位，进程作为资源分配的最小单位，在Windows中进程是不活动的，只是作为线程的容器。</p>
<h4 id="进程和线程的对比"><a href="#进程和线程的对比" class="headerlink" title="进程和线程的对比"></a>进程和线程的对比</h4><p>1、进程基本上相互独立的，而线程存在于进程内，是进程的一个子集。</p>
<p>2、进程拥有共享的资源，如内存空间等，供其内部的线程的线程共享。</p>
<p>3、进程间通信较为复杂</p>
<p>​        同一台计算机的进程通信称为IPC（Inter-process communication)。</p>
<p>​        不同计算机之间的进程通信，需要通过网络，并遵循共同的协议，例如HTTP。</p>
<p>4、线程通信相对简单，因为它们共享进程内的内存，一个例子是对个线程访问同一个共享变量。</p>
<p>5、线程更轻量，线程上下文切换成本一般上要比进程上下文切换低。</p>
<h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><p>一般会将线程轮流使用CPU的做法称为并发，concurrent  微观串行，宏观并行。</p>
<p>多核CPU下，每个核都可以调度运行线程，这时候线程可以是并行的。</p>
<p>*并发：是同一时间应对多件事情的能力。</p>
<p>*并行：是同一时间动手做多件事情的能力。</p>
<h4 id="创建线程的第一种方式"><a href="#创建线程的第一种方式" class="headerlink" title="创建线程的第一种方式"></a>创建线程的第一种方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;HelloWrold&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">&quot;HelloWrold&quot;</span>));</span><br><span class="line">        thread1.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建线程的第二种方式"><a href="#创建线程的第二种方式" class="headerlink" title="创建线程的第二种方式"></a>创建线程的第二种方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;HelloWrlod&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Runnable runnable1 = ()-&gt; System.out.println(<span class="string">&quot;HelloWrold&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable1);</span><br><span class="line">        thread1.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Thread-与-Runnable-的关系"><a href="#Thread-与-Runnable-的关系" class="headerlink" title="Thread 与 Runnable 的关系"></a>Thread 与 Runnable 的关系</h4><p>分析 Thread 的源码，理清它与 Runnable 的关系<br>小结<br> 1、方法一 是把线程和任务合并在了一起，方法二是把线程和任务分开了（推荐）<br> 2、用 Runnable 更容易与线程池等高级 API 配合<br> 3、用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</p>
<h4 id="创建线程的第三种方式"><a href="#创建线程的第三种方式" class="headerlink" title="创建线程的第三种方式"></a>创建线程的第三种方式</h4><p>FutureTask(Callable<V> callable)<br>创建一个 FutureTask ，它将在运行时执行给定的 Callable 。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;running....&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(task,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Integer integer = task.get();</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查看进程线程的方法"><a href="#查看进程线程的方法" class="headerlink" title="查看进程线程的方法"></a>查看进程线程的方法</h4><p>windows</p>
<p>*任务管理器可以查看进程和线程数，也可以用来杀死进程</p>
<p>*tasklist 查看进程（tasklist | findstr java）<br>*taskkill 杀死进程 （taskkill /F /PID 15920）</p>
<p>linux<br> *ps -fe 查看所有进程(ps -fe | grep java)<br> *ps -fT -p 查看某个进程（PID）的所有线程</p>
<p>*kill 杀死进程</p>
<p>*top 按大写 H 切换是否显示线程</p>
<p>*top -H -p 查看某个进程（PID）的所有线程<br>Java</p>
<p>*jps 命令查看所有 Java 进程</p>
<p>*jstack 查看某个 Java 进程（PID）的所有线程状态<br>*jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</p>
<h4 id="jconsole-远程监控配置"><a href="#jconsole-远程监控配置" class="headerlink" title="jconsole 远程监控配置"></a>jconsole 远程监控配置</h4><p>*需要以如下方式运行你的 java 类<br>java -Djava.rmi.server.hostname=<code>ip地址</code> -Dcom.sun.management.jmxremote -<br>Dcom.sun.management.jmxremote.port=<code>连接端口</code> -Dcom.sun.management.jmxremote.ssl=是否安全连接 -<br>Dcom.sun.management.jmxremote.authenticate=是否认证 java类<br> *修改 /etc/hosts 文件将 127.0.0.1 映射至主机名<br>如果要认证访问，还需要做如下步骤</p>
<p>*复制 jmxremote.password 文件</p>
<p>*修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写</p>
<p>*连接时填入 controlRole（用户名），R&amp;D（密码）</p>
<h4 id="原理之线程运行"><a href="#原理之线程运行" class="headerlink" title="原理之线程运行"></a>原理之线程运行</h4><p>栈与栈帧<br>Java Virtual Machine Stacks （Java 虚拟机栈）<br>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟<br>机就会为其分配一块栈内存。<br> *每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存<br> *每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wgyEKf"><img src="https://s1.ax1x.com/2020/09/16/wgyEKf.png" alt="wgyEKf.png"></a></p>
<h4 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码<br> *线程的 cpu 时间片用完<br> *垃圾回收（此时会停止所有的工作进程）<br> *有更高优先级的线程需要运行<br>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法<br>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念<br>就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的<br> *状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等<br> *Context Switch 频繁发生会影响性能</p>
<h4 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w6RGHU"><img src="https://s1.ax1x.com/2020/09/15/w6RGHU.png" alt="w6RGHU.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w6Rob8"><img src="https://s1.ax1x.com/2020/09/15/w6Rob8.png" alt="w6Rob8.png"></a></p>
<h4 id="start与run"><a href="#start与run" class="headerlink" title="start与run"></a>start与run</h4><p>直接调用 run 是在主线程中执行了 run，没有启动新的线程，为普通的方法调用。<br> 使用 start 是启动新的线程，这样虚拟机才会把这个thread与操作系统的线程 一 一对应，通过新的线程间接执行 run 中的代码。</p>
<h4 id="sleep与yield"><a href="#sleep与yield" class="headerlink" title="sleep与yield"></a>sleep与yield</h4><p>sleep:</p>
<p>1、调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）<br>2、其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException<br>3、睡眠结束后的线程未必会立刻得到执行(等待任务调度器分配时间片)<br>4、建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p>
<p>yield:</p>
<p>1、调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程<br>2、具体的实现依赖于操作系统的任务调度器</p>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>void<br>setPriority(int newPriority)<br>更改此线程的优先级。 </p>
<p>线程优先级会提示线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它<br>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p>
<h4 id="sleep的应用防止CPU占用100"><a href="#sleep的应用防止CPU占用100" class="headerlink" title="sleep的应用防止CPU占用100%"></a>sleep的应用防止CPU占用100%</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">	Thread.sleep(<span class="number">50</span>)</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		sout(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="join方法详解"><a href="#join方法详解" class="headerlink" title="join方法详解"></a>join方法详解</h4><p>为什么需要join，打印r是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;wake up....&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                r = <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析<br> 因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 r=10<br> 而主线程一开始就要打印 r 的结果，所以只能打印出 r=0<br>解决方法<br>用 sleep 行不行？为什么？(Sleep时间不好控制)<br>用 join（等待某个进程运行结束），加在 t1.start() 之后即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;wake up....&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                r = <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以调用方角度来讲，如果<br> *需要等待结果返回，才能继续运行就是同步<br> *不需要等待结果返回，就能继续运行就是异步</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wc6FEQ"><img src="https://s1.ax1x.com/2020/09/16/wc6FEQ.png" alt="wc6FEQ.png"></a></p>
<p>等待多个结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> r1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> r2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;wake up....&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                r1 = <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                r2 = <span class="number">20</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> l1 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(r1);</span><br><span class="line">        System.out.println(r2);</span><br><span class="line">        System.out.println((l1-l)+ <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果如下：</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">2010</span>毫秒</span><br></pre></td></tr></table></figure>

<p>分析如下<br> 第一个 join：等待 t1 时, t2 并没有停止, 而在运行<br> 第二个 join：1s 后, 执行到此, t2 也运行了 1s, 因此也只需再等待 1s<br>如果颠倒两个 join 呢？<br> 最终都是输出2010毫秒</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wcRtFe"><img src="https://s1.ax1x.com/2020/09/16/wcRtFe.png" alt="wcRtFe.png"></a></p>
<p>有时效的join</p>
<p>等够时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;wake up....&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                r = <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> l1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println((l1-l) + <span class="string">&quot;毫秒&quot;</span> );<span class="comment">//1020毫秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="interrupt-方法详解"><a href="#interrupt-方法详解" class="headerlink" title="interrupt 方法详解"></a>interrupt 方法详解</h4><p><strong>打断 sleep，wait，join 的线程</strong><br>这几个方法都会让线程进入阻塞状态<br>打断 sleep (阻塞的，会抛出InterruptedException )的线程, 会清空打断状态(置为false)，以 sleep 为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;打断状态：&quot;</span> + t1.isInterrupted());<span class="comment">//打断状态：false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打断正常运行的线程</strong><br>打断正常运行的线程, 不会清空打断状态。（打断状态可以用来作为是否停止线程的标记）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> interrupted = Thread.currentThread().isInterrupted();</span><br><span class="line">                <span class="keyword">if</span> (interrupted == <span class="keyword">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;我被打断了，我自己要停下来&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;打断状态：&quot;</span> + t1.isInterrupted());<span class="comment">//打断状态：true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两阶段终止模式</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wcTczF"><img src="https://s1.ax1x.com/2020/09/16/wcTczF.png" alt="wcTczF.png"></a></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TwoPhaseTermination twoPhaseTermination = <span class="keyword">new</span> TwoPhaseTermination();</span><br><span class="line">        twoPhaseTermination.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        twoPhaseTermination.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseTermination</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        monitor= <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    Thread thread = Thread.currentThread();</span><br><span class="line">                    <span class="keyword">if</span> (thread.isInterrupted() == <span class="keyword">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;执行监控日志&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="comment">//重新设置打断标记</span></span><br><span class="line">                        thread.interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭线程监控</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：isInterrupt()不会清除标记，static boolean interrupted()会清空标记。</strong></p>
<h4 id="打断-park-线程"><a href="#打断-park-线程" class="headerlink" title="打断 park 线程"></a>打断 park 线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;pack.....&quot;</span>);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">&quot;unpack.....&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().isInterrupted());<span class="comment">//不会清除打断标记</span></span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">&quot;unpack.......&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">pack.....</span><br><span class="line">unpack.....</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">unpack.......    </span><br></pre></td></tr></table></figure>

<p><strong>如果打断标记已经是 true, 则 park 会失效</strong></p>
<p><strong>注意：可以使用 Thread.interrupted() 清除打断状态</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;pack.....&quot;</span>);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">&quot;unpack.....&quot;</span>);</span><br><span class="line">                System.out.println(Thread.interrupted());<span class="comment">//会清除打断标记</span></span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">&quot;unpack.......&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">pack.....</span><br><span class="line">unpack.....</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h4 id="不推荐的方法"><a href="#不推荐的方法" class="headerlink" title="不推荐的方法"></a>不推荐的方法</h4><p>还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wgMvFJ"><img src="https://s1.ax1x.com/2020/09/16/wgMvFJ.png" alt="wgMvFJ.png"></a></p>
<h4 id="主线程与守护线程"><a href="#主线程与守护线程" class="headerlink" title="主线程与守护线程"></a>主线程与守护线程</h4><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做<strong>守护线程</strong>，只要其它<strong>非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Thread.currentThread().isInterrupted() == <span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置为守护线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>*其它非守护线程结束了，守护线程的finally块内容不会执行</p>
<p>*<strong>垃圾回收器线程</strong>就是一种守护线程</p>
<p>*Tomcat 中的 <strong>Acceptor 和 Poller 线程</strong>都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</p>
<h4 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h4><p>这是从<strong>操作系统</strong>层面来描述的</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wg3B0f"><img src="https://s1.ax1x.com/2020/09/16/wg3B0f.png" alt="wg3B0f.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wg3sAS"><img src="https://s1.ax1x.com/2020/09/16/wg3sAS.png" alt="wg3sAS.png"></a></p>
<h4 id="六种状态"><a href="#六种状态" class="headerlink" title="六种状态"></a>六种状态</h4><p>这是从Java API层面描述的</p>
<p>根据Thread.State枚举，分为六种状态。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wgG5YF"><img src="https://s1.ax1x.com/2020/09/16/wgG5YF.png" alt="wgG5YF.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wgGTSJ"><img src="https://s1.ax1x.com/2020/09/16/wgGTSJ.png" alt="wgGTSJ.png"></a></p>
<p>六种状态代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (StateTest.class)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t3.start();</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t4.start();</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t2.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t5.start();</span><br><span class="line">        Thread t6 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (StateTest.class) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t6.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t1.getState());<span class="comment">//NEW</span></span><br><span class="line">        System.out.println(t2.getState());<span class="comment">//RUNNABLE</span></span><br><span class="line">        System.out.println(t3.getState());<span class="comment">//TIMED_WAITING</span></span><br><span class="line">        System.out.println(t4.getState());<span class="comment">//TERMINATED</span></span><br><span class="line">        System.out.println(t5.getState());<span class="comment">//WAITING</span></span><br><span class="line">        System.out.println(t6.getState());<span class="comment">//BLOCKED</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="习题：烧水泡茶（统筹规划）"><a href="#习题：烧水泡茶（统筹规划）" class="headerlink" title="习题：烧水泡茶（统筹规划）"></a>习题：烧水泡茶（统筹规划）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始洗水壶&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;开始烧水&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始洗茶壶&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;开始洗茶杯&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;拿茶叶&quot;</span>);</span><br><span class="line">                    t1.join();</span><br><span class="line">                    System.out.println(<span class="string">&quot;开始泡茶&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小王&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">开始洗水壶</span><br><span class="line">开始洗茶壶</span><br><span class="line">开始烧水</span><br><span class="line">开始洗茶杯</span><br><span class="line">拿茶叶</span><br><span class="line">开始泡茶</span><br></pre></td></tr></table></figure>

<p>缺陷：1、如果是老王泡茶，代码还得改。2、如何模拟老王将水壶交给小王，或者模拟小王将茶叶交给老王。</p>
<h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wgDWin"><img src="https://s1.ax1x.com/2020/09/16/wgDWin.png" alt="wgDWin.png"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/" data-id="ckfo4q45o000zvkvw21kqb9rt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-缓冲流、转换流" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/14/%E7%BC%93%E5%86%B2%E6%B5%81%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81/" class="article-date">
  <time datetime="2020-09-14T08:19:47.993Z" itemprop="datePublished">2020-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/14/%E7%BC%93%E5%86%B2%E6%B5%81%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81/">缓冲流、转换流</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><p>缓冲流也叫高效流，是对4个基本FileXxxx流的增强，所以也是4个流。</p>
<p>缓冲流的基本原理：是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p>
<h4 id="字节缓冲输出流"><a href="#字节缓冲输出流" class="headerlink" title="字节缓冲输出流"></a>字节缓冲输出流</h4><p>public class BufferedOutputStream<br>extends FilterOutputStream<br>该类实现缓冲输出流。 通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用。</p>
<p>构造方法：</p>
<p>BufferedOutputStream(OutputStream out)<br>创建一个新的缓冲输出流，以将数据写入指定的底层输出流。<br>BufferedOutputStream(OutputStream out, int size)<br>创建一个新的缓冲输出流，以便以指定的缓冲区大小将数据写入指定的底层输出流。 </p>
<p>方法：</p>
<p>void<br>flush()<br>刷新缓冲输出流。<br>void<br>write(byte[] b, int off, int len)<br>从指定的字节数组写入 len个字节，从偏移 off开始到缓冲的输出流。<br>void<br>write(int b)<br>将指定的字节写入缓冲的输出流。 </p>
<p>使用步骤：</p>
<p>1、创建FileOutputStream对象，构造方法中帮定要输出的目的地。</p>
<p>2、创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象，提高FileOutputStream对象效率。</p>
<p>3、使用BufferedOutputStream对象中的write，把数据写入到内部缓冲区中。</p>
<p>4、使用BufferedOutputStream对象中的方法flush，把内部的缓冲区的数据，刷新到文件中。</p>
<p>5、释放资源（会先调用flush方法刷新数据，第四步可以省略）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedOutputStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\study\\Git\\deom\\test\\base\\day014\\c.txt&quot;</span>);</span><br><span class="line">        BufferedOutputStream bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(fileOutputStream);</span><br><span class="line">        bufferedOutputStream.write(<span class="string">&quot;数据写入到硬盘中&quot;</span>.getBytes());</span><br><span class="line">        bufferedOutputStream.flush();</span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BufferedInputStream字节缓冲输入流"><a href="#BufferedInputStream字节缓冲输入流" class="headerlink" title="BufferedInputStream字节缓冲输入流"></a>BufferedInputStream字节缓冲输入流</h4><p>public class BufferedInputStream<br>extends FilterInputStream</p>
<p>构造方法：</p>
<p>BufferedInputStream(InputStream in)<br>创建一个 BufferedInputStream并保存其参数，输入流 in ，供以后使用。<br>BufferedInputStream(InputStream in, int size)<br>创建 BufferedInputStream具有指定缓冲区大小，并保存其参数，输入流 in ，供以后使用。 </p>
<p>int<br>available()<br>返回从该输入流中可以读取（或跳过）的字节数的估计值，而不会被下一次调用此输入流的方法阻塞。<br>void<br>close()<br>关闭此输入流并释放与流相关联的任何系统资源。<br>void<br>mark(int readlimit)<br>见的总承包 mark的方法 InputStream 。<br>boolean<br>markSupported()<br>测试这个输入流是否支持 mark和 reset方法。<br>int<br>read()<br>见 read法 InputStream的一般合同。<br>int<br>read(byte[] b, int off, int len)<br>从给定的偏移开始，将字节输入流中的字节读入指定的字节数组。<br>void<br>reset()<br>见 reset法 InputStream的一般合同。<br>long<br>skip(long n)<br>见 skip法 InputStream的一般合同。</p>
<p>使用步骤：</p>
<p>1、创建FileInputStream对象，构造方法中绑定要读取的数据源。</p>
<p>2、创建BufferedInputStrean对象，构造方法中传递FileInputStream对象，提高FileInputStread对象的读取效率。</p>
<p>3、使用BufferedInputStrean对象中的方法read，读取文件。</p>
<p>4、释放资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStreanDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\study\\Git\\deom\\test\\base\\day014\\c.txt&quot;</span>);</span><br><span class="line">        BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br><span class="line">        <span class="comment">/*int len = 0;</span></span><br><span class="line"><span class="comment">        while ((len = bufferedInputStream.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(len);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = bufferedInputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));<span class="comment">//abcdefg</span></span><br><span class="line">        &#125;</span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符缓冲输出流"><a href="#字符缓冲输出流" class="headerlink" title="字符缓冲输出流"></a>字符缓冲输出流</h4><p>public class BufferedWriter<br>extends Writer</p>
<p>构造方法：</p>
<p>BufferedWriter(Writer out)<br>创建使用默认大小的输出缓冲区的缓冲字符输出流。<br>BufferedWriter(Writer out, int sz)<br>创建一个新的缓冲字符输出流，使用给定大小的输出缓冲区。 </p>
<p>方法:</p>
<p>void<br>close()<br>关闭流，先刷新。<br>void<br>flush()<br>刷新流。<br>void<br>newLine()<br>写一行行分隔符。<br>void<br>write(char[] cbuf, int off, int len)<br>写入字符数组的一部分。<br>void<br>write(int c)<br>写一个字符<br>void<br>write(String s, int off, int len)<br>写一个字符串的一部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileWriter fileWriter = <span class="keyword">new</span> FileWriter(<span class="string">&quot;D:\\study\\Git\\deom\\test\\base\\day014\\c.txt&quot;</span>);</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(fileWriter);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            bufferedWriter.write(<span class="string">&quot;我是一名程序员&quot;</span>);</span><br><span class="line">            bufferedWriter.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedWriter.flush();</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符缓冲输入流"><a href="#字符缓冲输入流" class="headerlink" title="字符缓冲输入流"></a>字符缓冲输入流</h4><p>public class BufferedReader<br>extends Reader</p>
<p>从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取。</p>
<p>构造方法：</p>
<p>BufferedReader(Reader in)<br>创建使用默认大小的输入缓冲区的缓冲字符输入流。<br>BufferedReader(Reader in, int sz)<br>创建使用指定大小的输入缓冲区的缓冲字符输入流。 </p>
<p>方法：</p>
<p>int<br>read()<br>读一个字符<br>int<br>read(char[] cbuf, int off, int len)<br>将字符读入数组的一部分。<br>String<br>readLine()<br>读一行文字。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;D:\\study\\Git\\deom\\test\\base\\day014\\c.txt&quot;</span>));</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//每次读一行数据</span></span><br><span class="line">        <span class="keyword">while</span> ((s = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h1><h4 id="字符编码和字符集"><a href="#字符编码和字符集" class="headerlink" title="字符编码和字符集"></a>字符编码和字符集</h4><p>字符编码：计算机中存储的信息都是用二进制数表示的，而我们在屏幕上看到的数组、英文、标点符号，汉字等字符是二进制数转换之后的结果，按照某种规则，将字符存储到计算中，称为：编码，反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为：解码，比如说：按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号，反之，按照A规则存储，在按照B规则解析，就会导致乱码现象。</p>
<p>编码：字符（能看见的）—字节（看不懂的）</p>
<p>解码：字节（看不懂的）—-字符（能看懂的）</p>
<p>字符编码：就是一套自然语言的字符与二进制数之间的对应规则。</p>
<p>编码表：生活中文字和计算机中二进制的对应规则。</p>
<p>字符集：也叫编码表，是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</p>
<h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h4><p>public class OutputStreamWriter<br>extends Writer</p>
<p>OutputStreamWriter是字符的桥梁流以字节流：向其写入的字符编码成使用指定的字节charset 。</p>
<p>OutputStreamWriter(OutputStream out)<br>创建一个使用默认字符编码的OutputStreamWriter。<br>OutputStreamWriter(OutputStream out, Charset cs)<br>创建一个使用给定字符集的OutputStreamWriter。<br>OutputStreamWriter(OutputStream out, CharsetEncoder enc)<br>创建一个使用给定字符集编码器的OutputStreamWriter。<br>OutputStreamWriter(OutputStream out, String charsetName)<br>创建一个使用命名字符集的OutputStreamWriter。 </p>
<p>参数：charsetName:字符编码的格式：utf-8/gbk/…..</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamWriteDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        OutputStreamWriter outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\study\\Git\\deom\\test\\base\\day015\\src\\GBK.txt&quot;</span>),<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        outputStreamWriter.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        outputStreamWriter.flush();</span><br><span class="line">        outputStreamWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><p>public class InputStreamReader<br>extends Reader</p>
<p>InputStreamReader(InputStream in) //不指定编码表名称，默认utf-8.<br>创建一个使用默认字符集的InputStreamReader。<br>InputStreamReader(InputStream in, Charset cs)<br>创建一个使用给定字符集的InputStreamReader。<br>InputStreamReader(InputStream in, CharsetDecoder dec)<br>创建一个使用给定字符集解码器的InputStreamReader。<br>InputStreamReader(InputStream in, String charsetName)<br>创建一个使用命名字符集的InputStreamReader。 </p>
<p>注意：构造方法中指定的编码表名称要和文件的编码相同，否则会发生乱码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\study\\Git\\deom\\test\\base\\day015\\src\\GBK.txt&quot;</span>),<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStreamReader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStreamReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习：转换文件编码格式"><a href="#练习：转换文件编码格式" class="headerlink" title="练习：转换文件编码格式"></a>练习：转换文件编码格式</h4><p>将gbk文件转换为utf-8文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\study\\Git\\deom\\test\\base\\day015\\src\\GBK.txt&quot;</span>),<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        OutputStreamWriter outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\study\\Git\\deom\\test\\base\\day015\\src\\UTF-8.txt&quot;</span>),<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStreamReader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            outputStreamWriter.write(len);</span><br><span class="line">        &#125;</span><br><span class="line">        outputStreamWriter.close();</span><br><span class="line">        inputStreamReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>Java提供了一种对象序列化的机制，用一个字节序列可以表示一个对象，该字节序列包含该对象的数据，对象的类型和对象中存储的属性。字节序列写出到文件后，相当于文件中持久保存了一个对象的信息。反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化，对象的数据，对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。</p>
<p>public class ObjectInputStream<br>extends InputStream<br>implements ObjectInput, ObjectStreamConstants<br>ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象。</p>
<p>构造方法：ObjectInputStream(InputStream in)<br>创建从指定的InputStream读取的ObjectInputStream。 </p>
<p>方法：</p>
<p>int<br>read()<br>读取一个字节的数据。 </p>
<p>public interface Serializable<br>类的序列化由实现java.io.Serializable接口的类启用。 不实现此接口的类将不会使任何状态序列化或反序列化。 可序列化类的所有子类型都是可序列化的。 序列化接口没有方法或字段，仅用于标识可串行化的语义。</p>
<p>public class ObjectOutputStream<br>extends OutputStream<br>implements ObjectOutput, ObjectStreamConstants<br>ObjectOutputStream将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象。</p>
<p>构造方法：</p>
<p>ObjectOutputStream(OutputStream out)<br>创建一个写入指定的OutputStream的ObjectOutputStream。 </p>
<p>方法：</p>
<p>void<br>write(byte[] buf)<br>写入一个字节数组。<br>void<br>write(byte[] buf, int off, int len)<br>写入一个子字节数组。<br>void<br>write(int val)<br>写一个字节。 </p>
<h4 id="transient关键字：瞬态关键字"><a href="#transient关键字：瞬态关键字" class="headerlink" title="transient关键字：瞬态关键字"></a>transient关键字：瞬态关键字</h4><p>被transient修饰成员变量，不能被序列化。</p>
<p>被static修饰成员变量，不能被序列化。</p>
<h4 id="序列化标识ID"><a href="#序列化标识ID" class="headerlink" title="序列化标识ID"></a>序列化标识ID</h4><p>序列化运行时将每个可序列化的类与称为serialVersionUID的版本号相关联，该序列号在反序列化期间用于验证序列化对象的发送者和接收者是否已加载与该序列化兼容的对象的类。 如果接收方加载了一个具有不同于相应发件人类的serialVersionUID的对象的类，则反序列化将导致InvalidClassException 。 一个可序列化的类可以通过声明一个名为”serialVersionUID”的字段来显式地声明它自己的serialVersionUID，该字段必须是静态的，最终的，类型是long ：<br>  ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L; </p>
<h4 id="打印流PrintStream"><a href="#打印流PrintStream" class="headerlink" title="打印流PrintStream"></a>打印流PrintStream</h4><p>public class PrintStream<br>extends FilterOutputStream<br>implements Appendable, Closeable<br>A PrintStream为另一个输出流添加了功能，即能够方便地打印各种数据值的表示。 还提供了另外两个功能。 与其他输出流不同， PrintStream从不抛出IOException ; 相反，异常情况只是设置一个可以通过checkError方法测试的内部标志。 </p>
<p>构造方法：</p>
<p>PrintStream(String fileName)<br>使用指定的文件名创建新的打印流，无需自动换行。 </p>
<p>特有的方法：</p>
<p>print/println</p>
<p>System类下有一个静态方法：改变输出的地点。</p>
<p>static void<br>setOut(PrintStream out)<br>重新分配“标准”输出流。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/14/%E7%BC%93%E5%86%B2%E6%B5%81%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81/" data-id="ckfo4q45a000uvkvw8shy4zhf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/29/480%E4%B8%AALinux%E6%8C%87%E4%BB%A4/">480个Linux指令</a>
          </li>
        
          <li>
            <a href="/2020/09/26/Linux(%E4%B8%80)/">Linux(一)</a>
          </li>
        
          <li>
            <a href="/2020/09/25/Git/">Git</a>
          </li>
        
          <li>
            <a href="/2020/09/25/%E6%B3%A8%E8%A7%A3/">注解</a>
          </li>
        
          <li>
            <a href="/2020/09/24/%E5%8F%8D%E5%B0%84/">反射</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 我的笔记<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>