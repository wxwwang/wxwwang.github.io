<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>我的笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="我的笔记">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="我的笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="我的笔记">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="我的笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">我的笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-深入线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/13/%E6%B7%B1%E5%85%A5%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2020-09-13T01:06:05.844Z" itemprop="datePublished">2020-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/13/%E6%B7%B1%E5%85%A5%E7%BA%BF%E7%A8%8B/">深入线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h4 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h4><p>线程是调度CPU的最小单元，也叫轻量级进程LWP(Light Weight Process)。</p>
<p>两种线程模型：</p>
<p>用户级线程ULT :APP自己管理线程</p>
<p>内核级线程kLT:CPU管理线程。</p>
<p>Java虚拟机，使用的是哪一种线程模型？</p>
<p>Java虚拟机使用线程模型：KLT。</p>
<p>Java线程创建是依赖于系统内核，通过jvm调用体统库创建内核线程，内核线程于Java-Thread是1：1的映射关系。</p>
<h4 id="线程池的意义"><a href="#线程池的意义" class="headerlink" title="线程池的意义"></a>线程池的意义</h4><p>线程是稀缺资源，他的创建于销毁是一个相对偏重且消耗资源的操作，而Java线程依赖于内核线程，创建线程需要进行操作系统状态切换，为避免资源过度消耗需要设法重用线程执行多个任务。线程池就是一个线程缓存，负责对线程进行统一分配、调优与监控。</p>
<p>什么时候使用线程池？</p>
<p>1、单个任务处理时间比较短。</p>
<p>2、需要处理的任务数量很大。</p>
<p>线程池优势</p>
<p>1、重用存在的线程，减少线程创建，消亡的开销，提高性能。</p>
<p>2、提高响应速度，当任务到达时，任务可以不需要的等到线程创建就能立即执行。</p>
<p>3、提高线程的可管理性，可统一分配，调优和监控。</p>
<p>阻塞队列</p>
<p>1、在任意时刻，不管并发有多高，永远只有一个线程能够进行队列的入队或者出队操作！线程安全的队列。</p>
<p>有界||无界</p>
<p>5</p>
<p>队列满，只能进行出队操作，所有人入队的操作必须等待，也就是被阻塞，</p>
<p>0</p>
<p>队列空，只能进行入队操作，所有出队的操作必须等待，也就是被阻塞。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/13/%E6%B7%B1%E5%85%A5%E7%BA%BF%E7%A8%8B/" data-id="ckfb6v60p000jxcvwd9v50qod" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-多线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2020-09-11T12:18:08.846Z" itemprop="datePublished">2020-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程、Lambda表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><p>并发：指两个或多个事件在同意时间段内发生。</p>
<p>并行：指两个或多个事件在同一时刻（同时发生）</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wNTo8K"><img src="https://s1.ax1x.com/2020/09/11/wNTo8K.png" alt="wNTo8K.png"></a></p>
<h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>进程：进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。</p>
<p>线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wN7OQU"><img src="https://s1.ax1x.com/2020/09/11/wN7OQU.png" alt="wN7OQU.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wNHzjS"><img src="https://s1.ax1x.com/2020/09/11/wNHzjS.png" alt="wNHzjS.png"></a></p>
<p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程</p>
<h4 id="分时调度和抢占式调度"><a href="#分时调度和抢占式调度" class="headerlink" title="分时调度和抢占式调度"></a>分时调度和抢占式调度</h4><p>分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。</p>
<p>抢占式调度：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么随机选择一个（线程随机性），Java使用的是抢占式调度。</p>
<p>抢占式调度详解：大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序，比如：现在我们一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p>
<p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。</p>
<p>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p>
<h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><p>jvm启动后，必然有一个执行路径(线程)从main方法开始的，一直执行到main方法结束，这个线程在java中称之为主线程。当程序的主线程执行时，如果遇到了循环而导致程序在指定位置停留时间过长，则无法马上执行下面的程序，需要等待循环结束后能够执行。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wNvab8"><img src="https://s1.ax1x.com/2020/09/11/wNvab8.png" alt="wNvab8.png"></a></p>
<h4 id="创建多线程的第一种方式——-继承Thread类"><a href="#创建多线程的第一种方式——-继承Thread类" class="headerlink" title="创建多线程的第一种方式——-继承Thread类"></a>创建多线程的第一种方式——-继承Thread类</h4><p>创建线程的步骤：</p>
<p>1 定义一个类继承Thread。</p>
<p>2 重写run方法。</p>
<p>3 创建子类对象，就是创建线程对象。</p>
<p>4 调用start方法，开启线程并让线程执行，同时还会告诉jvm去调用run方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run :&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">程序执行结果：<span class="comment">//每次都不一样</span></span><br><span class="line">main:<span class="number">0</span></span><br><span class="line">main:<span class="number">1</span></span><br><span class="line">run :<span class="number">0</span></span><br><span class="line">run :<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wUfLwt"><img src="https://s1.ax1x.com/2020/09/12/wUfLwt.png" alt="wUfLwt.png"></a></p>
<h4 id="继承Thread类原理"><a href="#继承Thread类原理" class="headerlink" title="继承Thread类原理"></a>继承Thread类原理</h4><p>创建线程的目的是什么？</p>
<p>是为了建立程序单独的执行路径，让多部分代码实现同时执行。也就是说线程创建并执行需要给定线程要执行的任务。</p>
<p>对于之前所讲的主线程，它的任务定义在main函数中。自定义线程需要执行的任务都定义在run方法中。</p>
<p>Thread类run方法中的任务并不是我们所需要的，只有重写这个run方法。既然Thread类已经定义了线程任务的编写位置（run方法），那么只要在编写位置（run方法）中定义任务代码即可。所以进行了重写run方法动作。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wUhEkV"><img src="https://s1.ax1x.com/2020/09/12/wUhEkV.png" alt="wUhEkV.png"></a></p>
<h4 id="获取线程的名称"><a href="#获取线程的名称" class="headerlink" title="获取线程的名称"></a>获取线程的名称</h4><p>1、Thread.currentThread()获取当前线程对象（必须继承Thread类才能用）</p>
<p>2、Thread.currentThread().getName();获取当前线程对象的名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String name = getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line">main</span><br><span class="line">Thread-<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="设置线程的名称"><a href="#设置线程的名称" class="headerlink" title="设置线程的名称"></a>设置线程的名称</h4><p>1、使用Thread类中的方法setName(名字)</p>
<p>​    void setName（String name)改变线程名称，使之与参数name相同。</p>
<p>2、创建一个带参数的构造方法，参数传递线程的名字，调用父类的带参构造方法，把线程名称传递给父类，让父类（Thread)给子类起一个名字。</p>
<p>​    Thread(String name) 分配新的Thread对象。</p>
<h4 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h4><p>public static void sleep(long millis):是当前正在执行线程以指定的毫秒数暂停（暂时停止执行）</p>
<h4 id="创建线程的第二种方式——实现Runnable接口"><a href="#创建线程的第二种方式——实现Runnable接口" class="headerlink" title="创建线程的第二种方式——实现Runnable接口"></a>创建线程的第二种方式——实现Runnable接口</h4><p>Runnable接口用来指定每个线程要执行的任务。包含了一个 run 的无参数抽象方法，需要由接口实现类重写该方法。</p>
<p>创建线程的步骤。</p>
<p>1、定义类实现Runnable接口。</p>
<p>2、覆盖接口中的run方法。。</p>
<p>3、创建Thread类的对象</p>
<p>4、将Runnable接口的子类对象作为参数传递给Thread类的构造函数。</p>
<p>5、调用Thread类的start方法开启线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread .currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span>  + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableImpl runnable = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现Runnable的原理"><a href="#实现Runnable的原理" class="headerlink" title="实现Runnable的原理"></a>实现Runnable的原理</h4><p>实现Runnable接口，避免了继承Thread类的单继承局限性。覆盖Runnable接口中的run方法，将线程任务代码定义到run方法中。</p>
<p>创建Thread类的对象，只有创建Thread类的对象才可以创建线程。线程任务已被封装到Runnable接口的run方法中，而这个run方法所属于Runnable接口的子类对象，所以将这个子类对象作为参数传递给Thread的构造函数，这样，线程对象创建时就可以明确要运行的线程的任务。</p>
<h4 id="实现Runnable的好处"><a href="#实现Runnable的好处" class="headerlink" title="实现Runnable的好处"></a>实现Runnable的好处</h4><p>第二种方式实现Runnable接口避免了单继承的局限性，所以较为常用。实现Runnable接口的方式，更加的符合面向对象，线程分为两部分，一部分线程对象，一部分线程任务。继承Thread类，线程对象和线程任务耦合在一起。一旦创建Thread类的子类对象，既是线程对象，又有线程任务。实现runnable接口，将线程任务单独分离出来封装成对象，类型就是Runnable接口类型。Runnable接口对线程对象和线程任务进行解耦。</p>
<h4 id="线程的匿名内部类使用"><a href="#线程的匿名内部类使用" class="headerlink" title="线程的匿名内部类使用"></a>线程的匿名内部类使用</h4><p>使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。</p>
<p>匿名内部类方式实现线程的创建</p>
<p>匿名：没有名字。</p>
<p>内部类：写在其他类内部的类。</p>
<p>匿名内部类的作用：简化代码。</p>
<p>把子类继承父类，重写父类的方法，创建子类对象集合一步完成。</p>
<p>把实现类实现类接口，重写接口中的方法，创建实现类对象合成一步完成。</p>
<p>匿名内部类的最终产物：子类/实现类对象，而这个类没有名字</p>
<p>格式：</p>
<p>new 父类/接口（）{</p>
<p>​    重写父类/接口中的方法。</p>
<p>}；</p>
<p>方式1：创建线程对象时，直接重写Thread类中的run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//以前Thread thread = new MyThread();</span></span><br><span class="line">        <span class="comment">//thread.start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式2：使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//以前Thread t = new Thread(new RunnableImpl());</span></span><br><span class="line">        <span class="comment">//t.start();</span></span><br><span class="line">        <span class="comment">//简化前</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//简化后</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>多线程访问了共享的数据，会产生线程安全问题。</p>
<p><img src="https://s1.ax1x.com/2020/09/12/wUqKXT.png" alt="wUqKXT.png"></p>
<p>模拟电影院卖票</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//有一百张票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟卖票</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第：&quot;</span> + ticket +<span class="string">&quot;票&quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableImpl runnable = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        <span class="comment">//创建三个卖票窗口</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果发现：上面的程序出现了问题，票出现了重复的票。错误的票 0、-1。</p>
<p>其实，线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
<p>注意:<br>线程安全问题是不能产生的,我们可以让一个线程在访问共享数据的时候,无论是否失去了cpu的执行权;让其他的线程只能等待,等待当前线程卖完票,其他线程在进行卖票保证:使用—个线程在卖票</p>
<h4 id="线程同步—-同步代码块"><a href="#线程同步—-同步代码块" class="headerlink" title="线程同步—-同步代码块"></a>线程同步—-同步代码块</h4><p>同步代码块: 在代码块声明上 加上synchronized</p>
<p>synchronized (锁对象) {</p>
<p>​    可能会产生线程安全问题的代码 </p>
<p>}</p>
<p>同步代码块中的锁对象可以是任意的对象；但多个线程时，要使用同一个锁对象才能够保证线程安全。</p>
<p>同步技术的原理:<br>使用了一个锁对象,这个锁对象叫同步锁,也叫对象锁,也叫对象监视器<br>3个线程一起抢夺cpu的执行权,谁抢到了谁执行run方法进行卖票<br>to抢到了cpu的执行权,执行run方法,遇到synchronized代码块<br>这时t0会检查synchronized代码块是否有锁对象<br>发现有,就会获取到锁对象,进入到同步中执行<br>t1抢到了cpu的执行权执行run方法,遇到synchronized代码块<br>这时t1会检查synchronized代码块是否有锁对象<br>发现没有,t1救护进入到阻塞状态,会一直等待t0线程归还锁对象<br>一直到t0线程执行完同步中的代码,会把锁对象归还给同步代码块<br>t1才能获取到锁对象进入到同步中执行<br>总结:同步中的线程,没有执行完毕不会释放锁,同步外的线程没有锁进不去同步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//有一百张票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟卖票</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第：&quot;</span> + ticket +<span class="string">&quot;票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程同步—-同步方法"><a href="#线程同步—-同步方法" class="headerlink" title="线程同步—-同步方法"></a>线程同步—-同步方法</h4><p>同步方法：在方法声明上加上synchronized</p>
<p>public synchronized void method(){</p>
<p>​       可能会产生线程安全问题的代码 </p>
<p>}</p>
<p>同步方法中的锁对象是 this,this就是new RunnableImpl();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//有一百张票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟卖票</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            payTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">payTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第：&quot;</span> + ticket +<span class="string">&quot;票&quot;</span>);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态同步方法"><a href="#静态同步方法" class="headerlink" title="静态同步方法"></a>静态同步方法</h4><p>public static synchronized void method(){</p>
<p>​    可能会产生线程安全问题的代码 </p>
<p>}</p>
<p>静态同步方法中的锁对象是 类名.class</p>
<h4 id="线程安全—-Lock接口"><a href="#线程安全—-Lock接口" class="headerlink" title="线程安全—-Lock接口"></a>线程安全—-Lock接口</h4><p>Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。</p>
<p>使用步骤：</p>
<p>1、在成员方法位置创建一个ReentrantLock对象。</p>
<p>2、在可能会出现安全问题的代码前调用Lock接口中的方法Lock获取锁。</p>
<p>3、在可能可能出现安全问题的代码后调用Lock接口中的方法unLock释放锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//有一百张票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟卖票</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第：&quot;</span> + ticket +<span class="string">&quot;票&quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lock.unlock();方法一般放在finally{}中，如果程序出现异常也会将锁放回。</p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有种状态六种状态。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/waQdHK"><img src="https://s1.ax1x.com/2020/09/12/waQdHK.png" alt="waQdHK.png"></a></p>
<h4 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wal929"><img src="https://s1.ax1x.com/2020/09/12/wal929.png" alt="wal929.png"></a></p>
<p>模拟顾客和老板之间买包子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">//创建顾客线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//模拟顾客买包子</span></span><br><span class="line">                <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;顾客：老板我要买包子&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;顾客：开始吃&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">//创建老板线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;老板：等我5秒&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;老板：包子做好了&quot;</span>);</span><br><span class="line">                    object.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">顾客：老板我要买包子</span><br><span class="line">老板：等我<span class="number">5</span>秒</span><br><span class="line">老板：包子做好了</span><br><span class="line">顾客：开始吃   </span><br></pre></td></tr></table></figure>

<h4 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h4><p>在开始讲解等待唤醒机制之前，有必要搞清一个概念——线程之间的通信：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。通过一定的手段使各个线程能有效的利用资源。而这种手段即—— 等待唤醒机制。</p>
<p>等待唤醒机制所涉及到的方法：</p>
<ul>
<li>wait（） :等待，将正在执行的线程释放其执行资格 和 执行权，并存储到线程池中。</li>
<li>notify（）：唤醒，唤醒线程池中被wait（）的线程，一次唤醒一个，而且是任意的。</li>
<li>notifyAll（）： 唤醒全部：可以将线程池中的所有wait() 线程都唤醒。</li>
</ul>
<p>其实，所谓唤醒的意思就是让 线程池中的线程具备执行资格。必须注意的是，这些方法都是在 同步中才有效。同时这些方法在使用时必须标明所属锁，这样才可以明确出这些方法操作的到底是哪个锁上的线程。</p>
<p>仔细查看JavaAPI之后，发现这些方法 并不定义在 Thread中，也没定义在Runnable接口中，却被定义在了Object类中，为什么这些操作线程的方法定义在Object类中？</p>
<p>因为这些方法在使用时，必须要标明所属的锁，而锁又可以是任意对象。能被任意对象调用的方法一定定义在Object类中。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wawlsU"><img src="https://s1.ax1x.com/2020/09/12/wawlsU.png" alt="wawlsU.png"></a></p>
<p>代码模拟</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZi</span> </span>&#123;</span><br><span class="line">    String pi;</span><br><span class="line">    String xian;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZiPu</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi baoZi;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZiPu</span><span class="params">(BaoZi baoZi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baoZi = baoZi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (baoZi)&#123;</span><br><span class="line">                <span class="keyword">if</span> (baoZi.flag == <span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        baoZi.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                        baoZi.pi = <span class="string">&quot;薄皮&quot;</span>;</span><br><span class="line">                        baoZi.xian = <span class="string">&quot;三鲜馅&quot;</span>;</span><br><span class="line">                        System.out.println(<span class="string">&quot;正在生产：&quot;</span> + baoZi.pi + baoZi.xian + <span class="string">&quot;的包子&quot;</span>);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        baoZi.pi = <span class="string">&quot;冰皮&quot;</span>;</span><br><span class="line">                        baoZi.xian = <span class="string">&quot;猪肉馅&quot;</span>;</span><br><span class="line">                        System.out.println(<span class="string">&quot;正在生产：&quot;</span> + baoZi.pi + baoZi.xian + <span class="string">&quot;的包子&quot;</span>);</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    baoZi.notify();</span><br><span class="line">                    System.out.println(<span class="string">&quot;吃货快来吃&quot;</span> + baoZi.pi + baoZi.xian + <span class="string">&quot;的包子&quot;</span>);</span><br><span class="line">                    baoZi.flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChiHuo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi baoZi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChiHuo</span><span class="params">(BaoZi baoZi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baoZi = baoZi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (baoZi)&#123;</span><br><span class="line">                <span class="keyword">if</span> (baoZi.flag == <span class="keyword">false</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        baoZi.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;吃货开始吃：&quot;</span> + baoZi.pi + baoZi.xian + <span class="string">&quot;的包子&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;吃货吃完了&quot;</span>);</span><br><span class="line">                    baoZi.flag = <span class="keyword">false</span>;</span><br><span class="line">                    baoZi.notify();</span><br><span class="line">                    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BaoZi baoZi = <span class="keyword">new</span> BaoZi();</span><br><span class="line">        <span class="keyword">new</span> BaoZiPu(baoZi).start();</span><br><span class="line">        <span class="keyword">new</span> ChiHuo(baoZi).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码运行结果：</span><br><span class="line">正在生产：薄皮三鲜馅的包子</span><br><span class="line">吃货快来吃薄皮三鲜馅的包子</span><br><span class="line">吃货开始吃：薄皮三鲜馅的包子</span><br><span class="line">吃货吃完了</span><br><span class="line">--------------------------</span><br><span class="line">正在生产：冰皮猪肉馅的包子</span><br><span class="line">吃货快来吃冰皮猪肉馅的包子</span><br><span class="line">吃货开始吃：冰皮猪肉馅的包子</span><br><span class="line">吃货吃完了</span><br><span class="line">--------------------------</span><br></pre></td></tr></table></figure>

<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>线程池，其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</p>
<p>我们详细的解释一下为什么要使用线程池？</p>
<p>在java中，如果每个请求到达就创建一个新线程，开销是相当大的。在实际使用中，创建和销毁线程花费的时间和消耗的系统资源都相当大，甚至可能要比在处理实际的用户请求的时间和资源要多的多。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。如果在一个jvm里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。为了防止资源不足，需要采取一些办法来限制任何给定时刻处理的请求数目，尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，尽量利用已有对象来进行服务。</p>
<p>线程池主要用来解决线程生命周期开销问题和资源不足问题。通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了，而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快。另外，通过适当的调整线程中的线程数目可以防止出现资源不足的情况。</p>
<h4 id="使用线程池方式–Runnable接口"><a href="#使用线程池方式–Runnable接口" class="headerlink" title="使用线程池方式–Runnable接口"></a>使用线程池方式–Runnable接口</h4><p>通常，线程池都是通过线程池工厂创建，再调用线程池中的方法获取线程，再通过线程去执行任务方法。</p>
<p>Executors：线程池创建工厂类</p>
<p>public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象</p>
<p>ExecutorService：线程池类</p>
<p>Future&lt;?&gt; submit(Runnable task)：获取线程池中的某一个线程对象，并执行 Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用</p>
<p>使用线程池中线程对象的步骤：</p>
<p>1、创建线程池对象</p>
<p>2、创建Runnable接口子类对象</p>
<p>3、提交Runnable接口子类对象</p>
<p>4、关闭线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>新的线程执行了</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>新的线程执行了</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>新的线程执行了</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>新的线程执行了</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>新的线程执行了</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>新的线程执行了</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>新的线程执行了</span><br></pre></td></tr></table></figure>

<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>使用Lambda表达式实现多线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程执行了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果：</span></span><br><span class="line"><span class="comment">//Thread-0执行了</span></span><br><span class="line"><span class="comment">//Thread-1线程执行了</span></span><br></pre></td></tr></table></figure>

<h4 id="Lambda表达式的标准格式"><a href="#Lambda表达式的标准格式" class="headerlink" title="Lambda表达式的标准格式"></a>Lambda表达式的标准格式</h4><p>Lambda表达式的标准格式：</p>
<p>由三部分组成：1、一些参数。2、一个箭头3、一段代码</p>
<p>格式：（参数列表）-&gt;{一些重写方法的代码}</p>
<p>解释说明格式：</p>
<p>（）：接口中抽象方法的参数列表，没有参数，就空着；有参数就写出参数，多个参数使用逗号隔开。</p>
<p>-&gt;：传递的意思，把参数传递给方法体{}</p>
<p>{}：重写接口的抽象方法的方法体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeCook</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        invokeCook(<span class="keyword">new</span> Cook() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeCook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;吃饭了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        invokeCook(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;吃饭了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCook</span><span class="params">(Cook cook)</span></span>&#123;</span><br><span class="line">        cook.makeCook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序执行结果：</span></span><br><span class="line"><span class="comment">//吃饭了</span></span><br><span class="line"><span class="comment">//吃饭了</span></span><br></pre></td></tr></table></figure>

<h4 id="Lambda表达式有参数有返回值"><a href="#Lambda表达式有参数有返回值" class="headerlink" title="Lambda表达式有参数有返回值"></a>Lambda表达式有参数有返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] persons = &#123;</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;迪丽热巴&quot;</span>,<span class="number">18</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;古力娜扎&quot;</span>,<span class="number">25</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;马尔扎哈&quot;</span>,<span class="number">20</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">//        Arrays.sort(persons, new Comparator&lt;Person&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compare(Person o1, Person o2) &#123;</span></span><br><span class="line"><span class="comment">//                return o1.getAge()-o2.getAge();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        Arrays.sort(persons,(Person o1,Person o2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sum(<span class="number">20</span>,<span class="number">92</span>,(<span class="keyword">int</span> a,<span class="keyword">int</span> b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,PC c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = c.sum(a,b);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果：</span></span><br><span class="line"><span class="comment">//112</span></span><br></pre></td></tr></table></figure>

<h4 id="Lambda表达式可以省略的内容"><a href="#Lambda表达式可以省略的内容" class="headerlink" title="Lambda表达式可以省略的内容"></a>Lambda表达式可以省略的内容</h4><p>Lambda表达式：是可推导，可以省略。</p>
<p>凡是根据上下文推导出来的内容，都可以省略不写。</p>
<p>可以省略的内容：</p>
<p>1、（参数列表）：括号中参数列表的数据类型，可以省略不写。</p>
<p>2、（参数列表）：括号中的参数如果只有一个，那么类型和（）都可以省略不写。</p>
<p>3、{一些代码}：如果{}中的代码只有一行，无论是否有返回值，都可以省略（{}，return，分号）。</p>
<p>注意：要省略{}，return，分号必须一起省略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*sum(20,92,(int a,int b)-&gt;&#123;</span></span><br><span class="line"><span class="comment">            return a + b;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line">        sum(<span class="number">30</span>,<span class="number">34</span>,(a,b)-&gt; a + b);<span class="comment">//64</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,PC c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = c.sum(a,b);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Lambda的使用前提"><a href="#Lambda的使用前提" class="headerlink" title="Lambda的使用前提"></a>Lambda的使用前提</h4><p>1、使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。</p>
<p>2、使用Lambda必须具有上下文推断，也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</p>
<p>备注：有且仅有一个抽象方法的接口，被称为：函数式接口。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-id="ckfb6v615000uxcvw63ys2gw5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-异常" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/11/%E5%BC%82%E5%B8%B8/" class="article-date">
  <time datetime="2020-09-11T07:23:40.342Z" itemprop="datePublished">2020-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/11/%E5%BC%82%E5%B8%B8/">异常</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h4 id="异常的概念"><a href="#异常的概念" class="headerlink" title="异常的概念"></a>异常的概念</h4><p>异常：指的是程序在执行的过程中，出现的非正常的情况，最终导致JVM的非正常的停止。</p>
<p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象，Java处理异常的方式是中断处理。</p>
<p>异常值得并不是语法错误，语法错了，编译不通过，不会产生字节码文件，根本不能运行。</p>
<h4 id="异常和错误的区别"><a href="#异常和错误的区别" class="headerlink" title="异常和错误的区别"></a>异常和错误的区别</h4><p>Java.lang.Throwable:类是Java语言中所有的错误和异常的超类。</p>
<p>Exception:编译期异常，进行编译（写代码）Java程序出现的问题。</p>
<p>​    RuntimeException:运行期异常，Java程序运行过程中出现的问题。</p>
<p>​    异常就相当于一个小毛病，把异常处理掉，程序就可以继续执行。</p>
<p>Error:错误</p>
<p>​    错误就相当于程序得了一个无法治愈的毛病，必须修改代码，程序才能继续执行。</p>
<h4 id="异常产生的原理"><a href="#异常产生的原理" class="headerlink" title="异常产生的原理"></a>异常产生的原理</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wNZ6L4"><img src="https://s1.ax1x.com/2020/09/11/wNZ6L4.png" alt="wNZ6L4.png"></a></p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h6 id="throw关键字："><a href="#throw关键字：" class="headerlink" title="throw关键字："></a>throw关键字：</h6><p>作用：可以使用throw关键字在指定的方法中抛出指定的异常。</p>
<p>作用格式：throw new xxxException(“异常产生的原因”)</p>
<p>注意：1、throw关键字必须写在方法的内部。</p>
<p>2、throw关键字后边new的对象必须是Exception或者Exception的子类对象。</p>
<p>3、throw关键字抛出指定的异常对象，我们就必须处理这个异常。</p>
<p>throw关键字后边创建的是RuntimeException或者RuntimeException的子类对象，我们可以不处理，默认交给JVM处理（打印异常）；</p>
<p>throw关键字后边创建的是编译异常（写代码的时候报错），我们就必须处理这个异常，要么throws，要么try…..catch。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">34</span>,<span class="number">12</span>,<span class="number">67</span>&#125;; <span class="comment">//创建数组</span></span><br><span class="line">        <span class="keyword">int</span> num = ArrayTools.getElement(<span class="keyword">null</span>,<span class="number">2</span>);<span class="comment">// 调用方法，获取数组中指定索引处元素</span></span><br><span class="line"><span class="comment">//int num = ArrayTools.getElement(arr,5);// 调用方法，获取数组中指定索引处元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;num=&quot;</span>+num);<span class="comment">//打印获取到的元素值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过给定的数组，返回给定的索引对应的元素值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">若程序出了异常，JVM它会打包异常对象并抛出。但是它所提供的信息不够给力。想要更清晰，需要自己抛出异常信息。</span></span><br><span class="line"><span class="comment">下面判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;arr指向的数组不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=arr.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;错误的角标，&quot;</span>+index+<span class="string">&quot;索引在数组中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Objects类中的非空判断"><a href="#Objects类中的非空判断" class="headerlink" title="Objects类中的非空判断"></a>Objects类中的非空判断</h4><p>Object类中的静态方法：</p>
<p>public static <T> T requireNonNull(T obj):查看指定引用类型不是null。</p>
<p>源码：</p>
<p>public static <T> T requireNonNull(T obj){</p>
<p>​    if（obj == null)</p>
<p>​        throw new NullPointerException();</p>
<p>​    return obj;</p>
<p>}</p>
<h4 id="声明异常throws"><a href="#声明异常throws" class="headerlink" title="声明异常throws"></a>声明异常throws</h4><p>声明：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理，那么必须通过throws进行声明，让调用者去处理。</p>
<p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p>
<p>声明异常格式： 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2… { }</p>
<h4 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h4><p>格式：</p>
<p>try{</p>
<p>​    可能出现的异常的代码</p>
<p>}catch(定义一个异常的变量，用来接收try中抛出的异常对象){</p>
<p>​    异常的处理逻辑，怎么处理异常对象</p>
<p>}</p>
<p>……..</p>
<p>catch(异常类名  变量名){}</p>
<p>注意：</p>
<p>1、try中可能会抛出多个异常，那么就可以使用多个catch来处理这些异常对象。</p>
<p>2、如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完try中的处理逻辑，继续执行try….catch之后的代码。</p>
<p>如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑，执行完try中的代码，继续执行try….catch之后的代码。</p>
<h4 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h4><p>finally代码块：</p>
<p>格式：</p>
<p>try{</p>
<p>​    可能出现的异常的代码</p>
<p>}catch(定义一个异常的变量，用来接收try中抛出的异常对象){</p>
<p>​    异常的处理逻辑，怎么处理异常对象</p>
<p>}finally{</p>
<p>​    无论是否出现异常都会执行。</p>
<p>}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; <span class="comment">//throws ArrayIndexOutOfBoundsException</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">            System.out.println( arr[<span class="number">5</span>] );<span class="comment">// 会抛出ArrayIndexOutOfBoundsException</span></span><br><span class="line">            <span class="comment">//当产生异常时，必须有处理方式。要么捕获，要么声明。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123; <span class="comment">//括号中需要定义什么呢？try中抛出的是什么异常，在括号中就定义什么异常类型。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;异常发生了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            arr = <span class="keyword">null</span>; <span class="comment">//把数组指向null，通过垃圾回收器，进行内存垃圾的清除</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序运行结果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常的注意事项："><a href="#异常的注意事项：" class="headerlink" title="异常的注意事项："></a>异常的注意事项：</h4><p>多个异常可以分别处理</p>
<p>多个异常一次捕获多次处理</p>
<p>多个异常一次捕获，采用同一种方式处理</p>
<p>声明抛出异常：声明上使用,一次声明多个异常</p>
<p>运行时异常被抛出可以不处理。即不捕获也不声明抛出</p>
<p>如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集</p>
<p>父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p>
<p>当多异常处理时，捕获处理，前边的类不能是后边类的父类</p>
<h4 id="throw-和throws-的区别是什么"><a href="#throw-和throws-的区别是什么" class="headerlink" title="throw 和throws 的区别是什么"></a>throw 和throws 的区别是什么</h4><p>throw<br>定义在方法中，后边跟的是异常对象<br>同时只能抛出一个异常对象</p>
<p>throws<br> 定义在方法的声明上，后边跟的是异常的类型<br> 后边同时可以跟多个数据类型</p>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>通过阅读异常源代码：发现java中所有的异常类，都是继承Throwable，或者继承Throwable的子类。这样该异常才可以被throw抛出。说明这个异常体系具备一个特有的特性：可抛性：即可以被throw关键字操作。</p>
<p>并且查阅异常子类源码，发现每个异常中都调用了父类的构造方法，把异常描述信息传递给了父类，让父类帮我们进行异常信息的封装。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class 异常名 extends Exception&#123; <span class="comment">//或继承RuntimeException</span></span><br><span class="line">    <span class="keyword">public</span> 异常名()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> 异常名(String s)&#123;</span><br><span class="line">   　　 <span class="keyword">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义异常继承Exception</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(message);<span class="comment">// 如果自定义异常需要异常信息，可以通过调用父类的带有字符串参数的构造函数即可。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义异常继承RuntimeException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    MyException()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    MyException(String message) &#123;</span><br><span class="line">        <span class="keyword">super</span>(message);<span class="comment">// 如果自定义异常需要异常信息，可以通过调用父类的带有字符串参数的构造函数即可。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义异常练习"><a href="#自定义异常练习" class="headerlink" title="自定义异常练习"></a>自定义异常练习</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String[] useName = &#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你的用户名&quot;</span>);</span><br><span class="line">        String name = scanner.next();</span><br><span class="line">        <span class="keyword">for</span> (String s : useName) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.equals(name))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">&quot;亲，您输入的用户名已经被注册&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜你注册成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">请输入你的用户名</span></span><br><span class="line"><span class="comment">李云龙</span></span><br><span class="line"><span class="comment">恭喜你注册成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">请输入你的用户名</span></span><br><span class="line"><span class="comment">张三</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; demo02.MyException: 亲，您输入的用户名已经被注册</span></span><br><span class="line"><span class="comment">	at MyExceptionDemo.main(MyExceptionDemo.java:12)</span></span><br><span class="line"><span class="comment">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span></span><br><span class="line"><span class="comment">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span></span><br><span class="line"><span class="comment">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span></span><br><span class="line"><span class="comment">	at java.lang.reflect.Method.invoke(Method.java:483)</span></span><br><span class="line"><span class="comment">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/11/%E5%BC%82%E5%B8%B8/" data-id="ckfb6v60l000dxcvw8w0vhxcw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深入泛型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/10/%E6%B7%B1%E5%85%A5%E6%B3%9B%E5%9E%8B/" class="article-date">
  <time datetime="2020-09-10T08:53:32.205Z" itemprop="datePublished">2020-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/10/%E6%B7%B1%E5%85%A5%E6%B3%9B%E5%9E%8B/">深入泛型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Java推出泛型以前，程序员可以构建一个元素为Object的集合，该集合能够存储任意的数据类型对象，而在使用该集合的工程中，需要程序员明确知道存储每个元素的数据类型，否则很容易引发ClassCastException异常。</p>
<h4 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h4><p>Java泛型是jdk5中引入的一个新特性，泛型提供了编译时类型安全检测机制，该机制允许我们在编译时检测到非法的数据类型数据。</p>
<p>泛型的本质就是参数化类型，也就是所操作的数据类型被指定为一个参数。</p>
<h4 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h4><p>1、编译期间检查类型</p>
<p>2、减少了数据类型转换</p>
<p>3、提高代码复用</p>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>泛型类的定义语法</p>
<p>修饰符    class    类名称&lt;泛型标识，泛型标识,…….&gt;{</p>
<p>​        private    泛型标识    变量名;</p>
<p>​        ……</p>
<p>}</p>
<p>常用的泛型标识：T、E、K、V</p>
<p>泛型标识<T>—–类型形参</p>
<p>T 创建对象的时候给指定具体的数据类型。</p>
<p>T 是由外部实用类的时候来指定。</p>
<h4 id="泛型类的使用"><a href="#泛型类的使用" class="headerlink" title="泛型类的使用"></a>泛型类的使用</h4><p>使用语法：</p>
<p>类名&lt;具体的数据类型&gt;     对象名    =    new    类名&lt;具体的数据类型&gt;（）;</p>
<p>Java7以后，后面的&lt;&gt;中的具体的数据类型可以省略不写。</p>
<p>类名&lt;具体的数据类型&gt;     对象名    =    new    类名&lt;&gt;（）;</p>
<h4 id="泛型类的注意事项"><a href="#泛型类的注意事项" class="headerlink" title="泛型类的注意事项"></a>泛型类的注意事项</h4><p>1、泛型类在创建对象的时候，没有指定类型，将按照Object类型来操作。</p>
<p>2、泛型类，不支持基本数据类型。为什么？因为在使用泛型的时候编译器会在适当的时候将Object类转换为我们转递的具体的类类型，基本数据类型没有继承Object所以不能转换。</p>
<p>3、同一泛型类，根据不同的数据类型创建的对象，本质上是同一类型。</p>
<h4 id="泛型类派生子类"><a href="#泛型类派生子类" class="headerlink" title="泛型类派生子类"></a>泛型类派生子类</h4><p>1、子类也是泛型类，子类和父类的泛型类型要一致</p>
<p>class    类名称<T>    extends    父类名称<T></p>
<p>2、子类不是泛型类，父类要明确泛型的数据类型</p>
<p>class    类名称    extends    父类名称<T>    </p>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>泛型接口的定义语法：</p>
<p>修饰符    interface    接口名称&lt;泛型标识，泛型标识,…..&gt;{</p>
<p>​        泛型标识    方法名（）;</p>
<p>​        …..</p>
<p>}</p>
<h4 id="泛型接口的使用"><a href="#泛型接口的使用" class="headerlink" title="泛型接口的使用"></a>泛型接口的使用</h4><p>1、实现类不是泛型类，接口要明确数据类型</p>
<p>2、实现类也是泛型类，实现类和接口的泛型类型要一致</p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>语法：</p>
<p>修饰符    &lt;T,E,…..&gt;    返回值类型    方法名（形参列表）{</p>
<p>​    方法体……</p>
<p>}</p>
<p>1、public 与返回值中间<T>非常重要，可以理解为声明此方法为泛型方法。</p>
<p>2、只用声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的的成员方法并不是泛型方法。</p>
<p>3、<T>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</p>
<p>4、与泛型的定义一样，此处T可以随意写为任意标识，常见的T,E,K,V等形式的参数常用于表示泛型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">getName</span><span class="params">(ArrayList&lt;E&gt; list)</span></span>&#123;<span class="comment">//泛型标识，有调用方法的时候来指定。</span></span><br><span class="line">	<span class="keyword">return</span> list.get(r.nextInt(list.size()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="泛型类和泛型方法的区别"><a href="#泛型类和泛型方法的区别" class="headerlink" title="泛型类和泛型方法的区别"></a>泛型类和泛型方法的区别</h4><p>1、泛型类，是在实例化类的时候指明泛型具体类型。</p>
<p>2、泛型方法，是在调用方法的时候指明泛型的具体类型。</p>
<h4 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h4><p>public <E> void print(E… e){</p>
<p>​    for(E e1:e){</p>
<p>​        sout(e1);</p>
<p>​    }</p>
<p>}</p>
<h4 id="泛型方法总结"><a href="#泛型方法总结" class="headerlink" title="泛型方法总结"></a>泛型方法总结</h4><p>1、泛型方法能使方法独立于类而产生变化</p>
<p>2、如果static方法要使用泛型能力，就必须使其成为泛型方法。</p>
<h4 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h4><p>1、类型通配符一般是使用“？”代替具体的类型实参。</p>
<p>2、所以，类型通配符是类型实参，而不是类型形参。</p>
<h4 id="类型通配符的上限"><a href="#类型通配符的上限" class="headerlink" title="类型通配符的上限"></a>类型通配符的上限</h4><p>语法：</p>
<p>类/接口&lt;? extends 实参类型&gt;</p>
<p>*要求该泛型的类型，只能是实参类型，或实参类型的子类类型。</p>
<h4 id="类型通配符的下限"><a href="#类型通配符的下限" class="headerlink" title="类型通配符的下限"></a>类型通配符的下限</h4><p>语法：</p>
<p>类/接口&lt;? super 实参类型&gt;</p>
<p>*要求该泛型的类型，只能是实参类型，或实参类型的父类类型。</p>
<h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>概念：泛型是Java5版本才引进的概念，在这之前是没有泛型的，但是，泛型代码能够很好的和之前版本的代码兼容。那是因为，泛型信息只存在于代码编译阶段，在进入JVM之前，与泛型相关的信息会被擦除掉，我们称之为—-》类型擦除。</p>
<p>无限制类型擦除：<T>—&gt;Object</p>
<p>有限制类型擦除：<T extends Number>—&gt; Number</p>
<p>桥接方法：</p>
<h4 id="泛型与数组"><a href="#泛型与数组" class="headerlink" title="泛型与数组"></a>泛型与数组</h4><p>泛型数组的创建：</p>
<p>1、可以声明带泛型的数组引用，但是不能直接创建带泛型的数组对象。</p>
<p>2、可以通过Java.lang.reflect.Array的newInstance(Class<T>,int)创建T[]数组。</p>
<h4 id="反射常用的泛型类"><a href="#反射常用的泛型类" class="headerlink" title="反射常用的泛型类"></a>反射常用的泛型类</h4><p>1、Class<T></p>
<p>2、Constructor<T></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/10/%E6%B7%B1%E5%85%A5%E6%B3%9B%E5%9E%8B/" data-id="ckfb6v60p000ixcvwhso7c0yl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Collections工具类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/09/Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/" class="article-date">
  <time datetime="2020-09-09T14:32:39.160Z" itemprop="datePublished">2020-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/09/Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/">Collections工具类、Map集合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h4 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h4><p>Collections工具类常用的静态方法：</p>
<p>public static <T> boolean addAll(Collection<T> c,T…elements):向集合中添加多个元素。</p>
<p>public static void shuffie(List&lt;?&gt; list):打乱集合的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c,T...elements):向集合中添加多个元素。</span></span><br><span class="line">        Collections.addAll(arrayList,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[a, b, c, d]</span></span><br><span class="line">        <span class="comment">//public static void shuffie(List&lt;?&gt; list):打乱集合的顺序。</span></span><br><span class="line">        Collections.shuffle(arrayList);</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[c, a, d, b]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>public static <T> void sort (List<T> list):将集合中的元素按照默认的规则排序。</p>
<p>注意事项：sort(List<T> list)使用前提</p>
<p>该排序的集合里边储存的元素，必须实现Comparable，重写接口中的方法compareTo定义排序的规则。</p>
<p>Comparable接口的排序规则：</p>
<p>自己（this)-参数：升序</p>
<p>参数-自己（this):降序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写接口中comparableTo方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getAge()-o.getAge();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparableDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">&quot;赵四&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">&quot;wangwu&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        System.out.println(list);<span class="comment">//[Person&#123;name=&#x27;张三&#x27;, age=19&#125;, Person&#123;name=&#x27;赵四&#x27;, age=22&#125;, Person&#123;name=&#x27;wangwu&#x27;, age=15&#125;]</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);<span class="comment">//[Person&#123;name=&#x27;wangwu&#x27;, age=15&#125;, Person&#123;name=&#x27;张三&#x27;, age=19&#125;, Person&#123;name=&#x27;赵四&#x27;, age=22&#125;]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>public static <T> void sort(List<T> list,Comparator&lt;? super T&gt;):将集合中的元素按照指定规矩排序。</p>
<p>Comparator的排序规则：</p>
<p>o1-o2:升序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;迪丽热巴&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;古力娜扎&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;马尔扎哈&quot;</span>,<span class="number">25</span>));</span><br><span class="line">        System.out.println(list);<span class="comment">//[Student&#123;name=&#x27;迪丽热巴&#x27;, age=18&#125;, Student&#123;name=&#x27;古力娜扎&#x27;, age=15&#125;, Student&#123;name=&#x27;马尔扎哈&#x27;, age=25&#125;]</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//按照年龄排序</span></span><br><span class="line">                <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);<span class="comment">//[Student&#123;name=&#x27;古力娜扎&#x27;, age=15&#125;, Student&#123;name=&#x27;迪丽热巴&#x27;, age=18&#125;, Student&#123;name=&#x27;马尔扎哈&#x27;, age=25&#125;]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h4><p>java.util.Map&lt;K,V&gt;集合</p>
<p>Map集合的特点：</p>
<p>1、Map集合是一个双列集合，一个元素包括两个值（一个key,一个value）</p>
<p>2、Map集合中的元素，key和value的数据类型可以相同，也可以不同。</p>
<p>3、Map集合的元素，key是不可以重复的，value是可以重复的</p>
<p>4、Map集合中的元素，key和value是一一对应的。</p>
<p>java.util.HashMap&lt;K.V&gt;集合 implements Map&lt;K,V&gt;接口</p>
<p>HashMap集合的特点：</p>
<p>1、HashMap集合底层是哈希表，查询的速度特别的快。</p>
<p>jdk1.8之前：数组+单项链表</p>
<p>jdk8之后：数组+单项链表+红黑树（链表的长度超过8）：提高查询速度。</p>
<p>2、HashMap集合是一个无序的集合，存储元素和取出的顺序有可能不一致。</p>
<p>java.util.LinkedHashMap&lt;K,V&gt;集合 extends HashMap&lt;K,V&gt;集合</p>
<p>LinkedHashMap的特点：</p>
<p>1、LinkedHashMap集合底层是哈希表+链表（保证迭代的顺序）</p>
<p>2、LinkedHashMap集合是一个有序的集合，存储元素和取出来元素的顺序是一样的。</p>
<h4 id="Map集合中的方法"><a href="#Map集合中的方法" class="headerlink" title="Map集合中的方法"></a>Map集合中的方法</h4><ul>
<li><ul>
<li><table>
<thead>
<tr>
<th><code>void</code></th>
<th><code>clear()</code> 从该地图中删除所有的映射（可选操作）。</th>
</tr>
</thead>
<tbody><tr>
<td><code>default V</code></td>
<td><code>compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code> 尝试计算指定键的映射及其当前映射的值（如果没有当前映射， <code>null</code> ）。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</code> 如果指定的键尚未与值相关联（或映射到 <code>null</code> ），则尝试使用给定的映射函数计算其值，并将其输入到此映射中，除非 <code>null</code> 。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code> 如果指定的密钥的值存在且非空，则尝试计算给定密钥及其当前映射值的新映射。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsKey(Object key)</code> 如果此映射包含指定键的映射，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsValue(Object value)</code> 如果此地图将一个或多个键映射到指定的值，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code></td>
<td><code>entrySet()</code> 返回此地图中包含的映射的<a href="../../java/util/Set.html"><code>Set</code></a>视图。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>equals(Object o)</code> 将指定的对象与此映射进行比较以获得相等性。</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>forEach(BiConsumer&lt;? super K,? super V&gt; action)</code> 对此映射中的每个条目执行给定的操作，直到所有条目都被处理或操作引发异常。</td>
</tr>
<tr>
<td><code>V</code></td>
<td><code>get(Object key)</code> 返回到指定键所映射的值，或 <code>null</code>如果此映射包含该键的映射。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>getOrDefault(Object key, V defaultValue)</code> 返回到指定键所映射的值，或 <code>defaultValue</code>如果此映射包含该键的映射。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>hashCode()</code> 返回此地图的哈希码值。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEmpty()</code> 如果此地图不包含键值映射，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td><code>Set&lt;K&gt;</code></td>
<td><code>keySet()</code> 返回此地图中包含的键的<a href="../../java/util/Set.html"><code>Set</code></a>视图。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</code> 如果指定的键尚未与值相关联或与null相关联，则将其与给定的非空值相关联。</td>
</tr>
<tr>
<td><code>V</code></td>
<td><code>put(K key, V value)</code> 将指定的值与该映射中的指定键相关联（可选操作）。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>putAll(Map&lt;? extends K,? extends V&gt; m)</code> 将指定地图的所有映射复制到此映射（可选操作）。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>putIfAbsent(K key, V value)</code> 如果指定的键尚未与某个值相关联（或映射到 <code>null</code> ）将其与给定值相关联并返回 <code>null</code> ，否则返回当前值。</td>
</tr>
<tr>
<td><code>V</code></td>
<td><code>remove(Object key)</code> 如果存在（从可选的操作），从该地图中删除一个键的映射。</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>remove(Object key, Object value)</code> 仅当指定的密钥当前映射到指定的值时删除该条目。</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>replace(K key, V value)</code> 只有当目标映射到某个值时，才能替换指定键的条目。</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>replace(K key, V oldValue, V newValue)</code> 仅当当前映射到指定的值时，才能替换指定键的条目。</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code> 将每个条目的值替换为对该条目调用给定函数的结果，直到所有条目都被处理或该函数抛出异常。</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size()</code> 返回此地图中键值映射的数量。</td>
</tr>
<tr>
<td><code>Collection&lt;V&gt;</code></td>
<td><code>values()</code> 返回此地图中包含的值的<a href="../../java/util/Collection.html"><code>Collection</code></a>视图。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MapDemo01</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        | `boolean`             | `containsKey(Object key)` 如果此映射包含指定键的映射，则返回 `true` 。 |</span></span><br><span class="line"><span class="comment">        | `boolean`             | `containsValue(Object value)` 如果此地图将一个或多个键映射到指定的值，则返回 `true` 。</span></span><br><span class="line"><span class="comment">        | `V`                   | `put(K key, V value)` 将指定的值与该映射中的指定键相关联（可选操作）。 ||</span></span><br><span class="line"><span class="comment">        | `V`                   | `get(Object key)` 返回到指定键所映射的值，或 `null`如果此映射包含该键的映射。 |                          |</span></span><br><span class="line"><span class="comment">        | `boolean`             | `isEmpty()` 如果此地图不包含键值映射，则返回 `true` 。</span></span><br><span class="line"><span class="comment">        | `V`                   | `remove(Object key)` 如果存在（从可选的操作），从该地图中删除一个键的映射。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt; map = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;郭靖&quot;</span>,<span class="string">&quot;黄蓉&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;杨过&quot;</span>,<span class="string">&quot;小龙女&quot;</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;杨过=小龙女, 郭靖=黄蓉, 张无忌=赵敏&#125;</span></span><br><span class="line">        <span class="comment">//| `V`                   | `get(Object key)` 返回到指定键所映射的值，或 `null`如果此映射包含该键的映射。</span></span><br><span class="line">        <span class="built_in">String</span> s1 = map.get(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        <span class="built_in">String</span> s2 = map.get(<span class="string">&quot;虚竹&quot;</span>);</span><br><span class="line">        System.out.println(s1);<span class="comment">//赵敏</span></span><br><span class="line">        System.out.println(s2);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//| `boolean`             | `containsKey(Object key)` 如果此映射包含指定键的映射，则返回 `true` 。 |</span></span><br><span class="line">        boolean b1 = map.containsKey(<span class="string">&quot;郭靖&quot;</span>);</span><br><span class="line">        boolean b2 = map.containsKey(<span class="string">&quot;杨康&quot;</span>);</span><br><span class="line">        System.out.println(b1);<span class="comment">//true</span></span><br><span class="line">        System.out.println(b2);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Map集合的遍历"><a href="#Map集合的遍历" class="headerlink" title="Map集合的遍历"></a>Map集合的遍历</h4><p>一、Map集合的第一种遍历方式：通过键找值的方式</p>
<p>Map集合中的方法：</p>
<p>​    Set<K> keySet():返回此映射中包含的键的Set视图。</p>
<p>实现步骤：</p>
<p>1、使用Map集合中的方法keySet(),把Map集合所有的key取出来，存储到一个Set集合中。</p>
<p>2、遍历set集合，获取Map集合中的每一个key.</p>
<p>3、通过Map集合中的方法get （key），通过key找到value。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;郭靖&quot;</span>,<span class="string">&quot;黄蓉&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;杨过&quot;</span>,<span class="string">&quot;小龙女&quot;</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;杨过=小龙女, 郭靖=黄蓉, 张无忌=赵敏&#125;</span></span><br><span class="line">        <span class="comment">//1、使用Map集合中的方法keySet(),把Map集合所有的key取出来，存储到一个Set集合中。</span></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        Iterator&lt;String&gt; iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            <span class="comment">//2、遍历set集合，获取Map集合中的每一个key.</span></span><br><span class="line">            String next = iterator.next();</span><br><span class="line">            <span class="comment">// 3、通过Map集合中的方法get （key），通过key找到value。</span></span><br><span class="line">            String s = map.get(next);</span><br><span class="line">            System.out.println(next + <span class="string">&quot;=&quot;</span> + s);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            杨过=小龙女</span></span><br><span class="line"><span class="comment">            郭靖=黄蓉</span></span><br><span class="line"><span class="comment">            张无忌=赵敏</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            String s1 = map.get(s);</span><br><span class="line">            System.out.println(s + <span class="string">&quot;=&quot;</span> + s1);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            杨过=小龙女</span></span><br><span class="line"><span class="comment">            郭靖=黄蓉</span></span><br><span class="line"><span class="comment">            张无忌=赵敏</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二：Map集合遍历的第二种方式：使用Entry对象遍历</p>
<p>Map集合中的方法：</p>
<p><code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code>  <code>entrySet()</code> 返回此地图中包含的映射的<a href="../../java/util/Set.html"><code>Set</code></a>视图。 </p>
<p>实现步骤：</p>
<p>1、使用Map集合中的方法entrySet()，把Map集合中多个Entry对象取出来，存储到一个Set集合中。</p>
<p>2、遍历Set集合，取出每一个Entry对象。</p>
<p>3、使用Entry对象中的方法getKey()和getValue()获取键与值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;郭靖&quot;</span>,<span class="string">&quot;黄蓉&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;杨过&quot;</span>,<span class="string">&quot;小龙女&quot;</span>);</span><br><span class="line">        <span class="comment">//1、使用Map集合中的方法entrySet()，把Map集合中多个Entry对象取出来，存储到一个Set集合中。</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="comment">//2、遍历Set集合，取出每一个Entry对象。</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = entries.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; next = iterator.next();</span><br><span class="line">            <span class="comment">//3、使用Entry对象中的方法getKey()和getValue()获取键与值。</span></span><br><span class="line">            String key = next.getKey();</span><br><span class="line">            String value = next.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;  &quot;</span> + value);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            杨过  小龙女</span></span><br><span class="line"><span class="comment">            郭靖  黄蓉</span></span><br><span class="line"><span class="comment">            张无忌  赵敏</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entries) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;  &quot;</span> + value);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            杨过  小龙女</span></span><br><span class="line"><span class="comment">            郭靖  黄蓉</span></span><br><span class="line"><span class="comment">            张无忌  赵敏</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashMap集合存储自定义元素"><a href="#HashMap集合存储自定义元素" class="headerlink" title="HashMap集合存储自定义元素"></a>HashMap集合存储自定义元素</h4><p>Map集合保证key是唯一的，作为key的元素，必须重写hashCode和equals方法，以保证key唯一。</p>
<h4 id="LinkedHashMap集合"><a href="#LinkedHashMap集合" class="headerlink" title="LinkedHashMap集合"></a>LinkedHashMap集合</h4><p>java.util.LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt;</p>
<p>Map接口的哈希表和链表实现，具有可预知的迭代顺序</p>
<p>底层原理：</p>
<p>哈希表+链表（记录元素的顺序）Key不允许重复。</p>
<h4 id="练习：计算一个字符串中字符出现的次数"><a href="#练习：计算一个字符串中字符出现的次数" class="headerlink" title="练习：计算一个字符串中字符出现的次数"></a>练习：计算一个字符串中字符出现的次数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串&quot;</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s = scanner.next();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="comment">//将字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="comment">//遍历字符数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">            <span class="comment">//判断hashMap集合中的key是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (hashMap.containsKey(aChar)) &#123;</span><br><span class="line">                <span class="comment">//如果存在value值加一并放到hashMap集合中</span></span><br><span class="line">                Integer integer = hashMap.get(aChar);</span><br><span class="line">                integer++;</span><br><span class="line">                hashMap.put(aChar,integer);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//key不存在，就将key放在hashMap集合中，value值设置为1.</span></span><br><span class="line">                hashMap.put(aChar,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历hashMap集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = hashMap.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : entries) &#123;</span><br><span class="line">            Character key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="jdk9的新特性"><a href="#jdk9的新特性" class="headerlink" title="jdk9的新特性"></a>jdk9的新特性</h4><p>List接口，Set接口，Map接口：里边增加了一个静态方法of,可以给集合一次性添加多个元素。</p>
<p>static <E> List<E> of(E… elements)</p>
<p>使用前提：</p>
<p>当集合中存储的元素的个数已经确定了，不在改变时使用。</p>
<p>注意：1、of方法只适用于List接口，Set接口，Map接口，不适用于接口的实现类。</p>
<p>2、of方法的返回值是一个不可改变的集合，集合不能在使用add,put方法添加元素，会抛出异常。</p>
<p>3、Set接口和Map接口在of方法的时候，不能有重复的元素，否在就会抛出异常。</p>
<h4 id="Debug调试程序"><a href="#Debug调试程序" class="headerlink" title="Debug调试程序"></a>Debug调试程序</h4><p>可以让代码逐行执行，查看代码执行的过程，调试程序中出现事物bug。</p>
<p>使用方法：</p>
<p>1、在行号的右边，鼠标左键单击，添加断点（每个方法的第一行，哪里有bug添加到哪里）</p>
<p>2、右键，选择Debug执行程序。</p>
<p>3、程序就会停留在添加的第一个断点处。</p>
<p>执行程序：</p>
<p>1、f8:逐行执行程序。</p>
<p>2、f7：进入到方法中。</p>
<p>3、shift + f8:跳出方法。</p>
<p>4、f9：跳到下一个断点，如果没用下一个断点，那么就结束程序。</p>
<p>5、ctrl + f2:退出debug模式，停止程序。</p>
<p>6、Console:切换到控制台。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/09/Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/" data-id="ckfb6v610000nxcvwhe714fxi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-List集合、set集合、可变参数List集合、set集合、可变参数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/09/List%E9%9B%86%E5%90%88%E3%80%81set%E9%9B%86%E5%90%88%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0List%E9%9B%86%E5%90%88%E3%80%81set%E9%9B%86%E5%90%88%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/" class="article-date">
  <time datetime="2020-09-09T11:23:23.793Z" itemprop="datePublished">2020-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/09/List%E9%9B%86%E5%90%88%E3%80%81set%E9%9B%86%E5%90%88%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0List%E9%9B%86%E5%90%88%E3%80%81set%E9%9B%86%E5%90%88%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/">List集合、set集合、可变参数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h1><p>List接口的特点:</p>
<p>1、它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的。</p>
<p>2、它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</p>
<p>3、集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</p>
<p>List接口的常用子类有：</p>
<p>1、ArrayList集合</p>
<p>2、LinkedList集合</p>
<p>List接口的特有方法(带索引的方法)</p>
<p>1、增加元素方法</p>
<p>add(Object e)：向集合末尾处，添加指定的元素 </p>
<p>void add(int index, Object e)   向集合指定索引处，添加指定的元素，原有元素依次后移</p>
<p>2、删除元素</p>
<p>E remove(Object e)：将指定元素对象，从集合中删除，返回值为被删除的元素</p>
<p>E remove(int index)：将指定索引处的元素，从集合中删除，返回值为被删除的元素</p>
<p>3、替换元素方法</p>
<p>E set(int index, Object e)：将指定索引处的元素，替换成指定的元素，返回值为替换前的元素</p>
<p>4、查询元素方法</p>
<p>E get(int index)：获取指定索引处的元素，并返回该元素</p>
<p>注意事项：带有索引的操作,防止越界问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[a, b, c, d, a]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//add(int index, Object e)   向集合指定索引处，添加指定的元素，原有元素依次后移</span></span><br><span class="line">        list.add(<span class="number">2</span>,<span class="string">&quot;zhaosi&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[a, b, zhaosi, c, d, a]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//E remove(int index)：将指定索引处的元素，从集合中删除，返回值为被删除的元素</span></span><br><span class="line">        String s1 = list.remove(<span class="number">4</span>);</span><br><span class="line">        System.out.println(s1);<span class="comment">//d</span></span><br><span class="line">        System.out.println(list);<span class="comment">//[a, b, zhaosi, c, a]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//E set(int index, Object e)：将指定索引处的元素，替换成指定的元素，返回值为替换前的元素</span></span><br><span class="line">        String s2 = list.set(<span class="number">3</span>,<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        System.out.println(s2);<span class="comment">//c</span></span><br><span class="line">        System.out.println(list);<span class="comment">//[a, b, zhaosi, wangwu, a]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合的三种方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//E get(int index)：获取指定索引处的元素，并返回该元素</span></span><br><span class="line">            String s = list.get(i);</span><br><span class="line">            System.out.print(s + <span class="string">&quot;  &quot;</span>);<span class="comment">//a  b  zhaosi  wangwu  a</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            String s = iterator.next();</span><br><span class="line">            System.out.print(s + <span class="string">&quot;  &quot;</span>);<span class="comment">//a  b  zhaosi  wangwu  a</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">&quot;  &quot;</span>);<span class="comment">//a  b  zhaosi  wangwu  a </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//        String s = list.get(10);//IndexOutOfBoundsException索引越界异常</span></span><br></pre></td></tr></table></figure>

<h4 id="LinkedList集合的自身特点"><a href="#LinkedList集合的自身特点" class="headerlink" title="LinkedList集合的自身特点"></a>LinkedList集合的自身特点</h4><p>自身特点: 链表底层实现,查询慢,增删快</p>
<p>注意：子类的特有功能,不能多态调用</p>
<p>底层采用链表结构，每次查询都要从链头或链尾找起，查询相对较慢，但是删除直接修改元素记录的地址值即可，不要大量移动元素。</p>
<p>LinkedList的索引决定是从链头开始还是从链尾开始找，如果该元素小于元素长度一半，从链头开始找，如果大于元素长度的一半，则从链尾找起。</p>
<p>常用方法：</p>
<p> E removeFirst() 移除并返回链表的开头 等效于pop();</p>
<p> E removeLast() 移除并返回链表的结尾</p>
<p> E getFirst() 获取链表的开头</p>
<p> E getLast() 获取链表的结尾</p>
<p>addFirst(E) 添加到链表的开头  等效于void push(E e):</p>
<p>addLast(E) 添加到链表的结尾</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        linkedList.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//addFirst(E) 添加到链表的开头  等效于void push(E e):</span></span><br><span class="line">        <span class="comment">//addLast(E) 添加到链表的结尾</span></span><br><span class="line">        linkedList.addFirst(<span class="string">&quot;www&quot;</span>);</span><br><span class="line">        linkedList.addLast(<span class="string">&quot;com&quot;</span>);</span><br><span class="line">        System.out.println(linkedList);<span class="comment">//[www, a, b, c, d, a, com]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//E removeFirst() 移除并返回链表的开头 等效于pop();</span></span><br><span class="line">        <span class="comment">//E removeLast() 移除并返回链表的结尾</span></span><br><span class="line">        linkedList.removeFirst();</span><br><span class="line">        linkedList.removeLast();</span><br><span class="line">        System.out.println(linkedList);<span class="comment">//[a, b, c, d, a]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// E getFirst() 获取链表的开头</span></span><br><span class="line">        <span class="comment">//E getLast() 获取链表的结尾</span></span><br><span class="line">        String s1 = linkedList.getFirst();</span><br><span class="line">        String s2 = linkedList.getLast();</span><br><span class="line">        System.out.println(s1);<span class="comment">//a</span></span><br><span class="line">        System.out.println(s2);<span class="comment">//a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h1><p>Set接口的特点：</p>
<p>特点：不重复元素、没有索引、无序集合，存储和取出的顺序有可能不同。底层是通过哈希表实现的。</p>
<p>它是个不包含重复元素的集合。</p>
<p>Set集合取出元素的方式可以采用：迭代器、增强for。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">3</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(set);<span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer integer : set) &#123;</span><br><span class="line">            System.out.println(integer);<span class="comment">//123</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Integer integer = iterator.next();</span><br><span class="line">            System.out.println(integer);<span class="comment">//123</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><p>哈希值:是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑地址，是模拟出来的到的地址不是数据实际存储的物理地址）。</p>
<p>在Object类有一个方法，可以获取对象的哈希值。</p>
<p>int hashCode():返回获取对象的哈希值。</p>
<p>hashCode方法的源码：</p>
<p>public native int hashCode();</p>
<p>native:代表该方法调用的是本地操作系统的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashCodeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = s1.hashCode();</span><br><span class="line">        <span class="keyword">int</span> i1 = s2.hashCode();</span><br><span class="line">        System.out.println(i);<span class="comment">//96354</span></span><br><span class="line">        System.out.println(i1);<span class="comment">//96354</span></span><br><span class="line">        System.out.println(<span class="string">&quot;重地&quot;</span>.hashCode());<span class="comment">//1179395</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通话&quot;</span>.hashCode());<span class="comment">//1179395</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>特点：速度快。</p>
<p>存储数据到集合中，先计算元素的哈希值，将哈希值存放到数组中，在数组的下面挂上我们要查找的元素。如果链表的的长度超多8位，那么就会把链表转换为红黑树结构提高查询的效率。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w8K8SS"><img src="https://s1.ax1x.com/2020/09/09/w8K8SS.png" alt="w8K8SS.png"></a></p>
<h4 id="Set集合元素不重合的原理"><a href="#Set集合元素不重合的原理" class="headerlink" title="Set集合元素不重合的原理"></a>Set集合元素不重合的原理</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w8l9ds"><img src="https://s1.ax1x.com/2020/09/09/w8l9ds.png" alt="w8l9ds.png"></a></p>
<h4 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h4><p>HashSet存储自定义元素。</p>
<p>Set集合保证元素唯一：</p>
<p>存储的元素，必须重写hashCode方法和equals方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != person.age) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(person.name) : person.name == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Person&gt; hashSet = <span class="keyword">new</span> HashSet();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Person person3 = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        hashSet.add(person);</span><br><span class="line">        hashSet.add(person1);</span><br><span class="line">        hashSet.add(person3);</span><br><span class="line">        System.out.println(hashSet);<span class="comment">//[Person&#123;name=&#x27;张三&#x27;, age=19&#125;, Person&#123;name=&#x27;张三&#x27;, age=18&#125;]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h4><p>特点：有序不可重复的，底层是一个哈希表（数组+链表/红黑树）+链表（记录元素储存位置），保证元素有序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashSet&lt;String&gt; linkedHashSet = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="comment">//有序不可重复</span></span><br><span class="line">        System.out.println(linkedHashSet);<span class="comment">//[a, b, c]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>使用前提：当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数。</p>
<p>使用格式：定义方法时使用</p>
<p>修饰符    返回值类型    方法名（数据类型…变量名）{}</p>
<p>可变参数的原理：可变参数底层就是一个数组，根据传递参数不同长度的数组，来储存这些参数。</p>
<p>传递参数个数，可以是0个1个2个……</p>
<p>终止写法：修饰符    返回值类型    方法名（Object…obj）{}</p>
<p>注意事项：1、一个方法的参数列表，只能有一个可变参数。</p>
<p>2、如果方法的参数有多个，那么可变参数必须写在参数列表的末尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> add = sum(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        System.out.println(add);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个0-n个整数的求和方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>...arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            count += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/09/List%E9%9B%86%E5%90%88%E3%80%81set%E9%9B%86%E5%90%88%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0List%E9%9B%86%E5%90%88%E3%80%81set%E9%9B%86%E5%90%88%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/" data-id="ckfb6v60e0005xcvw3nwxbg95" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-09-09T09:56:59.315Z" itemprop="datePublished">2020-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构、栈、队列、数组、链表、树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>先进后出</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w3fykj"><img src="https://s1.ax1x.com/2020/09/09/w3fykj.png" alt="w3fykj.png"></a></p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>先进先出</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w3fWcV"><img src="https://s1.ax1x.com/2020/09/09/w3fWcV.png" alt="w3fWcV.png"></a></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>查询快：数组的地址是连续的，我们通过数组的首地址可以找到数组，通过数组的索引可以快速查找某一个元素。</p>
<p>增删慢：数组的长度是固定的，我们想要增加/删除一个元素，必须创建一个新数组，把原数组的数据复制过来。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w3fq91"><img src="https://s1.ax1x.com/2020/09/09/w3fq91.png" alt="w3fq91.png"></a></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>查询慢：链表中地址不是连续的，每次查询元素，都必须从头开始查询。</p>
<p>增删块：链表结构，增加/删除一个元素，对链表的整体结构没有影响，所以增删块。</p>
<p>单向链表：链表中只有一条链子，不能保证元素的顺序（储存元素和取出元素的顺序有可能不一致）。</p>
<p>双向链表：链表中有两条链子，有一条链子是专门记录元素的顺序，是一个有序的集合。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w3hpAH"><img src="https://s1.ax1x.com/2020/09/09/w3hpAH.png" alt="w3hpAH.png"></a></p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>二叉树：分支不能超过两个。</p>
<p>排序树/查找树：在二叉数的基础上，元素是有大小顺序的，左子树小，右子树大。</p>
<p>平衡树：左孩子和右孩子相等。</p>
<p>不平衡树：左孩子不等于右孩子。</p>
<p>红黑树：特点：趋近于平衡树，查询的速度非常快，查询叶子节点最大次数和最小次数不能超过2倍。</p>
<p>约束：1、节点可以是红色的或者黑色的</p>
<p>2、根节点是黑色的。</p>
<p>3、叶子节点（空节点）是黑色的。</p>
<p>4、每个红色的节点的子节点都是黑色的。</p>
<p>5、任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w3hi9I"><img src="https://s1.ax1x.com/2020/09/09/w3hi9I.png" alt="w3hi9I.png"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="ckfb6v60m000fxcvwelvpdchx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-泛型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/09/%E6%B3%9B%E5%9E%8B/" class="article-date">
  <time datetime="2020-09-09T07:09:36.957Z" itemprop="datePublished">2020-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/09/%E6%B3%9B%E5%9E%8B/">泛型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w3POEQ"><img src="https://s1.ax1x.com/2020/09/09/w3POEQ.png" alt="w3POEQ.png"></a></p>
<p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。比如下面程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">    list.add(<span class="number">5</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">                <span class="comment">//相当于:Object obj=new Integer(5);</span></span><br><span class="line">    </span><br><span class="line">    Iterator it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">      <span class="comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">      String str = (String) it.next();<span class="comment">//String str=(String)obj;</span></span><br><span class="line">                                      <span class="comment">//编译时期仅检查语法错误,String是Object的儿子可以向下转型</span></span><br><span class="line">                                      <span class="comment">//运行时期String str=(String)(new Integer(5))</span></span><br><span class="line">                                      <span class="comment">//String与Integer没有父子关系所以转换失败</span></span><br><span class="line">                                      <span class="comment">//程序在运行时发生了问题java.lang.ClassCastException</span></span><br><span class="line">      System.out.println(str.length());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.5 出现新的安全机制,保证程序的安全性，泛型指明了集合中存储数据的类型  &lt;数据类型&gt;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        function();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;rtyg&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;43rt5yhju&quot;</span>);</span><br><span class="line">    <span class="comment">//    coll.add(1);</span></span><br><span class="line">        </span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">          String s = it.next();</span><br><span class="line">          System.out.println(s.length());</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>定义格式： 修饰符 class 类名&lt;代表泛型的变量&gt; { }   例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：创建对象时，确定泛型的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentDemo</span><span class="params">(E name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(E name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StudentDemo&lt;String&gt; stringStudentDemo = <span class="keyword">new</span> StudentDemo&lt;String&gt;();</span><br><span class="line">        stringStudentDemo.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(stringStudentDemo.getName());<span class="comment">//张三</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型的方法"><a href="#泛型的方法" class="headerlink" title="泛型的方法"></a>泛型的方法</h4><p>定义格式： 修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){ } </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)&#123;  &#125; </span><br><span class="line"> <span class="comment">//该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组</span></span><br><span class="line"><span class="comment">//例如:</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">String[] arr = <span class="keyword">new</span> String[<span class="number">100</span>];</span><br><span class="line">String[] result = list.toArray(arr);</span><br><span class="line"><span class="comment">//此时，变量T的值就是String类型。变量T，可以与定义集合的泛型不同</span></span><br><span class="line"><span class="keyword">public</span> &lt;String&gt; String[] toArray(String[] a)&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如:</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">Integer[] arr = <span class="keyword">new</span> Integer[<span class="number">100</span>];</span><br><span class="line">Integer [] result = list.toArray(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时，变量T的值就是Integer类型。变量T，可以与定义集合的泛型不同</span></span><br><span class="line"><span class="keyword">public</span> &lt;Integer&gt; Integer[] toArray(Integer[] a)&#123;  &#125; </span><br></pre></td></tr></table></figure>

<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">带有泛型的接口</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span> &lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 实现类,先实现接口,不理会泛型</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> 调用者 : <span class="keyword">new</span> ArrayList&lt;String&gt;() 后期创建集合对象的时候,指定数据类型</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 实现类,实现接口的同时,也指定了数据类型</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXX</span> <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">new</span> XXX()</span><br></pre></td></tr></table></figure>

<p><strong>泛型的通配符</strong>  </p>
<p>? 泛型的通配,匹配所有的数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    泛型的通配符</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        array.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="number">789</span>);</span><br><span class="line">        set.add(<span class="number">890</span>);</span><br><span class="line"></span><br><span class="line">        iterator(array);</span><br><span class="line">        iterator(set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       定义方法,可以同时迭代2个集合</span></span><br><span class="line"><span class="comment">       参数: 怎么实现 , 不能写ArrayList,也不能写HashSet</span></span><br><span class="line"><span class="comment">       参数: 或者共同实现的接口</span></span><br><span class="line"><span class="comment">       泛型的通配,匹配所有的数据类型  ?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;</span><br><span class="line">        Iterator&lt;?&gt; it = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="comment">//it.next()获取的对象,什么类型</span></span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型的限定"><a href="#泛型的限定" class="headerlink" title="泛型的限定"></a><strong>泛型的限定</strong></h4><p>? extends Employee 限制的是父类, 上限限定,必须是本身和子类。<br>? super   Employee 限制的是子类, 下限限定，必须是本身和父类。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/09/%E6%B3%9B%E5%9E%8B/" data-id="ckfb6v60o000hxcvw90m3cx55" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-System类、Collection集合、迭代器IteratorSystem类、Collection集合、迭代器Iterator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/09/System%E7%B1%BB%E3%80%81Collection%E9%9B%86%E5%90%88%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8IteratorSystem%E7%B1%BB%E3%80%81Collection%E9%9B%86%E5%90%88%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator/" class="article-date">
  <time datetime="2020-09-08T23:44:16.423Z" itemprop="datePublished">2020-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/09/System%E7%B1%BB%E3%80%81Collection%E9%9B%86%E5%90%88%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8IteratorSystem%E7%B1%BB%E3%80%81Collection%E9%9B%86%E5%90%88%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator/">System类、Collection集合、迭代器Iterator</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h1><p><code>System</code>类提供的<code>System</code>包括标准输入，标准输出和错误输出流; 访问外部定义的属性和环境变量; 一种加载文件和库的方法; 以及用于快速复制阵列的一部分的实用方法。</p>
<p>常用的方法：</p>
<table>
<thead>
<tr>
<th><code>static long</code></th>
<th><code>currentTimeMillis()</code> 返回当前时间（以毫秒为单位）。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>static void</code></th>
<th align="left"><code>arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code> 将指定源数组中的数组从指定位置复制到目标数组的指定位置。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>参数</strong></p>
<p><code>src</code> - 源数组。</p>
<p><code>srcPos</code> - 源数组中的起始位置。</p>
<p><code>dest</code> - 目标数组。</p>
<p><code>destPos</code> - 目的地数据中的起始位置。</p>
<p><code>length</code> - 要复制的数组元素的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo01();</span><br><span class="line">        dem02();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数组src&#123;1，2，3，4，5&#125;的前三个元素复制到desc&#123;6,7,8,9,10&#125;的前三个位置上</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dem02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] src = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] desc = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(desc));<span class="comment">//[6, 7, 8, 9, 10]</span></span><br><span class="line">        System.arraycopy(src,<span class="number">0</span>,desc,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(desc));<span class="comment">//[1, 2, 3, 9, 10]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算for循环的执行时间</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> b = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9999</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;程序执行的时间是&quot;</span> + (e-b)+<span class="string">&quot;毫秒&quot;</span>);<span class="comment">//程序执行的时间是116毫秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h1><p>StringBuilder类：字符串缓冲区，可以提高字符串的操作效率（可以看成一个长度可以改变的字符串），底层也是一个数组，但是没有被final修饰，可以改变长度。</p>
<p>StringBuilder在内存中始终是一个数组，占用空间少，效率高。如果超出了StringBuilder的容量，会自动扩容。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w19PL4"><img src="https://s1.ax1x.com/2020/09/09/w19PL4.png" alt="w19PL4.png"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder() </span><br><span class="line">构造一个没有字符的字符串构建器，初始容量为16个字符。 </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder(String str)</span><br></pre></td></tr></table></figure>

<p>构造一个初始化为指定字符串内容的字符串构建器。</p>
<table>
<thead>
<tr>
<th><code>StringBuilder</code></th>
<th><code>append(任意数据类型)</code> 将 任意数据类型参数的字符串表示附加到序列中。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用无参构造</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//调用有参构造</span></span><br><span class="line">        StringBuilder stringBuilder1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">        System.out.println(stringBuilder);<span class="comment">//空字符串</span></span><br><span class="line">        System.out.println(stringBuilder1);<span class="comment">//ABC</span></span><br><span class="line">        <span class="comment">//链式编程：方法返回值是一个对象，可以继续调用对象方法。</span></span><br><span class="line">        stringBuilder.append(<span class="string">&quot;abc&quot;</span>).append(<span class="keyword">true</span>).append(<span class="number">8.8</span>);</span><br><span class="line">        System.out.println(stringBuilder);<span class="comment">//abctrue8.8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><code>String</code></th>
<th><code>toString()</code> 返回表示此顺序中的数据的字符串。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//将String类型转变成为StringBuilder类型</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">stringBuilder.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">System.out.println(stringBuilder);<span class="comment">//helloworld</span></span><br><span class="line"><span class="comment">//将StringBuilder类型转换成为String类型。</span></span><br><span class="line">String s1 = stringBuilder.toString();</span><br><span class="line">System.out.println(s1);<span class="comment">//helloworld</span></span><br></pre></td></tr></table></figure>

<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>Java中有8种基本的数据类型，可是这些数据是基本数据，想对其进行复杂操作，变的很难。怎么办呢？<br>在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数据类型，如年龄需要转换成int类型，考试成绩需要转换成double类型等。那么，想实现字符串与基本数据之间转换怎么办呢？<br>Java中提供了相应的对象来解决该问题，基本数据类型对象包装类：java将基本数据类型值封装成了对象。封装成对象有什么好处？可以提供更多的操作基本数值的功能。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w1ikwQ"><img src="https://s1.ax1x.com/2020/09/09/w1ikwQ.png" alt="w1ikwQ.png"></a></p>
<h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><p>装箱：把基本数据类型的数据，包装到包装类中。基本数据数据类型到包装类。</p>
<p>构造方法：</p>
<table>
<thead>
<tr>
<th><code>Integer(int value)</code> 构造一个新分配的 <code>Integer</code>对象，该对象表示指定的 <code>int</code>值。</th>
</tr>
</thead>
<tbody><tr>
<td><code>Integer(String s)</code> 构造一个新分配 <code>Integer</code>对象，表示 <code>int</code>由指示值 <code>String</code>参数。</td>
</tr>
</tbody></table>
<p>注意：传递的字符串，必须是基本数据的字符串，否则会抛出异常“100”正确。“abc”异常。</p>
<p>静态方法：</p>
<table>
<thead>
<tr>
<th><code>static Integer</code></th>
<th><code>valueOf(int i)</code> 返回一个 <code>Integer</code>指定的 <code>int</code>值的 <code>Integer</code>实例。</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Integer</code></td>
<td><code>valueOf(String s)</code> 返回一个 <code>Integer</code>对象，保存指定的值为 <code>String</code> 。</td>
</tr>
</tbody></table>
<p>拆箱：在包装类中取出基本类型的数据</p>
<p>成员方法：</p>
<table>
<thead>
<tr>
<th><code>int</code></th>
<th><code>intValue()</code> 将 <code>Integer</code>的值作为 <code>int</code> 。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法 装箱</span></span><br><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer integer1 = <span class="keyword">new</span> Integer(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">System.out.println(integer);<span class="comment">//1</span></span><br><span class="line">System.out.println(integer1);<span class="comment">//1</span></span><br><span class="line"><span class="comment">//静态方法  装箱</span></span><br><span class="line">Integer i = Integer.valueOf(<span class="number">1</span>);<span class="comment">//1</span></span><br><span class="line">Integer i1 = Integer.valueOf(<span class="string">&quot;1&quot;</span>);<span class="comment">//1</span></span><br><span class="line">System.out.println(i);</span><br><span class="line">System.out.println(i1);</span><br><span class="line"><span class="comment">//拆箱 成员方法</span></span><br><span class="line"> <span class="keyword">byte</span> b = integer.byteValue();</span><br><span class="line">System.out.println(b);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h4 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h4><p>自动空装箱和自动拆箱：基本数据类型和包装类之间可以自动的相互转换。</p>
<p>jdk5之后出现的新特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line">Integer integer = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> i = integer;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line">arrayList.add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> num = arrayList.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="基本数据类型与字符串之间的相互转换"><a href="#基本数据类型与字符串之间的相互转换" class="headerlink" title="基本数据类型与字符串之间的相互转换"></a>基本数据类型与字符串之间的相互转换</h4><p>基本数据类型转化为字符串</p>
<p>1、基本数据类型的值+“”最简单的方法。</p>
<p>2、包装类的静态方法toString(参数),不是Object类的toString（）  重载。</p>
<p>static String toString(int i)返回一个表示指定整数的String对象。</p>
<p>3、String类的静态方法valueof(参数)</p>
<p>static String valueof(int i)返回int参数的字符串表示形式。</p>
<p>字符串转换为基本数据类型</p>
<p>使用包装类的静态方法parseXxx(“字符串”)</p>
<p>Integer类：static int parseInt(String s)</p>
<p>Double类：static double parseDouble(String s)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型转字符串</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">String s = num + <span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.println(s + <span class="number">200</span>);<span class="comment">//100200</span></span><br><span class="line"></span><br><span class="line">String s2 = Integer.toString(<span class="number">100</span>);</span><br><span class="line">System.out.println(s2);<span class="comment">//100</span></span><br><span class="line"></span><br><span class="line">String s3 = String.valueOf(<span class="number">200</span>);</span><br><span class="line">System.out.println(s3);<span class="comment">//200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串转基本数据类型</span></span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(s3);</span><br><span class="line">System.out.println(i);<span class="comment">//200</span></span><br></pre></td></tr></table></figure>

<h1 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h1><p>集合是Java中提供的一种容器，可以用来存储多个数据。</p>
<p>在前面的学习中，我们知道数据多了，可以使用数据存放或者使用ArrayList集合进行存放数据。那么，集合和数既然都是容器，它们有什么区别呢？</p>
<p>1、数据的长度是固定的。集合的长度是可变的。</p>
<p>2、集合中存储的元素必须是引用类型数据。</p>
<h4 id="集合继承关系图"><a href="#集合继承关系图" class="headerlink" title="集合继承关系图"></a>集合继承关系图</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w1f5qg"><img src="https://s1.ax1x.com/2020/09/09/w1f5qg.png" alt="w1f5qg.png"></a></p>
<h4 id="Collection集合常用方法"><a href="#Collection集合常用方法" class="headerlink" title="Collection集合常用方法"></a>Collection集合常用方法</h4><p>public boolean add(E e):把给定的对象添加到当前集合中。</p>
<p>public void clear():清空集合中所有的元素。</p>
<p>public boolean remove(E e):把当前对象在当前集合中删除。</p>
<p>public boolean contains(E e):判断当前集合是否包含给定的对象。</p>
<p>public boolean isEmpty():判断当前集合是否为空。</p>
<p>public int size();返回集合元素的个数。</p>
<p>public Object[] toArray():把集合中的元素，存储到数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line">      Collection&lt;String&gt; collection = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">      System.out.println(collection);<span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// public boolean add(E e):把给定的对象添加到当前集合中。</span></span><br><span class="line">      collection.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">      collection.add(<span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">      collection.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">      collection.add(<span class="string">&quot;李六&quot;</span>);</span><br><span class="line">      collection.add(<span class="string">&quot;田七&quot;</span>);</span><br><span class="line">      System.out.println(collection);<span class="comment">//[张三, 赵四, 王五, 李六, 田七]</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//public boolean remove(E e):把当前对象在当前集合中删除。</span></span><br><span class="line">      collection.remove(<span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">      System.out.println(collection);<span class="comment">//[张三, 王五, 李六, 田七]</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//public boolean contains(E e):判断当前集合是否包含给定的对象。</span></span><br><span class="line">      <span class="keyword">boolean</span> b = collection.contains(<span class="string">&quot;田七&quot;</span>);</span><br><span class="line">      <span class="keyword">boolean</span> b1 = collection.contains(<span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">      System.out.println(b);<span class="comment">//true</span></span><br><span class="line">      System.out.println(b1);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//public boolean isEmpty():判断当前集合是否为空。</span></span><br><span class="line">      <span class="keyword">boolean</span> b2 = collection.isEmpty();</span><br><span class="line">      System.out.println(b2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//public int size();返回集合元素的个数。</span></span><br><span class="line">      <span class="keyword">int</span> size = collection.size();</span><br><span class="line">      System.out.println(size);<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//public Object[] toArray():把集合中的元素，存储到数组中。</span></span><br><span class="line">      Object[] objects = collection.toArray();</span><br><span class="line">      <span class="comment">//遍历数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">          System.out.print(objects[i] + <span class="string">&quot;  &quot;</span>);<span class="comment">//张三  王五  李六  田七</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//public void clear():清空集合中所有的元素。</span></span><br><span class="line">      <span class="comment">//注意并不是删除集合，而是清空集合，变为一个空集合</span></span><br><span class="line">      collection.clear();</span><br><span class="line">      System.out.println(collection);<span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> b4 = collection.isEmpty();</span><br><span class="line">      System.out.println(b4);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h4><p>java中提供了很多个集合，它们在存储元素时，采用的存储方式不同，我们要取出这些集合中的元素，可通过一种通用的获取方式来完成。</p>
<p>Collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p>
<p>每种集合的底层的数据结构不同,例如ArrayList是数组,LinkedList底层是链表,但是无论使用哪种集合,我们都会判断是否有元素，以及取出里面的元素的动作,那么Java为我们提供一个迭代器定义了统一的判断元素和取元素的方法。</p>
<p>接口 Iterator : 两个抽象方法</p>
<p>1、boolean hasNext() 判断集合中还有没有可以被取出的元素,如果有返回true</p>
<p>2、next() 取出集合中的下一个元素</p>
<p>Iterator接口,找实现类.   </p>
<p>Collection接口定义方法     Iterator  iterator()   </p>
<p> ArrayList 重写方法 iterator(),返回了Iterator接口的实现类的对象 </p>
<p>使用ArrayList集合的对象</p>
<p>Iterator it = array.iterator(),运行结果就是Iterator接口的实现类的对象 </p>
<p>it是接口的实现类对象,调用方法 hasNext 和 next 集合元素迭代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; collection = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        collection.add(<span class="string">&quot;姚明&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;科比&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;詹姆斯&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;林书豪&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = collection.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            String s = iterator.next();</span><br><span class="line">            System.out.print(s + <span class="string">&quot;  &quot;</span>);<span class="comment">//姚明  科比  詹姆斯  林书豪  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代器原理"><a href="#迭代器原理" class="headerlink" title="迭代器原理"></a>迭代器原理</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/w1xElD"><img src="https://s1.ax1x.com/2020/09/09/w1xElD.png" alt="w1xElD.png"></a></p>
<h4 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h4><p>格式:</p>
<p>for( 数据类型  变量名 : 数组或者集合 ){</p>
<p>​            sout（变量);</p>
<p>}</p>
<p>增强for循环：底层使用的也是迭代器，使用for循环的格式，简化了迭代器的书写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForeachDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo();</span><br><span class="line">        demo01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; co = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        co.add(<span class="string">&quot;马云&quot;</span>);</span><br><span class="line">        co.add(<span class="string">&quot;王健林&quot;</span>);</span><br><span class="line">        co.add(<span class="string">&quot;马化腾&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : co)&#123;</span><br><span class="line">            System.out.print(s + <span class="string">&quot;  &quot;</span>);<span class="comment">//马云  王健林  马化腾 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;  &quot;</span>);<span class="comment">//1  2  3  4  5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/09/System%E7%B1%BB%E3%80%81Collection%E9%9B%86%E5%90%88%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8IteratorSystem%E7%B1%BB%E3%80%81Collection%E9%9B%86%E5%90%88%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator/" data-id="ckfb6v60f0007xcvw1tgcbs95" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Object类、Date类、DateFormat类、Calendar类Object类、Date类、DateFormat类、Calendar类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/08/Object%E7%B1%BB%E3%80%81Date%E7%B1%BB%E3%80%81DateFormat%E7%B1%BB%E3%80%81Calendar%E7%B1%BBObject%E7%B1%BB%E3%80%81Date%E7%B1%BB%E3%80%81DateFormat%E7%B1%BB%E3%80%81Calendar%E7%B1%BB/" class="article-date">
  <time datetime="2020-09-08T11:02:59.103Z" itemprop="datePublished">2020-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/08/Object%E7%B1%BB%E3%80%81Date%E7%B1%BB%E3%80%81DateFormat%E7%B1%BB%E3%80%81Calendar%E7%B1%BBObject%E7%B1%BB%E3%80%81Date%E7%B1%BB%E3%80%81DateFormat%E7%B1%BB%E3%80%81Calendar%E7%B1%BB/">Object类、Date类、DateFormat类、Calendar类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>Java.lang.Object类</p>
<p>类Object是类层次结构的跟类，每个类都是用Object做为父类。所有对象（包括数组）都实现这个类的方法。</p>
<h4 id="toString（）方法"><a href="#toString（）方法" class="headerlink" title="toString（）方法"></a>toString（）方法</h4><p>看一个类是否重写了toString方法，直接打印这个类对应对象的名字即可，如果没有重写toString方法，那么打印的就是对象的地址值（默认），如果重写toString方法，那么就按照重写的方式打印。</p>
<p>toString()方法的返回值是String。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">定义一个标准的Person类</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by wangxiaowei on 2020/9/8.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        String s = person.toString();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//没有重写toString方法</span></span><br><span class="line">        System.out.println(r);<span class="comment">//java.util.Random@a14482</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//重写toString方法</span></span><br><span class="line">        System.out.println(scanner);<span class="comment">//java.util.Scanner[delimiters=\p&#123;javaWhitespace&#125;+][</span></span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//重写toString方法</span></span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[1, 2]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">程序的执行结果是：</span><br><span class="line">Person&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h4><p>boolean equals(Object obj)指示其他某个对象是否与此对象“相等”。</p>
<p>equals方法源码：</p>
<p>public boolean equals(Object obj){</p>
<p>​    return (this == obj);</p>
<p>}</p>
<p>参数：Object obj :可以传递任意的对象</p>
<p>== 比较运算符，返回的是一个布尔值 true false</p>
<p>基本数据类型：比较的是值。</p>
<p>引用数据类型：比较的是两个对象的地址值。</p>
<p>this是谁：哪个对象调用的equals方法，this就是哪个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>);</span><br><span class="line">System.out.println(p1.equals(p2));<span class="comment">//false</span></span><br><span class="line">p1 = p2;</span><br><span class="line">System.out.println(p1.equals(p2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="重写equals方法"><a href="#重写equals方法" class="headerlink" title="重写equals方法"></a>重写equals方法</h4><p>Object类的equals方法，默认比较的是两个对象的地址值，没有意义。所以我们要重写equals方法，比较两个对象的属性。</p>
<p>问题：隐含一个多态，多态的弊端，无法使用子类特有的内容（属性和方法）。</p>
<p>解决：可以使用向下转型（强转）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            Person person = (Person)obj;</span><br><span class="line">            <span class="keyword">boolean</span> b = <span class="keyword">this</span>.name .equals(person.name) &amp;&amp; <span class="keyword">this</span>.age == person.age;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">Person person1 = <span class="keyword">new</span> Person(<span class="string">&quot;迪丽热巴&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        Person person2 = <span class="keyword">new</span> Person(<span class="string">&quot;迪丽热巴&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(person1.equals(person2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="Objects类的equals方法"><a href="#Objects类的equals方法" class="headerlink" title="Objects类的equals方法"></a>Objects类的equals方法</h4><p>Objects类的equals方法：对两个对象进行比较，防止空指针异常。</p>
<p>public static boolean equals(Object a,Object b){</p>
<p>​    return (a == b) ||(a != null &amp;&amp; a.equals(b))</p>
<p>}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">null</span>;</span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(Objects.equals(s1,s2));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h1 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h1><p>java.util.Date:表示日期和时间的类。</p>
<p>Date类表示特定的时间，精确到毫秒。毫秒：千分之一秒。1000毫秒=1秒。</p>
<p>特定的瞬间：一个时间点，一刹那时间。</p>
<p>毫秒值的作用：可以对时间和日期进行计算</p>
<p>把当前日期转换为毫秒，当前日期2020-9-8。时间原点：1970-1-1-00-00-00</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.currentTimeMillis());<span class="comment">//1599568861960</span></span><br></pre></td></tr></table></figure>

<p>注意事项：中国属于东八区，会把时间增加8个小时，时间原点：1970-1-1-00-00-00</p>
<h4 id="Date类的构造方法和getTime（）方法"><a href="#Date类的构造方法和getTime（）方法" class="headerlink" title="Date类的构造方法和getTime（）方法"></a>Date类的构造方法和getTime（）方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前时间到时间原点的毫秒值</span></span><br><span class="line">        System.out.println(System.currentTimeMillis());<span class="comment">//1599568861960</span></span><br><span class="line">        demo01();</span><br><span class="line">        demo02();</span><br><span class="line">        demo03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前时间的到时间原点的毫秒值</span></span><br><span class="line">        Date d = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">long</span> l = d.getTime();</span><br><span class="line">        System.out.println(l);<span class="comment">//1599569711496</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过毫秒值算出当前时间</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1599569484834L</span>);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前日期</span></span><br><span class="line">        Date d = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(d);<span class="comment">//Tue Sep 08 20:51:24 CST 2020</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h1><p>java.test.DateFormat:是日期/时间格式化子类的抽象类。</p>
<p>作用：格式化（也就是日期–&gt;文本），解析（文本—&gt;日期）。</p>
<p>成员方法：String format(Date date)：按照指定的模式，把Date日期，格式化为符合模式的字符串。</p>
<p>Date parse(String source):把符合模式的字符串，解析为Date日期。</p>
<p>DateFormat类是一个抽象类，无法直接创建对象使用，可以使用DateFormat类的子类。</p>
<p>java.text.SimplDateFormat</p>
<p>构造方法：SimplDateFormat(String pattern)</p>
<p>参数：String pattern:传递指定的模式。</p>
<p>模式：y年 M月 d日 H时 m分 s秒 S毫秒</p>
<p>写对应的模式，会把模式替换为对应的日期和时间</p>
<p>“yyyy-MM-dd HH:mm:ss”</p>
<p>注意：模式中的字母不能更改，连接模式的符号可以改变。</p>
<p>“yyyy年MM月dd日 HH时mm分ss秒”</p>
<p>使用DateFormat类中的方法format，把日期格式化为文本。使用步骤：</p>
<p>1、创建SimleDateFormat对象，构造方法中传递指定的模式。</p>
<p>2、调用SimleDateFormat对象中的方法format，按照构造方法中指定的模式，把Date日期格式化为符合模式的字符串文本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>);</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(format);<span class="comment">//2020年09月08日 21时24分40秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用DateFormat类中的方法parse，把文本解析为日期。</p>
<p>使用步骤：1、创建SimleDateFormat对象，构造方法中传递指定的模式。</p>
<p>2、调用SimleDateFormat对象中的方法parse，把符合构造方法中模式的字符串，解析为Date日期。</p>
<p>注意：public Date parse(String source) throws ParseException</p>
<p>如果字符串和构造方法的模式不一样，那么程序就会抛出异常。</p>
<p>调用一个抛出了异常的方法，就必须的处理这个异常，要么throws继续抛出这个异常，要么try catch自己处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        SimpleDateFormat s = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>);</span><br><span class="line">        Date parse = s.parse(<span class="string">&quot;2020年09月08日 21时24分40秒&quot;</span>);</span><br><span class="line">        System.out.println(parse);<span class="comment">//Tue Sep 08 21:24:40 CST 2020</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习：计算一个人出生了多少天？"><a href="#练习：计算一个人出生了多少天？" class="headerlink" title="练习：计算一个人出生了多少天？"></a>练习：计算一个人出生了多少天？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BriDay</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        Date bir = simpleDateFormat.parse(<span class="string">&quot;1997-10-02&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> time = bir.getTime();</span><br><span class="line">        <span class="keyword">long</span> time1 = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">        <span class="keyword">long</span> l = time1 - time;</span><br><span class="line">        System.out.println(l/<span class="number">24</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">1000</span>);<span class="comment">//8377</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h1><p>java.util.Calendar类：Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。</p>
<p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，将语言敏感内容处理好，再返回子类对象。</p>
<h3 id="Calendar类静态方法"><a href="#Calendar类静态方法" class="headerlink" title="Calendar类静态方法"></a>Calendar类静态方法</h3><p>Calendar c = Calendar.getInstance();  //返回当前时间</p>
<h3 id="Calendar类常用方法"><a href="#Calendar类常用方法" class="headerlink" title="Calendar类常用方法"></a>Calendar类常用方法</h3><p>public void add(int field,int amount)//指定字段增加某值</p>
<p>注意：int amount;可以为负值，代表减少某值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance(); </span><br><span class="line"><span class="comment">//修改当前时间为3天后</span></span><br><span class="line">c.add(Calendar.DATE, <span class="number">3</span>); </span><br><span class="line"><span class="comment">//修改当前时间为5小时后</span></span><br><span class="line">c.add(Calendar.HOUR, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>public final Date getTime()//获取该日历对象转成的日期对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">Date d = c.getTime();<span class="comment">//Tue Sep 08 22:33:38 CST 2020</span></span><br></pre></td></tr></table></figure>

<p>public final void set(int field,int value)//设置指定字段的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line"><span class="comment">//设置时间为2020年9月9日</span></span><br><span class="line">c.set(Calendar.YEAR, <span class="number">2020</span>);</span><br><span class="line">c.set(Calendar.MONTH, <span class="number">9</span>);</span><br><span class="line">c.set(Calendar.DATE, <span class="number">9</span>);</span><br></pre></td></tr></table></figure>

<p>public static Calendar getInstance() //获取日期对象</p>
<p>public int get(int field)//获取时间字段值，字段参见帮助文档</p>
<p>YEAR 年</p>
<p>MONTH 月，从0开始算起，最大11；0代表1月，11代表12月。</p>
<p>DATE 天</p>
<p>HOUR 时</p>
<p>MINUTE分</p>
<p>SECOND秒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">//        System.out.println(calendar);</span></span><br><span class="line">        <span class="keyword">int</span> year = calendar.get(calendar.YEAR);</span><br><span class="line">        <span class="keyword">int</span> month = calendar.get(calendar.MONTH);</span><br><span class="line">        <span class="keyword">int</span> date = calendar.get(calendar.DATE) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> hour = calendar.get(calendar.HOUR );</span><br><span class="line">        System.out.println(year);<span class="comment">//2020</span></span><br><span class="line">        System.out.println(month);<span class="comment">//9</span></span><br><span class="line">        System.out.println(date);<span class="comment">//8</span></span><br><span class="line">        System.out.println(hour);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<p>1、西方星期的开始为周日，中国为周一。</p>
<p>2、在Calendar类中，月份的表示是以0-11代表1-12月。</p>
<p>3、日期是有大小关系的，时间靠后，时间越大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/08/Object%E7%B1%BB%E3%80%81Date%E7%B1%BB%E3%80%81DateFormat%E7%B1%BB%E3%80%81Calendar%E7%B1%BBObject%E7%B1%BB%E3%80%81Date%E7%B1%BB%E3%80%81DateFormat%E7%B1%BB%E3%80%81Calendar%E7%B1%BB/" data-id="ckfb6v60d0004xcvw8m0wds1r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/20/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98/">java并发编程共享模型之不可变</a>
          </li>
        
          <li>
            <a href="/2020/09/20/%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8BCAS%E6%97%A0%E9%94%81%EF%BC%88%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%89/">共享模型之CAS无锁（乐观锁，非阻塞）</a>
          </li>
        
          <li>
            <a href="/2020/09/19/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98/">java并发编程共享模型之内存</a>
          </li>
        
          <li>
            <a href="/2020/09/19/ReentrantLock/">ReentrantLock</a>
          </li>
        
          <li>
            <a href="/2020/09/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/">Java并发编程共享模型之管程（二）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 我的笔记<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>