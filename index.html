<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>我的笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="我的笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="我的笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="我的笔记">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="我的笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">我的笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Linux(一)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/26/Linux(%E4%B8%80)/" class="article-date">
  <time datetime="2020-09-26T12:56:01.936Z" itemprop="datePublished">2020-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/26/Linux(%E4%B8%80)/">Linux(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h4 id="Linux介绍"><a href="#Linux介绍" class="headerlink" title="Linux介绍"></a>Linux介绍</h4><p>Linux是一个开源、免费的操作系统，其稳定性、安全性、处理多并发已经得到了业界的认可，目前很多企业级的项目都会部署到Linux和Unix系统上。</p>
<h4 id="网络配置三种方式理解"><a href="#网络配置三种方式理解" class="headerlink" title="网络配置三种方式理解"></a>网络配置三种方式理解</h4><p>一、桥接模式：</p>
<p>1、好处是大家都在同一个网段，相互可以通讯。</p>
<p>2、坏处是：因为ip地址有限，可能造成IP冲突</p>
<p>二、Nat（网络地址转换模式）</p>
<p>1、好处虚拟机不占用其它的IP，所以不会冲突</p>
<p>2、内网的其他人不能和虚拟机通讯</p>
<p>三、主机模式</p>
<p>单独的一台电脑</p>
<h4 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h4><p>具体的目录结构：</p>
<p>1、/bin  是Binary的缩写，这个目录放着经常使用的命令</p>
<p>2、/sbin s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p>
<p>3、/home  存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p>
<p>4、/root   该目录为系统管理员，也称作超级权限者的用户主目录</p>
<p>5、/lib   系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件，几乎所有的应用程序都需要用到这些共享库。</p>
<p>6、/lost+found    这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
<p>7、/etc   所有的系统管理需要的配置文件和子目录</p>
<p>8、usr    这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录</p>
<p>9、/boot   存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件</p>
<p>10、proc   这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统的信息。</p>
<p>11、/srv    service缩写，该目录存放一些服务启动之后需要提取的数据。</p>
<p>12、sys  该目录下安装2.6内核新出现的一个文件系统</p>
<p>13、/temp   这个目录是用来存放一些临时文件的。</p>
<p>14、/dev   类似于windows的设备管理器，把所有的硬件用文件的形式存储。</p>
<p>15、/media   Linux系统会自动识别一些设备，例如u盘、光驱等等，当时别后，Linux会把识别的设备挂载到这个目录下。</p>
<p>16、/mnt  系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。</p>
<p>17、/opt   这是给主机额外安装软件所摆放的目录。如安装数据库就可放到该目录下。默认为空</p>
<p>18、/user/local   这是另一个主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</p>
<p>19、/var   这个目录中存放着不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。</p>
<p>20、/selinux   类似于360，是一种安全子系统，他能控制程序只能访问特定文件。</p>
<p><strong>总结一下</strong></p>
<ul>
<li>Linux的目录中有且只有一个根目录/</li>
<li>Linux的各个目录存放的内容是规划好的，不要乱放文件。</li>
<li>Linux是以文件的形式管理我们的设备，因此Linux系统，一切皆为文件。</li>
<li>Linux的各个目录下存放什么内容，必须有一个认识。</li>
</ul>
<h4 id="远程登录到Linux服务器"><a href="#远程登录到Linux服务器" class="headerlink" title="远程登录到Linux服务器"></a>远程登录到Linux服务器</h4><p>为什么需要远程登录Linux？</p>
<ul>
<li>linux服务器是开发小组共享的</li>
<li>正式上线的项目是运行在公网的</li>
<li>因此程序员需要远程登录到centons进行项目管理或者开发。</li>
</ul>
<p>Linux操作系统是在机房的你进不去。</p>
<p>远程登录客户端有 Xshell,Xftp</p>
<h4 id="vi和vim编辑器"><a href="#vi和vim编辑器" class="headerlink" title="vi和vim编辑器"></a>vi和vim编辑器</h4><p>vi文本编辑器</p>
<p>vim具有程序编辑能力，可以看作是是vi的增强版本</p>
<h5 id="vi和vim的三种常见模式"><a href="#vi和vim的三种常见模式" class="headerlink" title="vi和vim的三种常见模式"></a>vi和vim的三种常见模式</h5><ul>
<li>正常模式/一般模式下</li>
</ul>
<p>在正常模式下，我们可以使用快捷键。</p>
<ul>
<li>插入模式/编辑模式</li>
</ul>
<p>此模式下，程序员可以输入内容。</p>
<p>按下i,I,o,O,a,A,rR等任何一个字母之后才会进入编辑模式，一般来说按i即可。</p>
<ul>
<li>命令行模式</li>
</ul>
<p>在这个模式当下，可以提供相关指令，完成读取、存盘、替换、离开vim、显示行号等的动作则是在此模式中达成的。</p>
<h5 id="vi和vim快捷键"><a href="#vi和vim快捷键" class="headerlink" title="vi和vim快捷键"></a>vi和vim快捷键</h5><p>1、拷贝当前行 yy，拷贝当前行下的5行 5yy，并粘贴p</p>
<p>2、删除当前行  dd，删除当前行向下的5行  5dd</p>
<p>3、在文件中查找某个单词【命令行下/关键字，回车查找，输入n就是查找下一个。】</p>
<p>4、编辑/etc/profile文件，使用快捷键到底文档的最末行[G]和最首行[gg]【一般模式下】</p>
<p>5、在一个文件中输入“hello”,然后又撤销这个动作u【一般模式下】</p>
<p>6、设置文件的行号，取消文件的行号【命令行下：set nu  和  set  nonu】</p>
<p>7、将光标移到20行   第一步：显示行号  ：set nu 第二部：输入20这个数  第三步： 输入shift+g</p>
<h4 id="关机、重启和用户登录注销"><a href="#关机、重启和用户登录注销" class="headerlink" title="关机、重启和用户登录注销"></a>关机、重启和用户登录注销</h4><p>shutdown</p>
<ul>
<li>shutdown -h now:表示立即关机</li>
<li>shutdown -h 1:表示1分钟后关机</li>
<li>shutdown -r now :立即重启</li>
</ul>
<p>halt  :就是直接使用，效果等价于关机</p>
<p>reboot:就是重启系统</p>
<p>sync:把内存的数据同步到磁盘。</p>
<p><strong>注意细节</strong></p>
<p>当我们关机或者重启时，都应该先执行一下sync指令，把内存的数据写入磁盘，防止数据丢失。</p>
<h5 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h5><p>1、登录时尽量少用root账号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用“su - 用户名”命令来切换成系统管理员身份。</p>
<p>2、在提示符下输入 logout 即可注销用户。</p>
<p><strong>使用细节</strong></p>
<p>logout注销指令在图形运行级别无效，在运行级别3下有效。</p>
<h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p>说明：</p>
<p>1、Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>2、Linux的用户需要至少要属于一个组。</p>
<h5 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h5><p>基本语法</p>
<p>useradd [选项] 用户名</p>
<p><strong>细节说明</strong></p>
<p>1、当创建用户成功后，会自动地创建和用户同名的家目录</p>
<p>2、也可以通过 useradd -d 指定目录   新的用户名，给新创建的用户指定家目录。</p>
<h5 id="给用户指定或者修改密码"><a href="#给用户指定或者修改密码" class="headerlink" title="给用户指定或者修改密码"></a>给用户指定或者修改密码</h5><p>基本语法</p>
<p>passwd   用户名</p>
<h5 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h5><p>基本语法</p>
<p>userdel  用户名</p>
<p><strong>应用案例</strong></p>
<p>1、删除用户xm,但是要保留家目录</p>
<p>userdel xm</p>
<p>2、删除用户xh以及用户主目录</p>
<p>userdel -r xh</p>
<p><strong>注意细节</strong></p>
<p>在删除用户时，我们一般不会将家目录删除。</p>
<h5 id="查询用户信息"><a href="#查询用户信息" class="headerlink" title="查询用户信息"></a>查询用户信息</h5><p>基本语法</p>
<p>id  用户名</p>
<p><strong>应用实例</strong></p>
<p>查询root信息</p>
<p><strong>细节说明</strong></p>
<p>当用户不存在，返回无此用户。</p>
<h5 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h5><p>在操作Linux中，如果当前用户的权限不够，可以通过 su - 指令，切换到高权限用户，比如root。</p>
<p><strong>基本语法</strong></p>
<p>su - 切换用户名</p>
<p><strong>应用实例</strong></p>
<p>创建一个用户zf，指定密码，然后切换到zf。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useradd zf</span><br><span class="line">passwd zf</span><br><span class="line">su - zf</span><br><span class="line">exit   &#x2F;&#x2F;回到root用户</span><br></pre></td></tr></table></figure>

<p><strong>注意细节</strong></p>
<p>1、从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。</p>
<p>2、当需要返回到原来用户时，使用exit指令。</p>
<h5 id="查看当前用户-登录用户"><a href="#查看当前用户-登录用户" class="headerlink" title="查看当前用户/登录用户"></a>查看当前用户/登录用户</h5><p>基本语法</p>
<p>whoami / who am I</p>
<h4 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h4><p>类似于角色，系统可以对有共性的多个用户进行统一的管理。</p>
<p><strong>增加组</strong></p>
<p>groupadd 组名</p>
<p><strong>删除组</strong></p>
<p>groupdel 组名</p>
<p><strong>增加用户时直接加上组</strong></p>
<p>基本语法</p>
<p>useradd -g 用户组   用户名</p>
<p><strong>案例演示</strong></p>
<p>增加一个用户 zwj，直接将他指定到  wudang组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd wudang</span><br><span class="line">useradd -g wudang zwj</span><br></pre></td></tr></table></figure>

<h5 id="修改用户的组"><a href="#修改用户的组" class="headerlink" title="修改用户的组"></a>修改用户的组</h5><p>基本语法</p>
<p>usermod -g 用户组  用户名</p>
<p><strong>案例演示</strong></p>
<p>创建一个shaolin组，让将 zwj 用户修改到 shaolin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupadd shaolin</span><br><span class="line">usermod -g shaolin zwj</span><br><span class="line">id zwj</span><br></pre></td></tr></table></figure>

<h4 id="用户和组的配置"><a href="#用户和组的配置" class="headerlink" title="用户和组的配置"></a>用户和组的配置</h4><h5 id="etc-passwd-文件"><a href="#etc-passwd-文件" class="headerlink" title="/etc/passwd 文件"></a>/etc/passwd 文件</h5><p>用户（user）的配置文件，记录用户的各种信息</p>
<p>每行的含义：用户名：口令：用户标识：组标识号：注释性描述：主目录：登录Shall。</p>
<h5 id="etc-shadow-文件"><a href="#etc-shadow-文件" class="headerlink" title="/etc/shadow 文件"></a>/etc/shadow 文件</h5><p>口令（密码和登录信息）的配置文件</p>
<p>每行的含义：登录名：加密口令：最后一次修改的时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志。</p>
<h5 id="etc-group-文件"><a href="#etc-group-文件" class="headerlink" title="/etc/group  文件"></a>/etc/group  文件</h5><p>组（group）的配置文件，记录Linux包含的组的信息</p>
<p>每行含义：组名：口令：组标识号：组内用户列表(用户列表看不到)。</p>
<h4 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h4><h5 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h5><p>运行级别说明</p>
<p>0：关机</p>
<p>1：单用户【找回丢失密码】</p>
<p>2：多用户状态没有网络服务</p>
<p>3：多用户状态有网络服务</p>
<p>4：系统未使用保留给用户</p>
<p>5：图形界面</p>
<p>6：系统重启</p>
<p>常用运行级别是3和5，要修改默认的运行级别可改文件。</p>
<p>/etc/inittab 的id：5：initdefault：这一行的数字</p>
<h5 id="切换到指定运行级别的指令"><a href="#切换到指定运行级别的指令" class="headerlink" title="切换到指定运行级别的指令"></a>切换到指定运行级别的指令</h5><p>基本语法</p>
<p>init [012356]</p>
<p><strong>应用案例</strong></p>
<p>通过init来切换不同的运行级别，比如3-》5-》0关机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init 3</span><br><span class="line">init 5</span><br><span class="line">init 0</span><br></pre></td></tr></table></figure>

<h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><p>如何找回root密码</p>
<p>思路：进入到单用户模式，然后修改root密码。因为进入单用户模式，root不需要密码就可以登录。</p>
<p><strong>总结过程</strong></p>
<p>开机-&gt;在引导时输入  回车键 -&gt; 看到一个界面输入 e-&gt;看到一个新的界面，选中第二行（编辑内核）在输入e-&gt;在这行最后输入  1，在输入  回车键-&gt;再次输入b，这时就会进入到单用户模式。这时，我们就进入到单用户模式，使用passwd指令来修改root密码。</p>
<h4 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h4><p>当我们对某个指令不熟悉时，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法。</p>
<h5 id="man获得帮助信息"><a href="#man获得帮助信息" class="headerlink" title="man获得帮助信息"></a>man获得帮助信息</h5><p>基本语法</p>
<p>man [命令或配置文件]（功能描述：获得帮助信息）</p>
<p><strong>应用实例</strong></p>
<p>查看ls命令的帮助信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ls</span><br></pre></td></tr></table></figure>

<h5 id="help指令"><a href="#help指令" class="headerlink" title="help指令"></a>help指令</h5><p>基本语法</p>
<p>help 命令  （功能描述：获得shell内置命令的帮助信息）</p>
<p><strong>应用案例</strong></p>
<p>查看cd命令的帮助信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help cd</span><br></pre></td></tr></table></figure>

<h4 id="文件目录类指令"><a href="#文件目录类指令" class="headerlink" title="文件目录类指令"></a>文件目录类指令</h4><h5 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a>pwd指令</h5><p>基本语法</p>
<p>pwd  （功能描述：显示当前工作目录的绝对路径）</p>
<h5 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h5><p>基本语法</p>
<p>ls  [选项] [目录或是文件]</p>
<p>常用选项</p>
<ul>
<li>-a:显示当前目录所有的文件和目录，包括隐藏的。</li>
<li>-l:以列表的方式显示信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">ls -a</span><br><span class="line">ls -l</span><br><span class="line">ls -al</span><br></pre></td></tr></table></figure>

<h5 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a>cd指令</h5><p>基本语法</p>
<p>cd [参数]   （功能描述：切换到指定目录）</p>
<p>常用参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~ 或者 cd  回到自己的家目录</span><br><span class="line">cd..  回到当前目录的上一级目录</span><br></pre></td></tr></table></figure>

<h5 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a>mkdir指令</h5><p>mkdir指令用于创建mul</p>
<p>基本语法</p>
<p>mkdir [选项] 要创建的目录</p>
<p>常用选项</p>
<p>-p:创建多级目录</p>
<p><strong>应用实例</strong></p>
<p>创建一个目录/home/dog</p>
<p>创建多级目录/home/animal/tiger</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;home&#x2F;dog</span><br><span class="line">mkdir -p &#x2F;home&#x2F;animal&#x2F;tiger</span><br></pre></td></tr></table></figure>

<h5 id="rmdir指令"><a href="#rmdir指令" class="headerlink" title="rmdir指令"></a>rmdir指令</h5><p>rmdir指令删除空目录</p>
<p>基本语法</p>
<p>rmdir [选项]  要删除的空目录</p>
<p><strong>应用案例</strong></p>
<p>删除/home/dog目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir &#x2F;home&#x2F;dog</span><br></pre></td></tr></table></figure>

<p><strong>使用细节</strong></p>
<p>1、rmdir删除的是空目录，如果是目录下有内容时无法删除的</p>
<p>2、提示：如果需要删除非空目录，需要使用rm -rf要删除的目录。</p>
<h5 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h5><p>touch指令创建空文件</p>
<p>基本语法</p>
<p>touch 文件名称</p>
<p><strong>应用实例</strong></p>
<p>创建一个空文件hello.txt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch hello.txt</span><br><span class="line">touch 1.txt 2.txt  &#x2F;&#x2F;可以一次创建多个空文件</span><br></pre></td></tr></table></figure>

<h5 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a>cp指令</h5><p>cp指令拷贝文件到指定目录</p>
<p>基本语法</p>
<p>cp [选项] source dest</p>
<p>常用选项</p>
<p>-r:递归复制整个文件夹</p>
<p><strong>应用实例</strong></p>
<p>将/home/aaa.txt拷贝到/home/bbb目录下</p>
<p>递归复制整个文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp aaa.txt bbb&#x2F;</span><br><span class="line">cp -r test&#x2F; zwj&#x2F;   &#x2F;&#x2F;test文件夹里有文件</span><br></pre></td></tr></table></figure>



<p><strong>使用细节</strong></p>
<p>强制覆盖不提示的方法：\cp   //要复制的文件或文件夹  目标文件已经有了  强制覆盖。</p>
<h5 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h5><p>rm指令移除文件或目录</p>
<p>基本语法</p>
<p>rm [选项]   要删除的文件或目录</p>
<p>常用选项</p>
<p>-r  ：递归删除整个文件夹</p>
<p>-f :强制删除不提示</p>
<p><strong>应用实例</strong></p>
<p>将/home/aaa.txt删除</p>
<p>递归删除整个文件夹 /home/bbb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm aaa.txt</span><br><span class="line">rm -rf bbb&#x2F;</span><br></pre></td></tr></table></figure>



<p><strong>使用细节</strong></p>
<p>强制删除不提示的方法：带上 -f 参数即可。</p>
<h5 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h5><p>mv移动文件与目录或重命名</p>
<p>基本语法</p>
<p>mv oldNameFile  newNameFile   (功能描述：重命名)</p>
<p>mv /temp/movefile /targetFolder  (功能描述：移动文件)</p>
<p><strong>应用实例</strong></p>
<p>将/home/aaa.txt  文件   重命名为 pig.txt</p>
<p>将/home/pig.txt 文件移动到 /root目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv aaa.txt pig.txt</span><br><span class="line">mv pig.txt &#x2F;root     &#x2F;&#x2F;原理先移动已经有文件就重命名  没有就是移动</span><br></pre></td></tr></table></figure>

<h5 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h5><p>cat查看文件内容</p>
<p>基本语法</p>
<p>cat [选项] 要查看的文件</p>
<p>常用选项</p>
<p>-n : 显示行号</p>
<p><strong>应用实例</strong></p>
<p>/etc/profile  文件内容，并显示行号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;profile</span><br><span class="line">cat -n &#x2F;etc&#x2F;profile</span><br><span class="line">cat -n &#x2F;etc&#x2F;profile | more&#x2F;&#x2F;分页浏览</span><br></pre></td></tr></table></figure>



<p><strong>使用细节</strong></p>
<p>cat 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上  管道命令  |more</p>
<h5 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a>more指令</h5><p>more指令是一个基于vi编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。</p>
<p>more指令中内置了若干快捷键，详见操作说明</p>
<p>基本语法</p>
<p>more  要查看的文件</p>
<p>快捷键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">空格    代表向下翻一行</span><br><span class="line">回车     代表向下翻一行</span><br><span class="line">q       代表立即离开more，不在显示该文件内容</span><br><span class="line">ctrl+f   向下滚动一屏</span><br><span class="line">ctrl + b  返回上一屏</span><br><span class="line">&#x3D;       输出当前行的行号</span><br><span class="line">：f      输出文件名和当前行的行号</span><br></pre></td></tr></table></figure>

<p><strong>应用实例</strong></p>
<p>采用more查看文件/etc/profile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h5 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h5><p>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，<strong>对于显示大型文件具有较高的效率</strong></p>
<p>基本语法</p>
<p>less   要查看的文件</p>
<p>快捷键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">空格    向下翻动一页</span><br><span class="line">[pagedown] 向下翻动一页</span><br><span class="line">[pageup]   向上翻动一页</span><br><span class="line">&#x2F;字串    向下搜寻[字串]的功能：n:向下查找  N：向上查找</span><br><span class="line">？字串    向上搜寻[字串]的功能：n：向上查找 N：向下查找</span><br><span class="line">q   离开less这个程序</span><br></pre></td></tr></table></figure>

<h5 id="gt-指令和-gt-gt-指令"><a href="#gt-指令和-gt-gt-指令" class="headerlink" title="&gt;指令和&gt;&gt;指令"></a>&gt;指令和&gt;&gt;指令</h5><p>**&gt;输出重定向：会将原来的文件的内容覆盖</p>
<p>**&gt;&gt;追加：不会覆盖原来文件的内容，而是追加到文件的尾部。</p>
<p>基本语法</p>
<p>1、ls -l &gt;文件   （功能描述：列表的内容写入文件a.txt中（覆盖写））</p>
<p>说明：如果该文件不存在，就创建该文件。</p>
<p>2、ls -al &gt;&gt; 文件  （功能描述；列表的内容追加到文件aa.txt的末尾）</p>
<p>3、cat 文件1 &gt; 文件2 （功能描述：将文件1的内容覆盖到文件2）</p>
<p>4、echo “内容” &gt;&gt;文件  （功能描述：将文件1的内容覆盖到文件2）</p>
<h5 id="cal显示日历"><a href="#cal显示日历" class="headerlink" title="cal显示日历"></a>cal显示日历</h5><h5 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a>echo指令</h5><p>echo输出内容到控制台</p>
<p>基本语法</p>
<p>echo [选项] [输出内容]</p>
<p><strong>应用实例</strong></p>
<p>案例:使用echo指令输出环境变量,输出当前的环境路径</p>
<p>案例：使用echo 指令输出hello,world!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">echo &quot;hello,world&quot;</span><br></pre></td></tr></table></figure>

<h5 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h5><p>head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容</p>
<p>基本语法</p>
<p>head 文件   （功能描述：查看文件头10行内容）</p>
<p>head -n 5文件   （功能描述；查看文件头5行内容，5可以是任意行数）</p>
<p><strong>应用实例</strong></p>
<p>查看/etc/profile 的前面5行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 5 &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h5 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h5><p>tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容。</p>
<p>基本语法</p>
<p>1、tail 文件  （功能描述:查看文件后10行内容）</p>
<p>2、tail -n 5 文件  （功能描述：查看文件后5行内容，5可以是任意行数）</p>
<p>3、tail -f 文件  （功能描述；实时追踪该文档的所有更新）</p>
<p><strong>应用实例</strong></p>
<p>查看/etc/profile 最后5行代码</p>
<p>实时监控mydate.txt,看看文件有变化时，是否看到，实时的追加日期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail -n 5 &#x2F;etc&#x2F;profile</span><br><span class="line">tail -f mydate.txt</span><br></pre></td></tr></table></figure>

<h5 id="ln指令"><a href="#ln指令" class="headerlink" title="ln指令"></a>ln指令</h5><p>软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其它文件的路径</p>
<p>基本语法</p>
<p>ln -s [原文件或目录] [软连接名] （功能描述：给原文件创建一个软链接）</p>
<p><strong>实例应用</strong></p>
<p>在/home目录下创建一个软连接linkToRoot,连接到/root目录</p>
<p>删除软连接linkToRoot</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s &#x2F;root linkToRoot</span><br><span class="line">rm -rf linkToRoot</span><br></pre></td></tr></table></figure>

<p><strong>细节说明</strong></p>
<p>当我们使用pwd指令查看目录时，依然看到的是软链接所在的目录</p>
<h5 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a>history指令</h5><p>查看已经执行过历史命令，也可以执行历史指令</p>
<p>基本语法</p>
<p>history  (功能描述；查看已经执行过历史命令)</p>
<p><strong>应用实例</strong></p>
<p>显示所有的历史命令</p>
<p>显示最近使用过的10个指令</p>
<p>执行历史编号为5的指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history</span><br><span class="line">history 10</span><br><span class="line">!5</span><br></pre></td></tr></table></figure>

<h4 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h4><h5 id="date指令-显示当前日期"><a href="#date指令-显示当前日期" class="headerlink" title="date指令-显示当前日期"></a>date指令-显示当前日期</h5><p>基本语法</p>
<p>1、date   (功能描述：显示当前时间)</p>
<p>2、date +%Y (功能描述：显示当前年份)</p>
<p>3、date+%m   (功能描述 ：显示当前月份)</p>
<p>4、date+%d   (功能描述：显示当前是哪一天)</p>
<p>5、date “+%Y-%m-%d %H:%:%M:%S”   (功能描述：显示年月日时分秒)</p>
<h5 id="date指令-设置日期"><a href="#date指令-设置日期" class="headerlink" title="date指令-设置日期"></a>date指令-设置日期</h5><p>基本语法</p>
<p>date -s 字符串时间</p>
<p><strong>应用实例</strong></p>
<p>设置系统当前时间，比如设置为2020-11-11 11:22:22</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s &quot;2020-11-11 11:22:22&quot;</span><br></pre></td></tr></table></figure>

<h5 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h5><p>查看日历指令</p>
<p>基本语法</p>
<p>cal [选项]  （功能描述：不加选项，显示本月日历）</p>
<p><strong>应用案例</strong></p>
<p>显示当前日历</p>
<p>显示2020年日历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cal</span><br><span class="line">cal 2020</span><br></pre></td></tr></table></figure>

<h4 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h4><h5 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h5><p>find指令将从指令目录向下递归地遍历各个子目录，将满足条件的文件或者目录显示在中断。</p>
<p>基本语法</p>
<p>find [搜索范围] [选项]</p>
<p>选项说明</p>
<p>-name&lt;查询方式&gt;       （功能：按照指定的文件名查找模式查找文件）</p>
<p>-user&lt;用户名&gt;     （功能；查找属于指定用户名所有文件）</p>
<p>-size&lt;文件大小&gt;   （功能：按照指定的文件大小查找文件）</p>
<p><strong>应用实例</strong></p>
<p>1、按文件名：根据名称查找/home目录下的hello.txt文件</p>
<p>2、按拥有者：查找/opt目录下，用户名称为 noboby的文件</p>
<p>3、查找整个Linux系统下大于20m的文件（+n  大于   -n  小于   n  等于）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;home -name hello.txt</span><br><span class="line">find &#x2F;opt -user nobody</span><br><span class="line">find &#x2F; -size +20M</span><br><span class="line">find &#x2F; -size -20M  &#x2F;&#x2F;小于20M</span><br><span class="line">find &#x2F; -size 20480k   &#x2F;&#x2F;k要小写</span><br></pre></td></tr></table></figure>

<h5 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a>locate指令</h5><p>locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有的文件名称及路径的locate数据库实现快速定位给定的文件。locate指令无需遍历整个文件系统，查询速度较快。</p>
<p>基本语法</p>
<p>locate    搜索文件</p>
<p>由于locate 指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库。</p>
<p><strong>应用实例</strong></p>
<p>使用locate指令快速定位hello.txt文件所在的目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">updatedb</span><br><span class="line">locate hello.txt</span><br></pre></td></tr></table></figure>

<h5 id="gred指令和管道符号"><a href="#gred指令和管道符号" class="headerlink" title="gred指令和管道符号 |"></a>gred指令和管道符号 |</h5><p>gred过滤查找，管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。</p>
<p>基本语法</p>
<p>grep [选项]  查找内容   源文件</p>
<p>常用选项</p>
<p>-n      (功能：显示匹配行及行号)</p>
<p>-i      (功能：忽略字母大小写)</p>
<p><strong>应用案例</strong></p>
<p>请在hello.txt文件中，查找“yes”所在行，并且显示行号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat hello.txt | grep -n yes</span><br><span class="line">cat hello.txt | grep -ni yes   &#x2F;&#x2F;显示行号和不区分大小写</span><br></pre></td></tr></table></figure>

<h4 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h4><h5 id="gzip-gunzip指令"><a href="#gzip-gunzip指令" class="headerlink" title="gzip/gunzip指令"></a>gzip/gunzip指令</h5><p>gzip用于压缩文件，gunzip用于解压的</p>
<p>基本语法</p>
<p>gzip  文件   （功能描述：压缩文件，只能将文件压缩为*.gz文件）</p>
<p>gunzip  文件.gz    （功能描述：解压缩文件命令）</p>
<p><strong>应用实例</strong></p>
<p>gzip压缩，将/home下的hello.txt文件进行压缩</p>
<p>gunzip压缩，将/home下的hello.txt.gz文件进行解压缩。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip hello.txt</span><br><span class="line">gunzip hello.txt.gz</span><br></pre></td></tr></table></figure>

<p><strong>细节说明</strong></p>
<p>当我们使用gzip对文件进行压缩后，不会保留原来的文件。</p>
<h4 id="zip-unzip指令"><a href="#zip-unzip指令" class="headerlink" title="zip/unzip指令"></a>zip/unzip指令</h4><p>zip用于压缩指令，unzip用于解压的，这个在项目打包发布中很有用</p>
<p>基本语法</p>
<p>zip [选项]  XXX.zip 将要压缩的内容  （功能描述：压缩文件和目录命令）</p>
<p>unzip [选项]  XXX.zip   (功能描述：解压文件)</p>
<p>zip常用选项</p>
<p>-r   :递归压缩，即压缩目录</p>
<p>unzip的常用选项</p>
<p>-d&lt;目录&gt;：指定解压后文件的存放目录</p>
<p><strong>应用实例</strong></p>
<p>将/home下的所有文件进行压缩成mypackage.zip</p>
<p>将mypack.zip解压到/opt/tmp目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip -r mypackage.zip &#x2F;home&#x2F;</span><br><span class="line">unzip -d &#x2F;opt&#x2F;tem&#x2F; mypackage.zip</span><br></pre></td></tr></table></figure>

<h4 id="压缩和解压类-1"><a href="#压缩和解压类-1" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h4><h5 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h5><p>tar指令是打包指令，最后打包后的文件是.tar.gz的文件。</p>
<p>基本语法</p>
<p>tar [选项] XXX.tar.gz  打包的内容   （功能描述：打包目录，压缩后的文件格式.tar.gz）</p>
<p>选项说明</p>
<p>-c   :产生.tar打包文件</p>
<p>-v   :显示详细信息</p>
<p>-f  :指定压缩后的文件名</p>
<p>-z  :打包同时压缩</p>
<p>-x  :解包.tar文件</p>
<p><strong>应用实例</strong></p>
<p>1、压缩多个文件，将/home/a1.txt和/home/a2.txt压缩成a.tar.gz</p>
<p>2、将/home的文件夹压缩成myhome.tar.gz</p>
<p>3、将a.tar.gz解压到当前目录</p>
<p>4、将myhome.tar.gz  解压到 /opt/目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf a.tar.gz a1.txt a2.txt</span><br><span class="line">tar -zcvf myhome.tar.gz &#x2F;home&#x2F;</span><br><span class="line">tar -zxvf a.tar.gz</span><br><span class="line">tar -zxvf myhome.tar.gz &#x2F;opt&#x2F;   &#x2F;&#x2F; 指定解压的目录事先要存在，否者会报错</span><br></pre></td></tr></table></figure>

<h4 id="组管理和权限管理（难点，重点）"><a href="#组管理和权限管理（难点，重点）" class="headerlink" title="组管理和权限管理（难点，重点）"></a>组管理和权限管理（难点，重点）</h4><h5 id="Linux组基本介绍"><a href="#Linux组基本介绍" class="headerlink" title="Linux组基本介绍"></a>Linux组基本介绍</h5><p>在Linux中的每个用户必须属于一个组，不能独立于组外。在Linux中每个文件有所有者、所在组、其它组的概念。</p>
<p>1、所有者</p>
<p>2、所在组</p>
<p>3、其它组</p>
<p>4、改变用户所在的组</p>
<h5 id="文件-目录所有者"><a href="#文件-目录所有者" class="headerlink" title="文件/目录所有者"></a>文件/目录所有者</h5><p>一般为文件的创建者，谁创建了该文件，就自然的成为该文件的所有者。</p>
<h5 id="查看文件的所有者"><a href="#查看文件的所有者" class="headerlink" title="查看文件的所有者"></a>查看文件的所有者</h5><h6 id="指令：ls-ahl"><a href="#指令：ls-ahl" class="headerlink" title="指令：ls-ahl"></a>指令：ls-ahl</h6><p><strong>应用实例</strong></p>
<p>创建一个组police，在创建一个用户tom，将tom放在police组，然后使用tom来创建一个文件o.txt，看看情况如何</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">groupadd police</span><br><span class="line">useradd -g police tom</span><br><span class="line">passws tom</span><br><span class="line">su - tom</span><br><span class="line">touch ok.txt</span><br><span class="line">ls -ahl</span><br></pre></td></tr></table></figure>

<h5 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h5><h6 id="指令：chown-用户名-文件名"><a href="#指令：chown-用户名-文件名" class="headerlink" title="指令：chown  用户名  文件名"></a>指令：chown  用户名  文件名</h6><p><strong>应用实例</strong></p>
<p>使用root创建一个文件apple.txt,然后将其所有者修改成tom</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch apple.txt</span><br><span class="line">ls -l</span><br><span class="line">chown tom apple.txt</span><br></pre></td></tr></table></figure>

<h5 id="组的创建"><a href="#组的创建" class="headerlink" title="组的创建"></a>组的创建</h5><h6 id="基本指令-groupadd-组名"><a href="#基本指令-groupadd-组名" class="headerlink" title="基本指令 groupadd 组名"></a>基本指令 groupadd 组名</h6><p><strong>应用实例</strong></p>
<p>创建一个组，monster</p>
<p>创建用给用户fox，并放入到monster组中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupadd monster</span><br><span class="line">useradd -g monster fox</span><br><span class="line">id fox</span><br></pre></td></tr></table></figure>

<h4 id="文件-目录所在组"><a href="#文件-目录所在组" class="headerlink" title="文件/目录所在组"></a>文件/目录所在组</h4><p>当某个用户创建一个文件后，这个文件的所在组就是该用户所在组。</p>
<h5 id="查看文件-目录所在组"><a href="#查看文件-目录所在组" class="headerlink" title="查看文件/目录所在组"></a>查看文件/目录所在组</h5><h6 id="基本指令-ls-ahl"><a href="#基本指令-ls-ahl" class="headerlink" title="基本指令  ls -ahl"></a>基本指令  ls -ahl</h6><h5 id="修改文件所在组"><a href="#修改文件所在组" class="headerlink" title="修改文件所在组"></a>修改文件所在组</h5><h6 id="基本指令-chgrp-组名-文件名"><a href="#基本指令-chgrp-组名-文件名" class="headerlink" title="基本指令   chgrp 组名  文件名"></a>基本指令   chgrp 组名  文件名</h6><p><strong>应用实例</strong></p>
<p>使用root用户创建文件 orange.txt，看看当前这个文件属于哪个组，然后将这个文件所在组，修改到 polic组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch orange.txt</span><br><span class="line">ls -ahl</span><br><span class="line">chgrp polic orange.txt</span><br></pre></td></tr></table></figure>

<h4 id="其它组"><a href="#其它组" class="headerlink" title="其它组"></a>其它组</h4><p>除了文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</p>
<h5 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h5><p>在添加用户是，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组。</p>
<h6 id="指令：改变用户所在组"><a href="#指令：改变用户所在组" class="headerlink" title="指令：改变用户所在组"></a>指令：改变用户所在组</h6><p>1、usermod -g 组名  用户名</p>
<p>2、usermod -d 目录名   用户名   改变该用户登录的初始目录。</p>
<p><strong>应用实例</strong></p>
<p>创建一个bandit将tom这个用户从原来所在的police组，修改到bandit组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id tom</span><br><span class="line">groupadd bandit</span><br><span class="line">usermod -g bandit tom</span><br><span class="line">id tom</span><br></pre></td></tr></table></figure>

<h4 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h4><p>ls -l 中显示的内容如下</p>
<p><strong>0-9位说明</strong></p>
<p>1、第0位确定文件类型（d,-,l,c,b）</p>
<p>2、第1-3位确定所有者（该文件的所有者）拥有该文件的权限。—User</p>
<p>3、第4-6位确定所属组（同用户组的）拥有该文件的权限。—Group</p>
<p>4、第7-9位确定其它用户拥有该文件的权限。—Other。</p>
<h5 id="rwx权限详解"><a href="#rwx权限详解" class="headerlink" title="rwx权限详解"></a>rwx权限详解</h5><h6 id="rwx作用到文件"><a href="#rwx作用到文件" class="headerlink" title="rwx作用到文件"></a>rwx作用到文件</h6><p>1、[r]代表可读（read）:可以读取，查看</p>
<p>2、[w]代表可写（write）：可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除文件。</p>
<p>3、[x]代表可执行（execute）:可以被执行</p>
<h6 id="rwx作用到目录"><a href="#rwx作用到目录" class="headerlink" title="rwx作用到目录"></a>rwx作用到目录</h6><p>1、[r]代表可读（read）:可以读取，ls查看目录内容。</p>
<p>2、[w]代表可写（write）:可以修改，目录内创建+删除+重命名目录。</p>
<p>3、[x]代表可执行（execute）:可以进入该目录。</p>
<h5 id="修改权限-chmod"><a href="#修改权限-chmod" class="headerlink" title="修改权限 -chmod"></a>修改权限 -chmod</h5><p>基本说明</p>
<p>通过chmod指令，可以修改文件或目录的权限。</p>
<p><strong>第一种方式：+、-、=变更权限</strong></p>
<p>u:所有者  g:所有组  o:其他人 a：所有人（u,g,o的总和）</p>
<p>1、chmod  u = rwx,g = rx, o = x   文件目录名</p>
<p>2、chmod o + w   文件目录名</p>
<p>3、chmod  a - x  文件目录名 </p>
<p><strong>案例演示</strong></p>
<p>1、给abc文件的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">touch abc</span><br><span class="line">ls -l</span><br><span class="line">chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx abc</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>

<p>2、给abc文件的所有者除去执行的权限，增加组写的权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u-x,g+w abc</span><br></pre></td></tr></table></figure>

<p>3、给abc文件的所有用户添加读的权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod a+r abc</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>

<p><strong>第二种方式：通过数字变更权限</strong></p>
<p>r=4  w=2  x=1    rwx = 4+2+1=7</p>
<p>chmod u = rwx,g=rx,0=x   文件目录名</p>
<p>相当于chmod 751 文件目录名</p>
<p><strong>案例演示</strong></p>
<p>将/home/abc.txt文件的权限修改成 rwxr-xr-x,使用给数字的方式实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch abc.txt</span><br><span class="line">chmod 755 abc.txt</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>

<h5 id="修改文件所有者-chown"><a href="#修改文件所有者-chown" class="headerlink" title="修改文件所有者 -chown"></a>修改文件所有者 -chown</h5><p>基本介绍</p>
<p>chown newowner file   改变文件的所有者</p>
<p>chowm newowner:newgroup file  改变用户的所有者和所有组</p>
<p>-R  如果是目录   则使其下所有子文件或目录递归生效。</p>
<p><strong>案例演示</strong></p>
<p>1、将/home/abc.txt文件的所有者修改成tom</p>
<p>2、将/home/kkk目录下所有的文件和目录的所有者都修改成tom。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown tom abc.txt</span><br><span class="line">chown -R tom kkk&#x2F;</span><br></pre></td></tr></table></figure>

<h5 id="修改文件所在组-chgrp"><a href="#修改文件所在组-chgrp" class="headerlink" title="修改文件所在组 -chgrp"></a>修改文件所在组 -chgrp</h5><p>基本介绍</p>
<p>chgrp newgroup file  改变文件的所有组</p>
<p><strong>案例演示</strong></p>
<p>1、将/home/abc.txt文件的所有组修改成bandit组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp bandit abc.txt</span><br></pre></td></tr></table></figure>

<p>2、将/home/kkk目录下所有的文件和目录的所在组都修改成bandit组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp -R bandit &#x2F;home&#x2F;kkk</span><br></pre></td></tr></table></figure>

<h4 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h4><h5 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h5><p>crontab进行定时任务的设置。</p>
<p>概述</p>
<p>任务调度：是指系统在某个时间执行的特定的命令或程序</p>
<p>任务调度分类：1.系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等。2、个别用户工作：个别用户可能希望执行某些程序，比如说对mysql数据库的备份。</p>
<p>基本语法：</p>
<p>crontab [选项]</p>
<p>常用选项</p>
<p>-e     编辑crontab定时任务</p>
<p>-l      查询crontab任务</p>
<p>-r     删除当前用户所有的crontab任务。</p>
<p>参数细节说明：5个占位符的说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一个‘*’   一小时当中的第几分钟   0-59</span><br><span class="line">第二个‘*’    一天当中的第几个小时  0-23</span><br><span class="line">第三个‘*’    一个月当中的第几天    1-31</span><br><span class="line">第四个‘*’     一年当中的第几月    1-12</span><br><span class="line">第五个‘*’      一周当中的星期几   0-7（0和7都代表星期日）</span><br></pre></td></tr></table></figure>

<p>特殊符号说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*      代表任何时间。比如第一个‘*’就代表一个小时中每分钟都执行一次的意思</span><br><span class="line">，     代表不连续的时间。比如‘08，12，16****命令’，就代表在每天的8点，12点，16点都执行一次命令</span><br><span class="line">-    代表连续的时间范围。比如‘05**1-6命令’，代表在周一到周六的凌晨5点执行命令</span><br><span class="line">*&#x2F;n   代表每隔多久执行一次。比如‘*&#x2F;10****命令’ ，代表每隔10分钟执行一遍命令</span><br></pre></td></tr></table></figure>

<p><strong>快速入门</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">*&#x2F;*****ls -l &#x2F;etc &gt;&gt;&#x2F;tmp&#x2F;to.txt</span><br></pre></td></tr></table></figure>

<p>每分钟都会自动的调用ls -l /etc &gt;&gt;/tmp/to.txt</p>
<p><strong>案例</strong></p>
<p>1、每隔1分钟，就将当前日期的信息，追加到/tmp/mydate 文件中</p>
<ul>
<li>先编写一个文件 /home/mytask1.sh<ul>
<li>date &gt;&gt; /tmp/mydate</li>
</ul>
</li>
<li>给mytask1.sh一个可以执行权限<ul>
<li>chmod 744 mytask1.sh</li>
</ul>
</li>
<li>crontab -e<ul>
<li>1 * * * *  /home/mytask1.sh</li>
</ul>
</li>
</ul>
<p>第二方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">1***** date &gt;&gt; &#x2F;tmp&#x2F;mydate</span><br></pre></td></tr></table></figure>

<p>2、每隔一分钟，将当前日期和日历都追加到/home/mycal 文件中</p>
<ul>
<li>先编写一个文件 /home/mytask2.sh<ul>
<li>date &gt;&gt; /tmp/mycal</li>
<li>cal &gt;&gt; /tmp/mycal</li>
</ul>
</li>
<li>给mytask2.sh一个可以执行权限<ul>
<li>chmod 744 mytask2.sh</li>
</ul>
</li>
<li>crontab -e<ul>
<li>1 * * * *  /home/mytask2.sh</li>
</ul>
</li>
</ul>
<p>3、每天凌晨2：00将mysql数据库 testdb，备份到文件中mydb.bak.</p>
<ul>
<li>先编写一个文件 /home/mytask3.sh<ul>
<li>/usr/local/mysql/bin/mysqldump -u root -p root testdb &gt; /tmp/mydb.bak</li>
</ul>
</li>
<li>给mytask3.sh一个可以执行权限<ul>
<li>chmod 744 mytask3.sh</li>
</ul>
</li>
<li>crontab -e<ul>
<li>0 2 * * * /home/mytask1.sh</li>
</ul>
</li>
</ul>
<h5 id="crond相关指令"><a href="#crond相关指令" class="headerlink" title="crond相关指令"></a>crond相关指令</h5><p>1、crontab -r:终止任务调度</p>
<p>2、crontab -l:列出当前有哪些任务调度</p>
<p>3、service crond restart [重启任务调度]</p>
<h4 id="Linux磁盘分区、挂载"><a href="#Linux磁盘分区、挂载" class="headerlink" title="Linux磁盘分区、挂载"></a>Linux磁盘分区、挂载</h4><h5 id="分区的方式"><a href="#分区的方式" class="headerlink" title="分区的方式"></a>分区的方式</h5><p>1、mbr分区</p>
<ul>
<li>最多支持四个主分区</li>
<li>系统只能安装在主分区</li>
<li>扩展分区要占一个主分区</li>
<li>MBR最大只支持2TB，但拥有最好的兼容性</li>
</ul>
<p>2、gtp分区</p>
<ul>
<li>支持无限多个主分区（但操作系统可能限制，比如windows下最多128个分区）</li>
<li>最大支持18EB的大容量（EB=1024PB,PB=1024TB）</li>
<li>windows7 64位以后支持gtp</li>
</ul>
<h5 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h5><p>原理介绍</p>
<p>1、Linux来说无论有几个分区，分给哪一目录使用，它归根到底就只有一个根目录，一个独立且唯一个文件结构，Linux中每个分区都是用来组成整个文件系统的一部分。</p>
<p>2、Linux采用一种叫‘载入’的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来，这时要载入的一个分区将使它的储存空间在一个目录下获得。</p>
<p><strong>查看系统分区和挂载指令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br><span class="line">lsblk -f</span><br></pre></td></tr></table></figure>

<h5 id="给Linux添加一块新的硬盘"><a href="#给Linux添加一块新的硬盘" class="headerlink" title="给Linux添加一块新的硬盘"></a>给Linux添加一块新的硬盘</h5><p>1、虚拟机添加硬盘</p>
<ul>
<li>虚拟机–设置==硬盘–添加–一路默认</li>
</ul>
<p>2、分区   fdisk /dev/sdb</p>
<p>3、格式化  mkfs -t ext4 /dev/sdb1</p>
<p>4、挂载 </p>
<ul>
<li>mkdir /home/newdisk</li>
<li>mount /dev/sdb1 /home/newdisk</li>
</ul>
<p>5、设置自动挂载</p>
<ul>
<li>vim /etc/fstab</li>
<li>/dev/sdb1      /home/newdisk      ext4    defaults        0 0</li>
<li>/dev/sdb1   /home/newdisk</li>
<li>mount -a</li>
</ul>
<h5 id="如何卸载硬盘"><a href="#如何卸载硬盘" class="headerlink" title="如何卸载硬盘"></a>如何卸载硬盘</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">断开挂载</span><br><span class="line">umount &#x2F;dev&#x2F;sdb1  或者</span><br><span class="line">umount &#x2F;newdisk</span><br></pre></td></tr></table></figure>

<h4 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h4><h5 id="查询系统整体磁盘使用情况"><a href="#查询系统整体磁盘使用情况" class="headerlink" title="查询系统整体磁盘使用情况"></a>查询系统整体磁盘使用情况</h5><p>基本语法</p>
<p>df -h</p>
<p><strong>应用实例</strong></p>
<p>查询系统整体磁盘使用情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -lh</span><br></pre></td></tr></table></figure>

<h5 id="查询指定目录的磁盘占用情况"><a href="#查询指定目录的磁盘占用情况" class="headerlink" title="查询指定目录的磁盘占用情况"></a>查询指定目录的磁盘占用情况</h5><p>基本语法</p>
<p>du -h /目录</p>
<p>查询指定目录的磁盘占用情况，默认为当前目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-s    指定目录占用大小汇总</span><br><span class="line">-h    带计量单位</span><br><span class="line">-a    含文件</span><br><span class="line">--max-depth&#x3D;1  子目录深度</span><br><span class="line">-c    列出明细的同时，增加汇总值</span><br></pre></td></tr></table></figure>

<p><strong>应用实例</strong></p>
<p>查询/opt目录的磁盘占用情况，深度为1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -ach --max-depth&#x3D;1 &#x2F;opt</span><br></pre></td></tr></table></figure>

<h5 id="磁盘情况-工作使用指令"><a href="#磁盘情况-工作使用指令" class="headerlink" title="磁盘情况-工作使用指令"></a>磁盘情况-工作使用指令</h5><p>1、统计/home文件夹下文件的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &#x2F;home | grep &quot;^-&quot; | wc -l</span><br></pre></td></tr></table></figure>

<p>2、统计/home文件夹下目录的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &#x2F;home | grep &quot;^d&quot; | wc -l</span><br></pre></td></tr></table></figure>

<p>3、统计/home文件夹下文件的个数，包括子文件夹里的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lR &#x2F;home | grep &quot;^-&quot; | wc -l</span><br></pre></td></tr></table></figure>

<p>4、统计文件夹下目录的个数，包括子文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lR &#x2F;home | grep &quot;^d&quot; | wc -l</span><br></pre></td></tr></table></figure>

<p>5、以树状显示目录结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tree</span><br><span class="line">如果没有</span><br><span class="line">yum install tree</span><br></pre></td></tr></table></figure>

<h4 id="Linux网络环境配置-我的是centons8不一样"><a href="#Linux网络环境配置-我的是centons8不一样" class="headerlink" title="Linux网络环境配置(我的是centons8不一样)"></a>Linux网络环境配置(我的是centons8不一样)</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ay-a/p/11828607.html">https://www.cnblogs.com/ay-a/p/11828607.html</a></p>
<h5 id="第一种方式（自动获取）"><a href="#第一种方式（自动获取）" class="headerlink" title="第一种方式（自动获取）"></a>第一种方式（自动获取）</h5><p>说明：登录后，通过界面的来设置自动获取IP</p>
<p>特点：Linux启动后会自动获取IP，缺点是每次自动获取的IP地址可能不一样。</p>
<h5 id="第二种方法：指定固定的IP"><a href="#第二种方法：指定固定的IP" class="headerlink" title="第二种方法：指定固定的IP"></a>第二种方法：指定固定的IP</h5><p>说明：直接修改配置文件来指定IP，并可以连接到外网（推荐），编辑vi /etc/sysconfig/network-scripts/ifcfg-eth0</p>
<p>要求：将IP地址配置的静态的，IP地址为192.168.184.130</p>
<p>重启网络service network restart</p>
<h6 id="修改主机名称"><a href="#修改主机名称" class="headerlink" title="修改主机名称"></a>修改主机名称</h6><p>查看当前主机名</p>
<p>hostname</p>
<h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p>基本介绍</p>
<p>1、在Linux中，每个执行的程序（代码）都成为一个进程。每一个进程都分配一个ID号</p>
<p>2、每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器</p>
<p>3、每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到进程，通常使用后台方式执行。</p>
<p>4、一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才结束。</p>
<h5 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h5><p>基本介绍</p>
<p>ps命令是用来查看目前系统中。有哪些正在执行以及它们执行的状况。可以不加任何参数。</p>
<p>ps显示的信息选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PID     进程识别号</span><br><span class="line">TTY     终端机号</span><br><span class="line">TIME    此进程所消CPU时间</span><br><span class="line">CMD     正在执行的命令或进程号</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -a:显示当前终端的所有进程信息</span><br><span class="line">PS -U:以用户的格式显示进程信息</span><br><span class="line">ps -x：显示后台进程运行的参数。</span><br></pre></td></tr></table></figure>

<p>筛选进程指令：ps -aux | grep xxx</p>
<h5 id="显示系统执行的进程-1"><a href="#显示系统执行的进程-1" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h5><p>ps -ef  是以全格式显示当前所有的进程</p>
<p>ps -ef | more</p>
<p>-e  显示所有进程。 -f   全格式</p>
<h4 id="终止进程kill和killall"><a href="#终止进程kill和killall" class="headerlink" title="终止进程kill和killall"></a>终止进程kill和killall</h4><p>介绍：</p>
<p>若是某个进程执行一半需要停止时，或是已消耗了很大系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务。</p>
<p>基本语法</p>
<p>kill [选项]  进程号   （功能描述：通过进程号杀死进程）</p>
<p>killall 进程名称   （功能描述：通过进程名杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）</p>
<p>常用选项</p>
<p>-9:表示强迫进程立即停止</p>
<h5 id="查看进程树pstree"><a href="#查看进程树pstree" class="headerlink" title="查看进程树pstree"></a>查看进程树pstree</h5><p>基本语法：</p>
<p>pstree [选项]  ，可以更加直观得来看进程信息</p>
<p>常用选项</p>
<p>-p:显示进程得PID</p>
<p>-u：显示进程得所属用户</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/26/Linux(%E4%B8%80)/" data-id="ckfmol2pt00196wvwhbphcyex" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Git" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/25/Git/" class="article-date">
  <time datetime="2020-09-25T11:26:26.667Z" itemprop="datePublished">2020-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/25/Git/">Git</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>1、什么是git？</p>
<p>Git是一个分布式的版本控制软件</p>
<p>2、为什么要做版本控制？</p>
<p>要保留之前所有的版本，以便回滚和修改。</p>
<h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>一直下一步。</p>
<p><strong>想要让git对一个目录进行版本控制需要以下步骤</strong></p>
<p>1、进入要管理的目录</p>
<p>2、执行初始化命令</p>
<ul>
<li>git init   初始化，即：让git帮助我们管理当前文件夹</li>
</ul>
<p>3、git status   检测当前目录下文件的状态</p>
<p>4、三种状态的变化</p>
<ul>
<li>红色：新增的文件或修改了老文件   -》git add 文件名  或  git add .</li>
<li>第一次用要配置个人信息：用户名和邮箱【一次】<ul>
<li>git config –global user.email “<a href="mailto:&#x79;&#x6f;&#x75;&#x40;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;">&#x79;&#x6f;&#x75;&#x40;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;</a>“</li>
<li>git config –global user.name “Your Name”</li>
</ul>
</li>
<li>绿色：git已经管理起来   -》 git commit -m ‘描述信息’</li>
<li>生成版本</li>
</ul>
<p>5、查看版本记录</p>
<ul>
<li>git log</li>
</ul>
<h4 id="回滚至之前的版本"><a href="#回滚至之前的版本" class="headerlink" title="回滚至之前的版本"></a>回滚至之前的版本</h4><p>git log   查看版本号</p>
<p>git reset –hard 版本号</p>
<h4 id="回滚至之后的版本"><a href="#回滚至之后的版本" class="headerlink" title="回滚至之后的版本"></a>回滚至之后的版本</h4><p>git reflog</p>
<p>git reset –hard 版本号</p>
<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>分支可以给使用者提供多个环境，意味着你可以把你的工作从开发线上分离开来，以免影响开发主线。</p>
<ul>
<li><p>查看分支    git branch</p>
</li>
<li><p>创建分支    git branch   分支名称</p>
</li>
<li><p>切换分支    git  checkout  分支名称</p>
</li>
<li><p>分支合并（可能产生冲突） </p>
<ul>
<li>git merge 要合并的分支</li>
<li>注意：切换分支在合并</li>
</ul>
</li>
<li><p>删除分支  git branch -d 分支名称</p>
</li>
</ul>
<h4 id="推送和下载"><a href="#推送和下载" class="headerlink" title="推送和下载"></a>推送和下载</h4><p>推送</p>
<p>1、给远程仓库起别名</p>
<ul>
<li>git remote add origin 远程仓库地址</li>
</ul>
<p>2、向远程推送代码</p>
<ul>
<li>git push -u origin 分支</li>
</ul>
<p>克隆</p>
<p>1、克隆远程仓库代码【第一次克隆远程仓库的代码】</p>
<ul>
<li>git clone 远程仓库地址（内部已实现git remote add origin 远程仓库地址</li>
</ul>
<p>2、使用cd xxx 进入到文件夹里面写命令</p>
<p>3、切换分支</p>
<ul>
<li>git checkout 分支</li>
</ul>
<p><strong>在公司进行开发</strong></p>
<p>1、切换到dev分支进行开发</p>
<p>​        git checkout dev</p>
<p>2、把master分支合并到dev【仅一次】</p>
<p>​        git merge master</p>
<p>3、修改代码</p>
<p>4、提交代码</p>
<p>​        git add .</p>
<p>​        git commit -m ‘xxx’</p>
<p>​        git push origin dev</p>
<p><strong>回到家中继续写代码</strong></p>
<p>1、切换到dev分支进行开发</p>
<p>​        git checkout dev</p>
<p>2、拉代码</p>
<p>​        git pull origin dev</p>
<p>3、继续开发</p>
<p>4、提交代码</p>
<p>​        git add .</p>
<p>​        git commit -m ‘xxx’</p>
<p>​        git push origin dev</p>
<p><strong>回到公司继续写代码</strong></p>
<p>1、切换到dev分支进行开发</p>
<p>​        git checkout dev</p>
<p>2、拉代码</p>
<p>​        git pull origin dev</p>
<p>3、继续开发</p>
<p>4、提交代码</p>
<p>​        git add .</p>
<p>​        git commit -m ‘xxx’</p>
<p>​        git push origin dev</p>
<p><strong>开发完毕，要上线</strong></p>
<p>1、将dev分支合并到master，进行上线</p>
<p>​        git checkout master</p>
<p>​        git merge dev</p>
<p>​        git push origin master</p>
<p>2、把dev分支也推送到远程</p>
<p>​        git checkout dev</p>
<p>​        git merge master</p>
<p>​        git push origin dev</p>
<p><strong>在公司时忘记提交代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、拉代码</span><br><span class="line">	git pull origin dev</span><br><span class="line">2、继续开发</span><br><span class="line">3、提交代码</span><br><span class="line">	git add .</span><br><span class="line">	git commit -m &#39;xx&#39;</span><br><span class="line">注：忘记push了</span><br></pre></td></tr></table></figure>

<p><strong>回家继续写代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、拉代码，发现在公司写的代码忘记提交...</span><br><span class="line">	git pull origin dev</span><br><span class="line">2、继续开发其它功能</span><br><span class="line">3、把dev分支也推送到远程</span><br><span class="line">	git add .</span><br><span class="line">	git commit -m &#39;xx&#39;</span><br><span class="line">	git push origin dev</span><br></pre></td></tr></table></figure>

<p><strong>到公司继续写代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、拉代码，把晚上在家写的代码拉到本地（有合并、可能冲突）</span><br><span class="line">	git pull origin dev</span><br><span class="line">2、如果有冲突，手动解决冲突</span><br><span class="line">3、继续开发其它功能</span><br><span class="line">4、把dev分支也推到远程</span><br><span class="line">	git add . </span><br><span class="line">	git commot -m &#39;xxx&#39;</span><br><span class="line">	git push origin dev</span><br></pre></td></tr></table></figure>

<p><strong>其它</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull origin dev</span><br><span class="line">等价于</span><br><span class="line">git fetch origin dev</span><br><span class="line">git merge origin&#x2F;dev</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/0iV42T"><img src="https://s1.ax1x.com/2020/09/26/0iV42T.png" alt="0iV42T.png"></a></p>
<h4 id="rebase的作用"><a href="#rebase的作用" class="headerlink" title="rebase的作用"></a>rebase的作用</h4><p>rebase可以保持提交记录简洁，不分叉</p>
<p>1、</p>
<p>git rebase -i 加版本号       整合版本号之后的记录</p>
<p>git rebase -i HEAD~3      表示整合最近的三条记录  【注意提交远程仓库的不要合并，记录会发生冲突】</p>
<p>2、将dev分支整合到master主线上来</p>
<p>​        dev rebase master</p>
<p>​        git checkout master</p>
<p>​        git merge dev</p>
<p>​    现在就变成一条线了</p>
<p>3、美女约饭案例中到公司pull代码会产生分叉，可以这样做</p>
<p>​    git fetch origin dev</p>
<p>​    git rebase origin/dev</p>
<p><strong>注意</strong></p>
<p>在git checkout dev </p>
<p>​    git rebase master</p>
<p>这一步可能会产生冲突，我们解决冲突后</p>
<p>​    git add .</p>
<p>​    git rebase –continue</p>
<p><strong>保持代码提交整洁（变基）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase 分支</span><br></pre></td></tr></table></figure>

<p><strong>记录图形展示</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --pretty&#x3D;format:&quot;%h %s&quot;</span><br></pre></td></tr></table></figure>

<h4 id="快速解决冲突"><a href="#快速解决冲突" class="headerlink" title="快速解决冲突"></a>快速解决冲突</h4><p>1、安装beyond compare</p>
<p>2、在git中配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --local merge.tool bc3</span><br><span class="line">git config --local mergetool.path &#39;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;bcomp&#39;</span><br><span class="line">git config --local mergetool.keepBackup false</span><br></pre></td></tr></table></figure>

<p>3、应用beyond compare解决冲突</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mergetool </span><br></pre></td></tr></table></figure>

<h4 id="多人协同开发工作流"><a href="#多人协同开发工作流" class="headerlink" title="多人协同开发工作流"></a>多人协同开发工作流</h4><h5 id="一、创建项目-amp-邀请成员"><a href="#一、创建项目-amp-邀请成员" class="headerlink" title="一、创建项目&amp;邀请成员"></a>一、创建项目&amp;邀请成员</h5><p>协同开发时，需要所有的成员都可以对同一个项目进行操作，需要邀请成员并赋予权限，否则无法开发。</p>
<p>1、合作者，将用户添加到仓库合作者之后，该用户就可以向当前仓库提交代码</p>
<p>2、组织，将成员邀请进入组织，组织可以创建多个仓库，组织成员可以向组织下仓库提交代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0 -m &#39;版本介绍&#39; 创建本地创建Tag信息</span><br><span class="line">git tag -d v1.0 删除Tag</span><br><span class="line">git push origin --tags  将本地tag信息推送到远程仓库</span><br><span class="line">git pull origin --tags  更新本地tag版本信息</span><br><span class="line">git checkout v.10  切换tag</span><br><span class="line">git clone -b v0.1 地址   指定tag下载代码</span><br></pre></td></tr></table></figure>

<h4 id="小弟开发"><a href="#小弟开发" class="headerlink" title="小弟开发"></a>小弟开发</h4><ul>
<li>小弟注册Github 或Github </li>
<li>邀请小弟进入组织（默认对组织中的项目具有读权限）</li>
<li>小弟在自己电脑上下载代码并开发</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone 地址</span><br><span class="line">cd 仓库名</span><br><span class="line">git checkout dev</span><br><span class="line">git checkout -b dzz</span><br><span class="line">写代码....</span><br><span class="line">git add . </span><br><span class="line">git commit -m &#39;描述&#39;</span><br><span class="line">git push origin ddz</span><br></pre></td></tr></table></figure>

<h4 id="提测上线（预发布）"><a href="#提测上线（预发布）" class="headerlink" title="提测上线（预发布）"></a>提测上线（预发布）</h4><p>由专门团队或团队leader执行以下步骤</p>
<p>1、基于dev分支创建release分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git checkout -b release</span><br></pre></td></tr></table></figure>

<p>2、测试等</p>
<p>3、合并master</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用pull request</span><br><span class="line">或</span><br><span class="line">本地将release合并到master分支</span><br></pre></td></tr></table></figure>

<p>4、在master分支打tag</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v2 -m &#39;第二版 斗地主功能&#39;</span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>

<p>5、运维人员就可以去下载代码做上线了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v2 地址</span><br></pre></td></tr></table></figure>

<h4 id="给开源软件贡献代码"><a href="#给开源软件贡献代码" class="headerlink" title="给开源软件贡献代码"></a>给开源软件贡献代码</h4><p>1、fork源代码，将别人源代码拷贝到我自己的远程仓库</p>
<p>2、在自己仓库进行修改代码</p>
<p>3、给源代码的作者提交，修改bug的申请（pull request)</p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ul>
<li><p>项目配置文件：项目/.git/config</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --local user.name &#39;名字&#39;</span><br><span class="line">git config --local user.emeil &#39;邮箱&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局配置文件：~/.gitconfig</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &#39;名字&#39;</span><br><span class="line">git config --global user.email &#39;邮箱&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统配置文件：/etc/.gitconfig</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --system user.name &#39;&#39;</span><br><span class="line">git config --system user.email &#39;&#39;</span><br><span class="line">注意：需要有root权限</span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 地址，默认添加在本地配置文件中（--local)</span><br></pre></td></tr></table></figure>

<h4 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h4><p>1、url中体现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原来的地址：https:&#x2F;&#x2F;github.com&#x2F;WuPeiqi&#x2F;dbhot.git</span><br><span class="line">修改的地址https:&#x2F;&#x2F;用户名：密码github.com&#x2F;WuPeiqi&#x2F;dbhot.git</span><br><span class="line">git remote add origin 加上面的地址</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>2、SSH实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、生成公钥和私钥（默认放在~&#x2F;.ssh目录下，id_rsa.pub公钥、id_rsa私钥）</span><br><span class="line">	ssh-keygen</span><br><span class="line">2、拷贝公钥的内容，并设置到github中。</span><br><span class="line">3、在git本地中配置ssh地址</span><br><span class="line">	git remote add origin (usessh地址)</span><br></pre></td></tr></table></figure>

<p>3、git自动管理凭证</p>
<h4 id="git忽略文件"><a href="#git忽略文件" class="headerlink" title="git忽略文件"></a>git忽略文件</h4><p>让Git不在管理当前目录子下的某些文件</p>
<p>编辑   vim gitignore</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*.h</span><br><span class="line">!a.h</span><br><span class="line">files&#x2F;</span><br><span class="line">*.py[c|a|d]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line"></span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line"></span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line"></span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line"></span><br><span class="line">.mtj.tmp&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line"></span><br><span class="line">*.jar</span><br><span class="line"></span><br><span class="line">*.war</span><br><span class="line"></span><br><span class="line">*.nar</span><br><span class="line"></span><br><span class="line">*.ear</span><br><span class="line"></span><br><span class="line">*.zip</span><br><span class="line"></span><br><span class="line">*.tar.gz</span><br><span class="line"></span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see http:&#x2F;&#x2F;www.java.com&#x2F;en&#x2F;download&#x2F;help&#x2F;error_hotspot.xml</span><br><span class="line"></span><br><span class="line">hs_err_pid*</span><br></pre></td></tr></table></figure>



<p>gitignore</p>
<h4 id="github任务管理相关"><a href="#github任务管理相关" class="headerlink" title="github任务管理相关"></a>github任务管理相关</h4><ul>
<li>issues，文档以及任务管理。</li>
<li>wiki，项目文档</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/25/Git/" data-id="ckfmol2oh00016wvweqx6cl0b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-注解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/25/%E6%B3%A8%E8%A7%A3/" class="article-date">
  <time datetime="2020-09-25T02:11:41.482Z" itemprop="datePublished">2020-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/25/%E6%B3%A8%E8%A7%A3/">注解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>概念：说明程序的，给计算机看的。</p>
<p>概念描述：jdk5之后的新特性，说明程序的，使用注解：@注解名称。</p>
<p>作用分类：</p>
<p>1、编写文档：通过代码里标识的注解生成文档【生成文档doc文档】</p>
<p>2、代码分析：通过代码里标识的注解对代码进行分析【使用反射】</p>
<p>3、编译检车：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</p>
<h4 id="jdk中预定义的一些注解"><a href="#jdk中预定义的一些注解" class="headerlink" title="jdk中预定义的一些注解"></a>jdk中预定义的一些注解</h4><ul>
<li>@Override:检测该注解标注的方法是否是继承自父类（接口）的</li>
<li>@Depercated:该注解标注的内容，表示已过时。</li>
<li>@SupperssWarnings:压制警告<ul>
<li>一般传递参数all  @SuppressWarnings(“all”)</li>
</ul>
</li>
</ul>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><ul>
<li><p>格式：</p>
<p>元注解</p>
<p>public @interface 注解名称{</p>
<p>​    属性列表</p>
<p>}</p>
</li>
<li><p>本质：注解本质就是一个接口，该接口默认继承Annotation接口</p>
<ul>
<li>public interface MyAnno extends java.lang.annotation.Annotation{}</li>
</ul>
</li>
<li><p>javap xxxx.class反编译</p>
</li>
<li><p>属性：接口中的抽象方法</p>
<ul>
<li>要求：<ul>
<li>属性的返回值类型<ul>
<li>基本数据类型</li>
<li>String</li>
<li>枚举</li>
<li>注解</li>
<li>以上类型的数组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>要求：<ul>
<li>定义了属性，在使用时需要给属性赋值<ul>
<li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li>
<li>如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</li>
<li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}省略。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>元注解：用于描述注解的注解</p>
<p>1、@Target:描述注解能够作用的位置</p>
<ul>
<li>ElementType取值：<ul>
<li>TYPE:可以作用于类上</li>
<li>METHOD:可以作用于方法上</li>
<li>FIELD:可以作用于成员变量上</li>
</ul>
</li>
</ul>
<p>2、@Retention:描述注解被保留的阶段</p>
<ul>
<li>Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，被JVM读取到</li>
</ul>
<p>3、@Documented:描述注解是否被抽取到api文档中</p>
<p>4、@Inherited:描述注解是否被子类继承。</p>
<h4 id="在程序使用（解析）注解：获取注解中定义的属性值"><a href="#在程序使用（解析）注解：获取注解中定义的属性值" class="headerlink" title="在程序使用（解析）注解：获取注解中定义的属性值"></a>在程序使用（解析）注解：获取注解中定义的属性值</h4><p>1、获取注解定义的位置的对象  （Class,Method,Field)</p>
<p>2、获取指定的注解</p>
<ul>
<li>getAnnotation(Class)</li>
</ul>
<p>3、调用注解中的抽象方法获取配置的属性值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Pro &#123;</span><br><span class="line">    <span class="function">String <span class="title">className</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">methodName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="meta">@Pro(className = &quot;demo01.Student&quot;,methodName = &quot;show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Test&gt; cls1 = Test.class;</span><br><span class="line">        Pro pro = cls1.getAnnotation(Pro.class);</span><br><span class="line">        String className = pro.className();</span><br><span class="line">        String methodName = pro.methodName();</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(className);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        Object obj = cls.newInstance();</span><br><span class="line">        <span class="comment">//获取方法对象</span></span><br><span class="line">        Method method = cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习：写一个检测类中的方法是否有异常的“框架”，并记录到一个文件中"><a href="#练习：写一个检测类中的方法是否有异常的“框架”，并记录到一个文件中" class="headerlink" title="练习：写一个检测类中的方法是否有异常的“框架”，并记录到一个文件中"></a>练习：写一个检测类中的方法是否有异常的“框架”，并记录到一个文件中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1+1=&quot;</span>+ (<span class="number">1</span>+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chu</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1/0=&quot;</span> + (<span class="number">1</span>/<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Math math = <span class="keyword">new</span> Math();</span><br><span class="line">        Class&lt;? extends Math&gt; aClass = math.getClass();</span><br><span class="line">        Method[] methods = aClass.getMethods();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;bug.txt&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(Check.class))&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    method.invoke(math);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    bw.write(method.getName()+<span class="string">&quot;方法出现了异常&quot;</span>);</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">&quot;方法出现异常的名称是&quot;</span>+e.getCause().getClass().getSimpleName());</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">&quot;方法出现的异常原因是&quot;</span> + e.getCause().getMessage());</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bw.write(<span class="string">&quot;共出现&quot;</span>+count+<span class="string">&quot;次异常&quot;</span>);</span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">chu方法出现了异常</span><br><span class="line">方法出现异常的名称是ArithmeticException</span><br><span class="line">方法出现的异常原因是/ by zero</span><br><span class="line">------------------------</span><br><span class="line">共出现<span class="number">1</span>次异常</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1、以后大多数时候，我们会使用注解，而不是自定义注解</p>
<p>2、注解给谁用？</p>
<ul>
<li>编译器</li>
<li>给解析程序用</li>
</ul>
<p>3、注解不是程序的一部分，可以理解为注解就是一个标签。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/25/%E6%B3%A8%E8%A7%A3/" data-id="ckfmol2oz000o6wvw8z0l7ye9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-反射" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/24/%E5%8F%8D%E5%B0%84/" class="article-date">
  <time datetime="2020-09-24T12:45:27.046Z" itemprop="datePublished">2020-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/24/%E5%8F%8D%E5%B0%84/">反射</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射：框架设计的灵魂</p>
<ul>
<li>框架：半成品软件。可以在框架的基础上进行软件开发，简化代码。</li>
<li>反射：将类的各个组成部分封装为其它对象，这就是反射机制。<ul>
<li>好处：可以在程序运行过程中，操作这些对象。</li>
<li>好处：可以解耦，提高程序的可扩展性。</li>
</ul>
</li>
</ul>
<h4 id="获取Class对象的方式"><a href="#获取Class对象的方式" class="headerlink" title="获取Class对象的方式"></a>获取Class对象的方式</h4><p>1、Class.forName(“全类名”):将字节码文件加载进内存，返回Class对象。</p>
<ul>
<li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类</li>
</ul>
<p>2、类名.class:通过类名的属性class获取。</p>
<ul>
<li>多用于参数的传递</li>
</ul>
<p>3、对象.getClass():getClass方法在Object类中定义着。</p>
<ul>
<li>多用于对象的获取字节码的方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//获取Class文件的三种方式</span></span><br><span class="line">        Class cls1 = Class.forName(<span class="string">&quot;reflect.Person&quot;</span>);</span><br><span class="line">        System.out.println(cls1);<span class="comment">//class reflect.Person</span></span><br><span class="line">        Class cls2 = Person.class;</span><br><span class="line">        System.out.println(cls2);<span class="comment">//class reflect.Person</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Class cls3 = p.getClass();</span><br><span class="line">        System.out.println(cls3);<span class="comment">//class reflect.Person</span></span><br><span class="line">        System.out.println(cls1 == cls2);<span class="comment">//true</span></span><br><span class="line">        System.out.println(cls1 == cls3);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong></p>
<p>同一个字节码文件（*.class)在程序运行过程中，只会被加载一次，不论通过哪一种方式获取Class对象都是同一个。</p>
<h4 id="Class对象的功能"><a href="#Class对象的功能" class="headerlink" title="Class对象的功能"></a>Class对象的功能</h4><p>一、获取功能</p>
<p>1、获取成员方法们</p>
<ul>
<li><p>在反射机制中，把类中的成员变量使用类Field表示。可通过Class类中提供的方法获取成员变量：</p>
<p>返回一个成员变量</p>
<ul>
<li>public Field getField(String name) 获取指定的public修饰的变量</li>
<li>public Field getDeclaredField(String name) 获取指定的任意变量(包含私有)</li>
</ul>
<p>返回多个成员变量</p>
<ul>
<li>public Field[] getFields() 获取所有public修饰的变量</li>
<li>public Field[] getDeclaredFields() 获取所有的变量 (包含私有)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        返回一个成员变量</span></span><br><span class="line"><span class="comment">            * public Field getField(String name) 获取指定的public修饰的变量</span></span><br><span class="line"><span class="comment">            * public Field getDeclaredField(String name) 获取指定的任意变量(包含私有)</span></span><br><span class="line"><span class="comment">         返回多个成员变量</span></span><br><span class="line"><span class="comment">            * public Field[] getFields() 获取所有public修饰的变量</span></span><br><span class="line"><span class="comment">            * public Field[] getDeclaredFields() 获取所有的变量 (包含私有)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class cls = Person.class;</span><br><span class="line">        Field[] fields = cls.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);<span class="comment">//public java.lang.String reflect.Person.a</span></span><br><span class="line">        &#125;</span><br><span class="line">        Field a = cls.getField(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Object o = a.get(p);</span><br><span class="line">        System.out.println(o);<span class="comment">//null</span></span><br><span class="line">        a.set(p,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(p);<span class="comment">//Person&#123;name=&#x27;null&#x27;, age=0, a=&#x27;张三&#x27;, b=&#x27;null&#x27;, c=&#x27;null&#x27;, d=&#x27;null&#x27;&#125;</span></span><br><span class="line">        <span class="comment">//public Field[] getDeclaredFields() 获取所有的变量 (包含私有)</span></span><br><span class="line">        Field[] declaredFields = cls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        Field name = cls.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object o1 = name.get(p);</span><br><span class="line">        System.out.println(o1);<span class="comment">//null</span></span><br><span class="line">        name.set(p,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        System.out.println(p);<span class="comment">//Person&#123;name=&#x27;李四&#x27;, age=0, a=&#x27;张三&#x27;, b=&#x27;null&#x27;, c=&#x27;null&#x27;, d=&#x27;null&#x27;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、获取构造方法们</p>
<p>返回一个构造方法：</p>
<ul>
<li>public Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes) 获取public修饰, 指定参数类型所对应的构造方法</li>
<li>public Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 获取指定参数类型所对应的构造方法(包含私有的)<br>返回多个构造方法</li>
<li>public Constructor&lt;?&gt;[] getConstructors() 获取所有的public 修饰的构造方法</li>
<li>public Constructor&lt;?&gt;[] getDeclaredConstructors() 获取所有的构造方法(包含私有的)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        返回一个构造方法：</span></span><br><span class="line"><span class="comment">            * public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 获取public修饰, 指定参数类型所对应的构造方法</span></span><br><span class="line"><span class="comment">            * public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) 获取指定参数类型所对应的构造方法(包含私有的)</span></span><br><span class="line"><span class="comment">        返回多个构造方法</span></span><br><span class="line"><span class="comment">            * public Constructor&lt;?&gt;[] getConstructors() 获取所有的public 修饰的构造方法</span></span><br><span class="line"><span class="comment">            * public Constructor&lt;?&gt;[] getDeclaredConstructors() 获取所有的构造方法(包含私有的)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class cls = Person.class;</span><br><span class="line">        Constructor constructor = cls.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(constructor);<span class="comment">//public reflect.Person(java.lang.String,int)</span></span><br><span class="line">        Object person = constructor.newInstance(<span class="string">&quot;张三&quot;</span>, <span class="number">33</span>);</span><br><span class="line">        System.out.println(person);<span class="comment">//Person&#123;name=&#x27;张三&#x27;, age=33, a=&#x27;null&#x27;, b=&#x27;null&#x27;, c=&#x27;null&#x27;, d=&#x27;null&#x27;&#125;</span></span><br><span class="line">        Object person1 = cls.newInstance();</span><br><span class="line">        System.out.println(person1);<span class="comment">//Person&#123;name=&#x27;null&#x27;, age=0, a=&#x27;null&#x27;, b=&#x27;null&#x27;, c=&#x27;null&#x27;, d=&#x27;null&#x27;&#125;</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力反射</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、获取成员方法们</p>
<p>在反射机制中，把类中的成员方法使用类Method表示。可通过Class类中提供的方法获取成员方法：</p>
<p>返回获取一个方法：</p>
<ul>
<li>public Method getMethod(String name, Class&lt;?&gt;… parameterTypes)//获取public 修饰的方法</li>
<li>public Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) // 获取任意的方法，包含</li>
</ul>
<p>私有的</p>
<p>参数1: name 要查找的方法名称； 参数2： parameterTypes 该方法的参数类型</p>
<p>返回获取多个方法：</p>
<ul>
<li>public Method[] getMethods() //获取本类与父类中所有public 修饰的方法</li>
<li>public Method[] getDeclaredMethods() //获取本类中所有的方法(包含私有的)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        返回获取一个方法：</span></span><br><span class="line"><span class="comment">        * public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)//获取public 修饰的方法</span></span><br><span class="line"><span class="comment">        * public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) // 获取任意的方法，包含</span></span><br><span class="line"><span class="comment">        私有的</span></span><br><span class="line"><span class="comment">        参数1: name 要查找的方法名称； 参数2： parameterTypes 该方法的参数类型</span></span><br><span class="line"><span class="comment">        返回获取多个方法：</span></span><br><span class="line"><span class="comment">        * public Method[] getMethods() //获取本类与父类中所有public 修饰的方法</span></span><br><span class="line"><span class="comment">        * public Method[] getDeclaredMethods() //获取本类中所有的方法(包含私有的)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class personClass = Person.class;</span><br><span class="line">        Method eat = personClass.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">        Object p = personClass.newInstance();</span><br><span class="line">        eat.invoke(p);<span class="comment">//eat.....</span></span><br><span class="line">        Method eat1 = personClass.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>, String.class);</span><br><span class="line">        eat1.invoke(p,<span class="string">&quot;饭&quot;</span>);<span class="comment">//eat...饭</span></span><br><span class="line">        Method[] declaredMethods = personClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : declaredMethods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            String name = method.getName();</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        String name = personClass.getName();</span><br><span class="line">        System.out.println(name);<span class="comment">//reflect.Person</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、获取类名</p>
<ul>
<li>String getName()</li>
</ul>
<h4 id="Field-成员变量"><a href="#Field-成员变量" class="headerlink" title="Field:成员变量"></a>Field:成员变量</h4><p>操作：</p>
<p>1、设置值</p>
<ul>
<li>void set(Object obj,Object value)</li>
</ul>
<p>2、获取值</p>
<ul>
<li>get(Object obj)</li>
</ul>
<p>3、忽略访问权限修饰符的安全检查</p>
<ul>
<li>setAccessible(true):暴力反射</li>
</ul>
<h4 id="Constructor-构造方法"><a href="#Constructor-构造方法" class="headerlink" title="Constructor:构造方法"></a>Constructor:构造方法</h4><p>创建对象：</p>
<ul>
<li>T newInstance(Object… initargs)</li>
<li>如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法。</li>
</ul>
<h4 id="Method-方法对象"><a href="#Method-方法对象" class="headerlink" title="Method:方法对象"></a>Method:方法对象</h4><ul>
<li>执行方法：Object invoke(Object obj,Object….args)</li>
<li>获取方法名称：String getName:获取方法名</li>
</ul>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>需求：写一个“框架”，不能改变该类的任何代码的前提下，可以帮助我们创建任一类的对象，并且执行其中任意方法。</p>
<p><strong>实现</strong></p>
<p>1、配置文件</p>
<p>2、反射</p>
<p><strong>步骤</strong></p>
<p>1、将需要创建的对象的全类名和需要执行的方法定义在配置文件中</p>
<p>2、在程序中加载读取的配置文件</p>
<p>3、使用反射技术来加载类文件进内存</p>
<p>4、创建对象</p>
<p>5、执行方法</p>
<p><strong>具体步骤</strong></p>
<p>1、加载配置文件</p>
<p>1.1、创建Properties对象</p>
<p>Properties pro =  new Properties();</p>
<p>1.2加载配置文件，转换为一个集合</p>
<p>1.2.1获取class目录下的配置文件</p>
<p>ClassLoader classLoader = Test.class.getClassLoader();</p>
<p>InputStream is = classLoader.getResourceAsStream(“pro.properties”);</p>
<p>pro.load(is);</p>
<p>2、获取配置文件中定义的数据</p>
<p>String className = pro.getProperty(“className”);</p>
<p>String methodName = pro.getProperty(“methodName”);</p>
<p>3、加载该类进内存</p>
<p>Class cls = Class.forName(classNaem);</p>
<p>4、创建对象</p>
<p>Object obj = cls.newInstance();</p>
<p>5、获取方法对象</p>
<p>Method method = cls.getMethod(methodName);</p>
<p>6、执行方法</p>
<p>method.invoke(obj);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建Properties对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        ClassLoader classLoader = Test.class.getClassLoader();</span><br><span class="line">        <span class="comment">//加载配置文件，转换为一个集合</span></span><br><span class="line">        <span class="comment">//获取class目录下的配置文件</span></span><br><span class="line">        InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;pro.properties&quot;</span>);</span><br><span class="line">        pro.load(is);</span><br><span class="line">        <span class="comment">//获取配置文件中的定义的数据</span></span><br><span class="line">        String className = pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        String methodName = pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="comment">//加载类进内存</span></span><br><span class="line">        Class cls = Class.forName(className);</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        Object obj = cls.newInstance();</span><br><span class="line">        <span class="comment">//获取方法对象</span></span><br><span class="line">        Method method = cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/24/%E5%8F%8D%E5%B0%84/" data-id="ckfmol2ov000g6wvwbj9sb0v3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Stream流、方法引用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/24/Stream%E6%B5%81%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/" class="article-date">
  <time datetime="2020-09-24T06:04:56.519Z" itemprop="datePublished">2020-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/24/Stream%E6%B5%81%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/">Stream流、方法引用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p>Stream流是JDK8之后出现的，关注的是做什么，而不是怎么做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;金毛狮王&quot;</span>);</span><br><span class="line">        list.stream().filter(name-&gt;name.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                .filter(name-&gt;name.length() == <span class="number">3</span>)</span><br><span class="line">                .forEach(name-&gt; System.out.print(name));张无忌张三丰</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Stream流思想概述"><a href="#Stream流思想概述" class="headerlink" title="Stream流思想概述"></a>Stream流思想概述</h4><p>整体来看，流式思想类似于工厂车间的“生产流水线”。</p>
<p>拼接流式模型：建立一个生产线，按照生产线，来生产商品。</p>
<p>Stream流是一个来时数据源的元素队列</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。Java中Stream并不会存储元素，而是按需计算。</li>
<li>数据源流的来源。可以是集合，数组等。</li>
</ul>
<p>和以前的Collection操作不同，Stream操作还有两个基础的特征：</p>
<ul>
<li>Pipelining:中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格（fluent style).这样做可以对操作进行优化，比如延迟执行（laziness)和（short-circuiting).</li>
<li>内部迭代：以前对集合遍历都是通过Iterator或者增强for的方式，显示的在集合外部进行迭代，这叫做外部迭代。Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li>
</ul>
<p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source)-&gt;数据转换-&gt;执行操作获取想要的结果，每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。</p>
<h4 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h4><p>java.util.stream<T> 是Java8新加入的最常用的流接口。（这并不是一个函数式接口）</p>
<p>获取一个流，有以下几种常用的方式：</p>
<ul>
<li>所有Collection集合都可以通过stream默认方法获取流；</li>
<li>Stream接口的静态方法of可以获取数组对应的流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream2 = set.stream();</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        Stream&lt;String&gt; stream3 = keySet.stream();</span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        Stream&lt;String&gt; stream4 = values.stream();</span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream5 = entries.stream();</span><br><span class="line">        <span class="comment">//将数组转换为Stream流</span></span><br><span class="line">        Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        Integer[] integers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; integers1 = Stream.of(integers);</span><br><span class="line">        String[] strings = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="string">&quot;ccc&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; strings1 = Stream.of(strings);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Stream流中常用的方法"><a href="#Stream流中常用的方法" class="headerlink" title="Stream流中常用的方法"></a>Stream流中常用的方法</h4><p>流模式的操作很丰富，这些方法可以分为两类：</p>
<ul>
<li>延迟方法：返回值类型任然是Stream接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。）</li>
<li>终结方法：返回值类型不再是Stream接口自身的类型方法，因此不在支持类似StringBuilder那样的链式调用。本小节中，终结方法包括count和forEach方法。</li>
</ul>
<h4 id="逐一处理：forEach"><a href="#逐一处理：forEach" class="headerlink" title="逐一处理：forEach"></a>逐一处理：forEach</h4><p>虽然方法名字叫forEach，但是与for循环中的“for -each”昵称不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法接受一个Consumer接口函数，会将每一个流元素交给该函数进行处理。</p>
<p>简单记：forEach方法，用来遍历流中的数据，是一个终结方法。</p>
<h4 id="复习Consumer接口"><a href="#复习Consumer接口" class="headerlink" title="复习Consumer接口"></a>复习Consumer接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.function.Consumer&lt;T&gt; 接口是一个消费型接口。</span><br><span class="line">Consumer接口中包含抽象方法void accept(T t).意为消费一个指定泛型的数据。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForEachTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strings = &#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(strings);</span><br><span class="line">        stream.forEach(name-&gt; System.out.print(name));<span class="comment">//张三李四王五</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过滤：filter"><a href="#过滤：filter" class="headerlink" title="过滤：filter"></a>过滤：filter</h4><p>可以通过filter方法将一个流转换成另一个子集流。方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该接口接受一个Predicate函数式接口参数作为筛选条件。</p>
<h4 id="复习Predicate接口"><a href="#复习Predicate接口" class="headerlink" title="复习Predicate接口"></a>复习Predicate接口</h4><p>java.util.stream.Predicate函数式接口，其中唯一的抽象方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean test(T t);</span><br></pre></td></tr></table></figure>

<p>该方法将会产生一个boolean 值结果，代表指定的条件是否满足。如果结果为true,那么stream流的filter方法将会留用元素；如果结果为false，那么filter方法将会舍弃元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strings = &#123;<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;张翠山&quot;</span>,<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;周芷若&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(strings);</span><br><span class="line">        <span class="comment">//只要姓张的</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = stream.filter(name -&gt; name.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">        stream1.forEach(name-&gt; System.out.print(name));<span class="comment">//张无忌张翠山</span></span><br><span class="line">        <span class="comment">//会抛异常，使用完流就关闭了。</span></span><br><span class="line">        <span class="comment">//stream.forEach(nama-&gt;sout(name));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Stream流特点"><a href="#Stream流特点" class="headerlink" title="Stream流特点"></a>Stream流特点</h4><p>Stream流属于管道流，只能被消费（使用）一次，第一个Stream流调用完毕方法，数据就会流转到下一个Stream流上，而这时第一个Stream流已经使用完毕，就会关闭了，所以第一个Stream流就不能在调用方法了。</p>
<h4 id="映射：map"><a href="#映射：map" class="headerlink" title="映射：map"></a>映射：map</h4><p>如果需要将流中的元素映射到另一个流中，可以使用map方法。方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p>
<h4 id="复习Function接口"><a href="#复习Function接口" class="headerlink" title="复习Function接口"></a>复习Function接口</h4><p>java.util.stream.Function函数式接口，其中唯一的抽象方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这可以将一种T类型转换称为R类型，而这种转换的动作，就称为“映射”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strings = &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(strings);</span><br><span class="line">        Stream&lt;Integer&gt; stream1 = stream.map(name-&gt;Integer.parseInt(name));</span><br><span class="line">        stream1.forEach(i-&gt; System.out.print(i));<span class="comment">//1234</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="统计个数：count"><a href="#统计个数：count" class="headerlink" title="统计个数：count"></a>统计个数：count</h4><p>正如旧集合Collection当中的size方法一样，</p>
<p>流提供count方法来数一数其中的元素个数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法返回一个long值代表元素个数（不在像旧集合那样是int值）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        list.add(<span class="number">7</span>);</span><br><span class="line">        list.add(<span class="number">8</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        <span class="keyword">long</span> count = stream.count();</span><br><span class="line">        System.out.println(count);<span class="comment">//8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h4><p>limit方法可以对流进行截取，只取用前n个，limit是一个延迟方法。只是对流中的元素进行截取，返回的是一个新的流，所以可以继续调用Stream流中的其它方法。方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Steam&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数是一个long类型，如果集合当前长度大于参数进行截取；否则不进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        list.add(<span class="number">7</span>);</span><br><span class="line">        list.add(<span class="number">8</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        Stream&lt;Integer&gt; stream1 = stream.limit(<span class="number">5</span>);</span><br><span class="line">        stream1.forEach(i-&gt; System.out.print(i));<span class="comment">//12345</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="跳过前几个：skip"><a href="#跳过前几个：skip" class="headerlink" title="跳过前几个：skip"></a>跳过前几个：skip</h4><p>如果希望跳过前几个元素，可以使用skip方法获取一个截取之后的新流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果流的当前长度大于n，则跳过前n个；否者将会得到一个长度为0的空流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        list.add(<span class="number">7</span>);</span><br><span class="line">        list.add(<span class="number">8</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        Stream&lt;Integer&gt; stream1 = stream.skip(<span class="number">3</span>);</span><br><span class="line">        stream1.forEach(i-&gt; System.out.print(i));<span class="comment">//45678</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组合：concat"><a href="#组合：concat" class="headerlink" title="组合：concat"></a>组合：concat</h4><p>如果两个流，希望合并称为一个流，那么可以使用Stream接口的静态方法concat:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">concat</span><span class="params">(Stream&lt;? extends T&gt; a,Stream&lt;? extend T&gt; b)</span></span></span><br></pre></td></tr></table></figure>

<p>备注：这是一个静态方法，与java.lang.String当中的concat方法是不同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcatTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] str1 =&#123;<span class="string">&quot;张无忌&quot;</span>&#125;;</span><br><span class="line">        String[] str2 =&#123;<span class="string">&quot;张三丰&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Arrays.stream(str1);</span><br><span class="line">        Stream&lt;String&gt; stream1 = Arrays.stream(str2);</span><br><span class="line">        Stream&lt;String&gt; concat = Stream.concat(stream, stream1);</span><br><span class="line">        concat.forEach(name-&gt; System.out.print(name));<span class="comment">//张无忌张三丰</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><h4 id="方法引用符"><a href="#方法引用符" class="headerlink" title="方法引用符"></a>方法引用符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;金毛狮王&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        stream.forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双冒号：：为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的代替者。</p>
<p>例如上例中，System.out对象中有一个重载的println(String)方法恰好就是我们所需要的。那么对于printString方法的函数式接口参数，对比下面两种写法，完全等效。</p>
<ul>
<li>Lambda表达式写法：s-&gt;System.out.println(s);</li>
<li>方法引用写法：System.out::println</li>
</ul>
<p>第一种语义是指：拿到参数之后经Lambda之手，继而传递给System.out.println方法去处理。</p>
<p>第二种等效写法的语义是指：直接让System.out中的println方法来取代Lambda。两种写法的执行效果完全一样，而第二种方法引用的写法复用了已有方案，更加简洁。</p>
<p>注：Lambda中传递的参数一定是方法引用中的那个方法可以接受的类型，否则会抛出异常。</p>
<h4 id="方法引用的前提"><a href="#方法引用的前提" class="headerlink" title="方法引用的前提"></a>方法引用的前提</h4><p>使用前提是对象是已经存在的，成员方法也是已经存在，就可以使用对象名来引用成员方法。</p>
<h4 id="通过对象名引用成员方法"><a href="#通过对象名引用成员方法" class="headerlink" title="通过对象名引用成员方法"></a>通过对象名引用成员方法</h4><p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodRefefObject</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUpperCase</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">		sout(str.toUpperCase());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数式接口仍然定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>那么当需要使用这个printUpperCase成员方法来替printable接口的Lambda的时候，已经具有了MethodRefefObject类的对象实例，则可以通过对象名引用成员方法，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span></span>&#123;</span><br><span class="line">        p.print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    psvm&#123;</span><br><span class="line">        printString((s)-&gt;&#123;</span><br><span class="line">            MethodRerObject obj = <span class="keyword">new</span> MethodRerObject();</span><br><span class="line">            obj.printUpperCaseString(s);</span><br><span class="line">        &#125;);</span><br><span class="line">        MethodRerObject obj = <span class="keyword">new</span> MethodRerObject();</span><br><span class="line">        printString(obj::printUpperCase)<span class="comment">//HELLO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过类名称引用静态方法"><a href="#通过类名称引用静态方法" class="headerlink" title="通过类名称引用静态方法"></a>通过类名称引用静态方法</h4><p>使用前提：类已经存在，静态成员方法也已经存在，就可以通过类名直接引用静态成员方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JieKou1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i,JieKou1 j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j.abs(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = sum(-<span class="number">10</span>, Math::abs);</span><br><span class="line">        System.out.println(sum);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过super引用成员方法"><a href="#通过super引用成员方法" class="headerlink" title="通过super引用成员方法"></a>通过super引用成员方法</h4><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行代替。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">HuMan</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello 我是man&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(JieKou2 j)</span></span>&#123;</span><br><span class="line">        j.green();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        method(<span class="keyword">super</span>::sayHello);<span class="comment">//hello 我是Human</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Man().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JieKou2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">green</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuMan</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello 我是Human&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过this引用成员方法"><a href="#通过this引用成员方法" class="headerlink" title="通过this引用成员方法"></a>通过this引用成员方法</h4><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this：：成员方法”的格式来使用方法引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JieKou3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyFangZi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买了一个房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jieHun</span><span class="params">(JieKou3 j)</span></span>&#123;</span><br><span class="line">        j.buy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">soHappy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jieHun(<span class="keyword">this</span>::buyFangZi);<span class="comment">//买了一个房子</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test02().soHappy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类的构造器引用"><a href="#类的构造器引用" class="headerlink" title="类的构造器引用"></a>类的构造器引用</h4><p>由于构造器的名称与类名一样，并不固定。所以构造器引用“类名称：：new的格式表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JieKou4</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">newPerson</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String naem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String naem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.naem = naem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNaem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> naem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNaem</span><span class="params">(String naem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.naem = naem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String name,JieKou4 j)</span></span>&#123;</span><br><span class="line">        Person person = j.newPerson(name);</span><br><span class="line">        System.out.println(person.getNaem());<span class="comment">//迪丽热巴</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method(<span class="string">&quot;迪丽热巴&quot;</span>,Person::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组的构造器引用"><a href="#数组的构造器引用" class="headerlink" title="数组的构造器引用"></a>数组的构造器引用</h4><p>数组也是Object的子类对象，所以同样具有构造器，只是语法稍有不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JieKou5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] builderArr(<span class="keyword">int</span> length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] method(<span class="keyword">int</span> length,JieKou5 j)&#123;</span><br><span class="line">        <span class="keyword">return</span> j.builderArr(length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] method = method(<span class="number">10</span>, <span class="keyword">int</span>[]::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(method.length);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/24/Stream%E6%B5%81%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/" data-id="ckfmol2oq00086wvw72n6f7x8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-函数式接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/24/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/" class="article-date">
  <time datetime="2020-09-24T01:04:28.075Z" itemprop="datePublished">2020-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/24/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/">函数式接口</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p><strong>定义</strong></p>
<p>函数式接口：有且只有一个抽象方法的接口，称之为函数式接口，当然接口中可以包含其它方法（默认，静态，私有）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名称</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名称（可选参数信息）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@FunctionlInterface注解</strong></p>
<p>作用：可以检测接口是否是一个函数式接口。</p>
<h4 id="使用Lambda优化日志案例"><a href="#使用Lambda优化日志案例" class="headerlink" title="使用Lambda优化日志案例"></a>使用Lambda优化日志案例</h4><p>Lambda的特点：延迟加载。</p>
<p>Lambda的使用前提，必须存在函数式接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">builderMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;wrold&quot;</span>;</span><br><span class="line">        String str3 = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">        showLog(<span class="number">1</span>,()-&gt;str1 + str2 + str3);</span><br><span class="line">        showLog(<span class="number">2</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;条件不满足不执行&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> str1 + str2 + str3;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showLog</span><span class="params">(<span class="keyword">int</span> level,MessageBuilder messageBuilder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(messageBuilder.builderMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Lambda表达式作为参数传递，仅仅是把参数传递到showLog方法中，只有满足条件，日志的等级是1级，才会调用接口MessageBuilder中的方法builderMessage,才会进行字符串拼接。</p>
<h4 id="函数式接口作为方法的返回值类型"><a href="#函数式接口作为方法的返回值类型" class="headerlink" title="函数式接口作为方法的返回值类型"></a>函数式接口作为方法的返回值类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title">getComparator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//按照数组的长度降序排序</span></span><br><span class="line">        <span class="keyword">return</span> (o1,o2)-&gt;o2.length()-o1.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strings = &#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bbbbb&quot;</span>,<span class="string">&quot;ccc&quot;</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(strings));<span class="comment">//[aa, bbbbb, ccc]</span></span><br><span class="line">        Arrays.sort(strings,getComparator());</span><br><span class="line">        System.out.println(Arrays.toString(strings));<span class="comment">//[bbbbb, ccc, aa]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h4><p>java.util.function包中被提供。</p>
<h4 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h4><p>java.util.function.Supplier<T> 接口仅包含一个无参方法：T get();用来获取一个泛型参数指定类型的对象数据。</p>
<p>Supplier<T>接口被称之为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; supplier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = getString(()-&gt;<span class="string">&quot;胡歌&quot;</span>);</span><br><span class="line">        System.out.println(str);<span class="comment">//胡歌</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求数组中的最大值"><a href="#求数组中的最大值" class="headerlink" title="求数组中的最大值"></a>求数组中的最大值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">30</span>,<span class="number">88</span>,-<span class="number">22</span>,-<span class="number">44</span>,<span class="number">100</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxValue = getMax(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; max) &#123;</span><br><span class="line">                    max = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值是：&quot;</span> + maxValue);<span class="comment">//最大值是：100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h4><p>java.util.function.Consumer<T> 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定。</p>
<p>Consumer接口包含抽象方法void accept(T t),意为消费一个指定泛型的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mothed</span><span class="params">(String str, Consumer&lt;String&gt; con)</span></span>&#123;</span><br><span class="line">        con.accept(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">&quot;赵丽颖&quot;</span>;</span><br><span class="line">        mothed(name,con-&gt;&#123;</span><br><span class="line">            System.out.println(name);<span class="comment">//赵丽颖</span></span><br><span class="line">            String rname = <span class="keyword">new</span> StringBuffer(name).reverse().toString();<span class="comment">//颖丽赵</span></span><br><span class="line">            System.out.println(rname);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Consumer默认方法：andThen"><a href="#Consumer默认方法：andThen" class="headerlink" title="Consumer默认方法：andThen"></a>Consumer默认方法：andThen</h4><p>如果一个方法的参数和返回值全都是Consumer类型，那么就可以实现效果：消费数据的时候，首先做一个操作，然后在做一个操作，实现组合。而这个方法就是Consumer接口中过的默认方法andThen。</p>
<p>例如：</p>
<p>Consumer<String> con1</p>
<p>Consumer<String> con2</p>
<p>String s = “hello”;</p>
<p>con1.accept(s);</p>
<p>con2.accept(s);</p>
<p>连接两个Consumer接口，在进行消费</p>
<p>con1.andThen(con2).accept(s);谁写前边谁先消费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAndThen</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String name, Consumer&lt;String&gt; con1,Consumer&lt;String&gt; con2)</span></span>&#123;</span><br><span class="line">        con1.andThen(con2).accept(name);<span class="comment">//谁在前面谁先消费</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method(<span class="string">&quot;aaaAAA&quot;</span>,(s)-&gt;&#123;</span><br><span class="line">            System.out.println(s.toUpperCase());<span class="comment">//AAAAAA</span></span><br><span class="line">        &#125;,(s)-&gt;&#123;</span><br><span class="line">            System.out.println(s.toLowerCase());<span class="comment">//aaaaaa</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习：格式化打印信息"><a href="#练习：格式化打印信息" class="headerlink" title="练习：格式化打印信息"></a>练习：格式化打印信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String[] arr, Consumer&lt;String&gt; con1,Consumer&lt;String&gt; con2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            con1.andThen(con2).accept(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;迪丽热巴,女&quot;</span>,<span class="string">&quot;古力娜扎,女&quot;</span>,<span class="string">&quot;马尔扎哈,男&quot;</span>&#125;;</span><br><span class="line">        method(arr,(s)-&gt;&#123;</span><br><span class="line">            String name = s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">            System.out.print(<span class="string">&quot;姓名是：&quot;</span> + name);</span><br><span class="line">        &#125;,(s)-&gt;&#123;</span><br><span class="line">            String xingBie = s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">            System.out.println(<span class="string">&quot;,性别是：&quot;</span> + xingBie);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/*姓名是：迪丽热巴,性别是：女</span></span><br><span class="line"><span class="comment">        姓名是：古力娜扎,性别是：女</span></span><br><span class="line"><span class="comment">        姓名是：马尔扎哈,性别是：男*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h4><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用Predicate接口。</p>
<p>抽象方法：test</p>
<p>boolean test(T t);用于条件判断的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">method</span><span class="params">(String str, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre.test(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> reValue = method(str, (s) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> s.length() &gt; <span class="number">5</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(reValue);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Predicate接口默认方法：and"><a href="#Predicate接口默认方法：and" class="headerlink" title="Predicate接口默认方法：and"></a>Predicate接口默认方法：and</h4><p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个Predicate条件使用“与”逻辑连接起来实现“并且”的效果时，可以使用默认方法and。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateAndTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">method</span><span class="params">(String str, Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2)</span></span>&#123;</span><br><span class="line"><span class="comment">//        return pre1.test(str) &amp;&amp; pre2.test(str);</span></span><br><span class="line">        <span class="keyword">return</span> pre1.and(pre2).test(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> reValue = method(str, (s) -&gt; &#123;</span><br><span class="line">            <span class="comment">//判断字符串的长度是否大于5</span></span><br><span class="line">            <span class="keyword">return</span> s.length() &gt; <span class="number">5</span>;</span><br><span class="line">        &#125;, (s) -&gt; &#123;</span><br><span class="line">            <span class="comment">//判断字符串是否包含a</span></span><br><span class="line">            <span class="keyword">return</span> s.contains(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(reValue);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Predicate接口默认方法：or"><a href="#Predicate接口默认方法：or" class="headerlink" title="Predicate接口默认方法：or"></a>Predicate接口默认方法：or</h4><p>与and的“与”类似，默认方法or现实逻辑关系中的“或”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> per1.or(pre2).test(str);</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="keyword">return</span> pre1.test(str) || pre2.test(str)</span><br></pre></td></tr></table></figure>



<h4 id="Predicate接口默认方法：negate"><a href="#Predicate接口默认方法：negate" class="headerlink" title="Predicate接口默认方法：negate"></a>Predicate接口默认方法：negate</h4><p>“与”、“或”已经了解了，剩下的“非”（取反）。默认方法negate。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> pre.negate.test(str);<span class="comment">//对结果取反</span></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="keyword">return</span> !pre.test(str);</span><br></pre></td></tr></table></figure>

<h4 id="练习：筛选字符串中的数据"><a href="#练习：筛选字符串中的数据" class="headerlink" title="练习：筛选字符串中的数据"></a>练习：筛选字符串中的数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">method</span><span class="params">(String[] arr, Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//过滤字符串数组，将结果储存到集合中</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> test = pre1.and(pre2).test(s);</span><br><span class="line">            <span class="keyword">if</span> (test)&#123;</span><br><span class="line">                list.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;迪丽热巴,女&quot;</span>,<span class="string">&quot;古力娜扎,女&quot;</span>,<span class="string">&quot;马尔扎哈,男&quot;</span>,<span class="string">&quot;赵丽颖,女&quot;</span>&#125;;</span><br><span class="line">        ArrayList&lt;String&gt; list = method(arr, (s) -&gt; &#123;</span><br><span class="line">            <span class="comment">//逗号后后面的性别为女为真</span></span><br><span class="line">            <span class="keyword">return</span> s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>].equals(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">        &#125;, (s) -&gt; &#123;</span><br><span class="line">            <span class="comment">//姓名的长度大于3为真</span></span><br><span class="line">            <span class="keyword">return</span> s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].length() &gt; <span class="number">3</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);<span class="comment">//[迪丽热巴,女, 古力娜扎,女]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h4><p>Function接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。</p>
<p><strong>抽象方法：apply</strong></p>
<p>Function接口中最主要的抽象方法为：R apply(T t)，根据类型T的参数获取类型R 的结果。</p>
<p>使用的场景例如：将String类型转换为Integer类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String str, Function&lt;String,Integer&gt; fun)</span></span>&#123;</span><br><span class="line">        Integer apply = fun.apply(str);</span><br><span class="line">        System.out.println(apply);<span class="comment">//1234</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        method(s,(string)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(string);<span class="comment">//将字符串转换为Integer类型</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Function接口默认方法：andThen"><a href="#Function接口默认方法：andThen" class="headerlink" title="Function接口默认方法：andThen"></a>Function接口默认方法：andThen</h4><p>Function接口有一个默认的andThen方法，用来进行组合操作。</p>
<p>该方法同样用于“先做什么，在做什么的场景，和Consumer中的andThen差不多”；</p>
<p>将字符串的整数转换为整数乘以10，在转换为字符串的整数类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionAndThenTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String str, Function&lt;String,Integer&gt; fun1,Function&lt;Integer,String&gt; fun2)</span></span>&#123;</span><br><span class="line">        String s = fun1.andThen(fun2).apply(str);</span><br><span class="line">        System.out.println(s);<span class="comment">//12340</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String strings = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        method(strings,(s)-&gt;&#123;</span><br><span class="line">             <span class="keyword">return</span> Integer.parseInt(s) * <span class="number">10</span>;</span><br><span class="line">        &#125;,(integer)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> integer + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>将字符串变为字符串，再将字符串变为包装整数类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String str, Function&lt;String,String&gt; fun1,Function&lt;String,Integer&gt; fun2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = fun1.andThen(fun2).apply(str);</span><br><span class="line">        System.out.println(sum);<span class="comment">//40</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String string = <span class="string">&quot;赵丽颖,20&quot;</span>;</span><br><span class="line">        method(string,(s)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">        &#125;,(s)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(s) + <span class="number">20</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/24/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/" data-id="ckfmol2ou000e6wvweud4hln9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HashMap相关问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/23/HashMap%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-09-23T14:21:53.065Z" itemprop="datePublished">2020-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/23/HashMap%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/">HashMap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="HashMap相关的问题"><a href="#HashMap相关的问题" class="headerlink" title="HashMap相关的问题"></a>HashMap相关的问题</h1><h4 id="HashMap的内部数据结构？"><a href="#HashMap的内部数据结构？" class="headerlink" title="HashMap的内部数据结构？"></a>HashMap的内部数据结构？</h4><p>jdk7：数组加链表</p>
<p>jdk8:数组加链表加红黑树</p>
<h4 id="数据结构图"><a href="#数据结构图" class="headerlink" title="数据结构图"></a>数据结构图</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wxG24I"><img src="https://s1.ax1x.com/2020/09/23/wxG24I.png" alt="wxG24I.png"></a></p>
<h4 id="HashMap的数据插入原理"><a href="#HashMap的数据插入原理" class="headerlink" title="HashMap的数据插入原理"></a>HashMap的数据插入原理</h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wxGbUs"><img src="https://s1.ax1x.com/2020/09/23/wxGbUs.png" alt="wxGbUs.png"></a></p>
<ol>
<li>判断数组是否为空，为空进行初始化;</li>
<li>不为空，计算 k 的 hash 值，通过<code>(n - 1) &amp; hash</code>计算应当存放在数组中的下标 index;</li>
<li>查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中；</li>
<li>存在数据，说明发生了hash冲突(存在二个节点key的hash值一样), 继续判断key是否相等，相等，用新的value替换原数据(onlyIfAbsent为false)；</li>
<li>如果不相等，判断当前节点类型是不是树型节点，如果是树型节点，创造树型节点插入红黑树中；(如果当前节点是树型节点证明当前已经是红黑树了)</li>
<li>如果不是树型节点，创建普通Node加入链表中；判断链表长度是否大于 8并且数组长度大于64， 大于的话链表转换为红黑树；</li>
<li>插入完成之后判断当前节点数是否大于阈值，如果大于开始扩容为原数组的二倍。</li>
</ol>
<h4 id="HashMap怎么设定初始容量大小的"><a href="#HashMap怎么设定初始容量大小的" class="headerlink" title="HashMap怎么设定初始容量大小的"></a>HashMap怎么设定初始容量大小的</h4><p>一般如果new HashMap() 不传值，默认大小是16，负载因子是0.75， 如果自己传入初始大小k，初始化大小为 大于k的 2的整数次方，例如如果传10，大小为16。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充说明：下图是详细过程，算法就是让初始二进制右移1，2，4，8，16位，分别与自己位或，把高位第一个为1的数通过不断右移，把高位为1的后面全变为1，最后再进行+1操作，111111 + 1 = 1000000 = (二的六次方)（符合大于50并且是2的整数次幂 ）</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wxJzWt"><img src="https://s1.ax1x.com/2020/09/23/wxJzWt.png" alt="wxJzWt.png"></a></p>
<h4 id="HashMap的哈希函数怎么设计的"><a href="#HashMap的哈希函数怎么设计的" class="headerlink" title="HashMap的哈希函数怎么设计的"></a>HashMap的哈希函数怎么设计的</h4><p>hash函数是先拿到 key 的hashcode，是一个32位的int值，然后让hashcode的高16位和低16位进行异或操作</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wxGX80"><img src="https://s1.ax1x.com/2020/09/23/wxGX80.png" alt="wxGX80.png"></a></p>
<p><strong>为什么这么设计</strong></p>
<p>这个也叫扰动函数，这么设计有二点原因：</p>
<ol>
<li>一定要尽可能降低hash碰撞，越分散越好；</li>
<li>算法一定要尽可能高效，因为这是高频操作, 因此采用位运算；</li>
</ol>
<p><strong>为什么采用hashcode的高16位和低16位异或能降低hash碰撞？hash函数能不能直接用key的hashcode？</strong></p>
<p>因为key.hashCode()函数调用的是key键值类型自带的哈希函数，返回int型散列值。int值范围为**-2147483648~2147483647**，前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。你想，如果HashMap数组的初始大小才16，用之前需要对数组的长度取模运算，得到的余数才能用来访问数组下标。</p>
<p>源码中模运算就是把散列值和数组长度-1做一个”与”操作，位运算比取余%运算要快。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bucketIndex = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也正好解释了为什么HashMap的数组长度要取2的整数幂。因为这样（数组长度-1）正好相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  10100101 11000100 00100101</span><br><span class="line">&amp; 00000000 00000000 00001111</span><br><span class="line">----------------------------------</span><br><span class="line">  00000000 00000000 00000101    &#x2F;&#x2F;高位全部归零，只保留末四位</span><br></pre></td></tr></table></figure>

<p>但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，如果正好让最后几个低位呈现规律性重复，就无比蛋疼。这时候“扰动函数”的价值就体现出来了，</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wxJeKO"><img src="https://s1.ax1x.com/2020/09/23/wxJeKO.png" alt="wxJeKO.png"></a></p>
<p>右移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>
<p>实验：随机选取了352个字符串，在他们散列值完全没有冲突的前提下，对它们做低位掩码，取数组下标。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wxJmrD"><img src="https://s1.ax1x.com/2020/09/23/wxJmrD.png" alt="wxJmrD.png"></a></p>
<p>结果显示，当HashMap数组长度为512的时候（  二的九次方 ），也就是用掩码取低9位的时候，在没有扰动函数的情况下，发生了103次碰撞，接近30%。而在使用了扰动函数之后只有92次碰撞。碰撞减少了将近10%。看来扰动函数确实还是有功效的。</p>
<p>另外Java1.8相比1.7做了调整，1.7做了四次移位和四次异或，但明显Java 8觉得扰动做一次就够了，做4次的话，多了可能边际效用也不大，所谓为了效率考虑就改成一次了。</p>
<p>下面是1.7的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.8对hash函数做了优化，1.8还有别的优化吗？</strong></p>
<p>1.8还有三点主要的优化：</p>
<ol>
<li>数组+链表改成了数组+链表或红黑树；</li>
<li>链表的插入方式从头插法改成了尾插法，简单说就是插入时，如果数组位置上已经有元素，1.7将新元素放到数组中，原始节点作为新节点的后继节点，1.8遍历链表，将元素放置到链表的最后；</li>
<li>扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小；</li>
<li>在插入时，1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩容；</li>
</ol>
<p><strong>为什么要做这几点优化</strong></p>
<ol>
<li><p>防止发生hash冲突，链表长度过长，将时间复杂度由<code>O(n)</code>降为<code>O(logn)</code>;</p>
</li>
<li><p>因为1.7头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；</p>
<p>A线程在插入节点B，B线程也在插入，遇到容量不够开始扩容，重新hash，放置元素，采用头插法，后遍历到的B节点放入了头部，这样形成了环，如下图所示：</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wxJMad"><img src="https://s1.ax1x.com/2020/09/23/wxJMad.png" alt="wxJMad.png"></a></p>
<p>1.7的扩容调用transfer代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">      Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">      <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">        e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">      e.next = newTable[i]; <span class="comment">//A线程如果执行到这一行挂起，B线程开始进行扩容</span></span><br><span class="line">      newTable[i] = e;</span><br><span class="line">      e = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扩容的时候为什么1.8 不用重新hash就可以直接定位原节点在新数据的位置呢?</strong></p>
<p>这是由于扩容是扩大为原数组大小的2倍，用于计算数组位置的掩码仅仅只是高位多了一个1，理解</p>
<p>扩容前长度为16，用于计算(n-1) &amp; hash 的二进制n-1为0000 1111，扩容为32后的二进制就高位多了1，为0001 1111。</p>
<p>因为是&amp; 运算，1和任何数 &amp; 都是它本身，那就分二种情况，如下图：原数据hashcode高位第4位为0和高位为1的情况；</p>
<p>第四位高位为0，重新hash数值不变，第四位为1，重新hash数值比原来大16（旧数组的容量）</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wxJ8RP"><img src="https://s1.ax1x.com/2020/09/23/wxJ8RP.png" alt="wxJ8RP.png"></a></p>
<h4 id="那HashMap是线程安全的吗？"><a href="#那HashMap是线程安全的吗？" class="headerlink" title="那HashMap是线程安全的吗？"></a>那HashMap是线程安全的吗？</h4><p>不是，在多线程环境下，1.7 会产生死循环、数据丢失、数据覆盖的问题，1.8 中会有数据覆盖的问题，以1.8为例，当A线程判断index位置为空后正好挂起，B线程开始往index位置的写入节点数据，这时A线程恢复现场，执行赋值操作，就把A线程的数据给覆盖了；还有++size这个地方也会造成多线程同时扩容等问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)  <span class="comment">//多线程执行到这里</span></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 这里很重要</span></span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;</span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 多个线程走到这，可能重复resize()</span></span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="怎么解决这个线程不安全的问题？"><a href="#怎么解决这个线程不安全的问题？" class="headerlink" title="怎么解决这个线程不安全的问题？"></a>怎么解决这个线程不安全的问题？</h4><p>java中有HashTable、Collections.synchronizedMap、以及ConcurrentHashMap可以实现线程安全的Map。</p>
<p>HashTable是直接在操作方法上加synchronized关键字，锁住整个数组，粒度比较大，Collections.synchronizedMap是使用Collections集合工具的内部类，通过传入Map封装出一个SynchronizedMap对象，内部定义了一个对象锁，方法内通过对象锁实现；ConcurrentHashMap使用分段锁，降低了锁粒度，让并发度大大提高。</p>
<h4 id="ConcurrentHashMap的分段锁的实现原理"><a href="#ConcurrentHashMap的分段锁的实现原理" class="headerlink" title="ConcurrentHashMap的分段锁的实现原理"></a>ConcurrentHashMap的分段锁的实现原理</h4><p>ConcurrentHashMap成员变量使用volatile 修饰，免除了指令重排序，同时保证内存可见性，另外使用CAS操作和synchronized结合实现赋值操作，多线程操作只会锁住当前操作索引的节点。</p>
<p>如下图，线程A锁住A节点所在链表，线程B锁住B节点所在链表，操作互不干涉。</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wxJdaj"><img src="https://s1.ax1x.com/2020/09/23/wxJdaj.png" alt="wxJdaj.png"></a></p>
<h4 id="链表转红黑树是链表长度达到阈值，这个阈值是多少？"><a href="#链表转红黑树是链表长度达到阈值，这个阈值是多少？" class="headerlink" title="链表转红黑树是链表长度达到阈值，这个阈值是多少？"></a>链表转红黑树是链表长度达到阈值，这个阈值是多少？</h4><p>阈值是8，红黑树转链表阈值为6</p>
<p><strong>为什么是8，不是16，32甚至是7 ？又为什么红黑树转链表的阈值是6，不是8了呢？</strong></p>
<p>因为经过计算，在hash函数设计合理的情况下，发生hash碰撞8次的几率为百万分之6，概率说话。。因为8够用了，至于为什么转回来是6，因为如果hash碰撞次数在8附近徘徊，会一直发生链表和红黑树的互相转化，为了预防这种情况的发生。</p>
<p><strong>HashMap内部节点是有序的吗?</strong></p>
<p>是无序的，根据hash值随机插入</p>
<p><strong>有没有有序的Map？</strong></p>
<p>LinkedHashMap 和 TreeMap</p>
<p><strong>LinkedHashMap怎么实现有序的？</strong></p>
<p>LinkedHashMap内部维护了一个单链表，有头尾节点，同时LinkedHashMap节点Entry内部除了继承HashMap的Node属性，还有before 和 after用于标识前置节点和后置节点。可以实现按插入的顺序或访问顺序排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"><span class="comment">//链接新加入的p节点到链表后端</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">  LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">  tail = p;</span><br><span class="line">  <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">    head = p;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    p.before = last;</span><br><span class="line">    last.after = p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LinkedHashMap的节点类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  Entry&lt;K,V&gt; before, after;</span><br><span class="line">  Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Map&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;安琪拉&quot;</span>);</span><br><span class="line">  map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;的&quot;</span>);</span><br><span class="line">  map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;博客&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(Map.Entry&lt;String,String&gt; item: map.entrySet())&#123;</span><br><span class="line">    System.out.println(item.getKey() + <span class="string">&quot;:&quot;</span> + item.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//console输出</span></span><br><span class="line"><span class="number">1</span>:安琪拉</span><br><span class="line"><span class="number">2</span>:的</span><br><span class="line"><span class="number">3</span>:博客</span><br></pre></td></tr></table></figure>

<h4 id="TreeMap怎么实现有序的？"><a href="#TreeMap怎么实现有序的？" class="headerlink" title="TreeMap怎么实现有序的？"></a>TreeMap怎么实现有序的？</h4><p>TreeMap是按照Key的自然顺序或者Comprator的顺序进行排序，内部是通过红黑树来实现。所以要么key所属的类实现Comparable接口，或者自定义一个实现了Comparator接口的比较器，传给TreeMap用于key的比较。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/23/HashMap%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" data-id="ckfmol2oi00026wvwg6kd5rzq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网络编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2020-09-23T08:34:35.715Z" itemprop="datePublished">2020-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a><strong>通信协议</strong></h4><p>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</p>
<p>网络通信协议有很多种，目前应用最广泛的是TCP/IP协议(Transmission Control Protocal/Internet Protoal传输控制协议/英特网互联协议)，它是一个包括TCP协议和IP协议，UDP（User Datagram Protocol）协议和其它一些协议的协议组，在学习具体协议之前首先了解一下TCP/IP协议组的层次结构。</p>
<p>TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能，接下来针对这四层进行详细地讲解。</p>
<ul>
<li>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。</li>
<li>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。</li>
<li>传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。</li>
<li>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</li>
</ul>
<h4 id="IP地址和端口号"><a href="#IP地址和端口号" class="headerlink" title="IP地址和端口号"></a><strong>IP地址和端口号</strong></h4><p>要想使网络中的计算机能够进行通信，必须为每台计算机指定一个标识号，通过这个标识号来指定接受数据的计算机或者发送数据的计算机。</p>
<p>在TCP/IP协议中，这个标识号就是IP地址，它可以唯一标识一台计算机，目前，IP地址广泛使用的版本是IPv4，它是由4个字节大小的二进制数来表示，如：00001010000000000000000000000001。由于二进制形式表示的IP地址非常不便记忆和处理，因此通常会将IP地址写成十进制的形式，每个字节用一个十进制数字(0-255)表示，数字间用符号“.”分开，如 “192.168.1.100”。</p>
<p>随着计算机网络规模的不断扩大，对IP地址的需求也越来越多，IPV4这种用4个字节表示的IP地址面临枯竭，因此IPv6 便应运而生了，IPv6使用16个字节表示IP地址，它所拥有的地址容量约是IPv4的8×1028倍，达到2128个（算上全零的），这样就解决了网络地址资源数量不够的问题。</p>
<p>通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。在计算机中，不同的应用程序是通过端口号区分的。端口号是用两个字节（16位的二进制数）表示的，它的取值范围是0<del>65535，其中，0</del>1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一个应用或服务所占用。</p>
<h4 id="TCP通信程序"><a href="#TCP通信程序" class="headerlink" title="TCP通信程序"></a>TCP通信程序</h4><h4 id="TCP发送数据"><a href="#TCP发送数据" class="headerlink" title="TCP发送数据"></a>TCP发送数据</h4><p>Java中的TCP通信</p>
<ul>
<li>Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。</li>
<li>Java为客户端提供了Socket类，为服务器端提供了ServerSocket类</li>
</ul>
<p>构造方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Socket(InetAddress address,int port)</td>
<td>创建流套接字并将其连接到指定IP指定端口号</td>
</tr>
<tr>
<td>Socket(String host, int port)</td>
<td>创建流套接字并将其连接到指定主机上的指定端口号</td>
</tr>
</tbody></table>
<p>相关方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>InputStream  getInputStream()</td>
<td>返回此套接字的输入流</td>
</tr>
<tr>
<td>OutputStream getOutputStream()</td>
<td>返回此套接字的输出流</td>
</tr>
</tbody></table>
<h4 id="TCP接受数据"><a href="#TCP接受数据" class="headerlink" title="TCP接受数据"></a>TCP接受数据</h4><p>构造方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ServletSocket(int port)</td>
<td>创建绑定到指定端口的服务器套接字</td>
</tr>
</tbody></table>
<p>相关方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Socket accept()</td>
<td>监听要连接到此的套接字并接受它</td>
</tr>
</tbody></table>
<h4 id="TCP通信程序练习"><a href="#TCP通信程序练习" class="headerlink" title="TCP通信程序练习"></a>TCP通信程序练习</h4><ul>
<li><p>案例需求</p>
<p>客户端：发送数据，接受服务器反馈</p>
<p>服务器：收到消息后给出反馈</p>
</li>
<li><p>案例分析</p>
<ul>
<li>客户端创建对象，使用输出流输出数据</li>
<li>服务端创建对象，使用输入流接受数据</li>
<li>服务端使用输出流给出反馈数据</li>
<li>客户端使用输入流接受反馈数据</li>
</ul>
</li>
</ul>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建服务器端的Socket对象(ServerSocket)</span></span><br><span class="line">        <span class="comment">//ServerSocket(int port) 创建绑定到指定端口的服务器套接字</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//Socket accept() 侦听要连接到此套接字并接受它</span></span><br><span class="line">        Socket accept = ss.accept();</span><br><span class="line">        <span class="comment">//获取输入流，读数据，并把数据显示在控制台</span></span><br><span class="line">        InputStream inputStream = accept.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = inputStream.read(bytes);</span><br><span class="line">        String s = <span class="keyword">new</span> String(bytes, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(<span class="string">&quot;数据是：&quot;</span> + s);</span><br><span class="line">        <span class="comment">//给出反馈</span></span><br><span class="line">        OutputStream os = accept.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;数据以收到&quot;</span>.getBytes());</span><br><span class="line">        accept.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建客户端的Socket对象(Socket)</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;192.168.1.4&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//获取输出流，写数据</span></span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;hello:tcp我来了&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//接收服务器反馈</span></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = inputStream.read(bytes);</span><br><span class="line">        String s = <span class="keyword">new</span> String(bytes, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端：&quot;</span> + s);</span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TCP通信程序练习-1"><a href="#TCP通信程序练习-1" class="headerlink" title="TCP通信程序练习"></a>TCP通信程序练习</h4><ul>
<li><p>案例需求</p>
<p>客户端：数据来自于文本文件，接收服务器反馈</p>
<p>服务器：接收到的数据写入文本文件，给出反馈</p>
</li>
<li><p>案例分析</p>
<ul>
<li>创建客户端对象，创建输入流对象指向文件，每读入一行数据就给服务器输出一行数据，输出结束后使用shutdownOutput()方法告知服务端传输结束</li>
<li>创建服务器对象，创建输出流对象指向文件，每接受一行数据就使用输出流输出到文件中，传输结束后。使用输出流给客户端反馈信息</li>
<li>客户端接受服务端的回馈信息</li>
</ul>
</li>
</ul>
<p>相关方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void shutdownInput()</td>
<td>将此套接字的输入流放置在“流的末尾”</td>
</tr>
<tr>
<td>void shutdownOutput()</td>
<td>禁止用此套接字的输出流</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器端</span></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket accept = ss.accept();</span><br><span class="line">        InputStream inputStream = accept.getInputStream();</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;d:\\upload&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">            file.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file + <span class="string">&quot;\\1.jpg&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        accept.getOutputStream().write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line">        fos.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\图片\\线程安全类.png&quot;</span>);</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;192.168.1.4&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            outputStream.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-id="ckfmol2p1000t6wvw2hse89wr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-安全集合类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/23/%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB/" class="article-date">
  <time datetime="2020-09-23T00:24:10.766Z" itemprop="datePublished">2020-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/23/%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB/">线程安全集合类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h1><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wjzM8S"><img src="https://s1.ax1x.com/2020/09/23/wjzM8S.png" alt="wjzM8S.png"></a></p>
<p>线程安全集合类可以分为三大类：</p>
<ul>
<li><p>遗留的线程安全集合如 Hashtable ， Vector</p>
</li>
<li><p>使用 Collections 装饰的线程安全集合，如：</p>
<ul>
<li>Collections.synchronizedCollection </li>
<li>Collections.synchronizedList </li>
<li>Collections.synchronizedMap </li>
<li>Collections.synchronizedSet </li>
<li>Collections.synchronizedNavigableMap </li>
<li>Collections.synchronizedNavigableSet </li>
<li>Collections.synchronizedSortedMap </li>
<li>Collections.synchronizedSortedSet </li>
</ul>
</li>
<li><p>java.util.concurrent.*</p>
</li>
</ul>
<p>重点介绍 java.util.concurrent.* 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词： Blocking、CopyOnWrite、Concurrent</p>
<ul>
<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法 </li>
<li>CopyOnWrite 之类容器修改开销相对较重</li>
<li>Concurrent 类型的容器<ul>
<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量 </li>
<li>弱一致性<ul>
<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍 历，这时内容是旧的</li>
<li>求大小弱一致性，size 操作未必是 100% 准确 </li>
<li>读取弱一致性</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<p>遍历时如果发生了修改，对于非安全容器来讲，使用 fail-fast 机制也就是让遍历立刻失败，抛出 ConcurrentModiﬁcationException，不再继续遍历</p>
<h4 id="JDK-8-ConcurrentHashMap"><a href="#JDK-8-ConcurrentHashMap" class="headerlink" title="JDK 8 ConcurrentHashMap"></a>JDK 8 ConcurrentHashMap</h4><p>Java 8 数组（Node） +（ 链表 Node | 红黑树 TreeNode ） 以下数组简称（table），链表简称（bin）</p>
<ul>
<li>初始化，使用 cas 来保证并发安全，懒惰初始化 table</li>
<li>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程 会用 synchronized 锁住链表头</li>
<li>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素 添加至 bin 的尾部 </li>
<li>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新 table 进行搜索</li>
<li>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可 做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1/6 的节点会把复制到新 table 中</li>
<li>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。后统计数量时累加 即可</li>
</ul>
<h4 id="JDK-7-ConcurrentHashMap"><a href="#JDK-7-ConcurrentHashMap" class="headerlink" title="JDK 7 ConcurrentHashMap"></a>JDK 7 ConcurrentHashMap</h4><p>它维护了一个 segment 数组，每个 segment 对应一把锁</p>
<ul>
<li>优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 jdk8 中是类似的</li>
<li>缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化 </li>
</ul>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p><strong>加锁分析</strong></p>
<p>==高明之处==在于用了两把锁和 dummy 节点</p>
<ul>
<li>用一把锁，同一时刻，多只允许有一个线程（生产者或消费者，二选一）执行</li>
<li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行<ul>
<li>消费者与消费者线程仍然串行 </li>
<li>生产者与生产者线程仍然串行</li>
</ul>
</li>
</ul>
<p>线程安全分析</p>
<ul>
<li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全。两把锁保证了入队和出队没有竞争</li>
<li>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</li>
<li>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</li>
</ul>
<p>**性能比较 **</p>
<p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较</p>
<ul>
<li>Linked 支持有界，Array 强制有界</li>
<li>Linked 实现是链表，Array 实现是数组</li>
<li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组 </li>
<li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的 </li>
<li>Linked 两把锁，Array 一把锁</li>
</ul>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>CopyOnWriteArraySet 是它的马甲 底层实现采用了 写入时拷贝 的思想，增删改操作会将底层数组拷贝一份，更 改操作在新数组上执行，这时不影响其它线程的并发读，读写分离。 </p>
<p>不要觉得弱一致性就不好</p>
<ul>
<li>数据库的 MVCC 都是弱一致性的表现</li>
<li>并发高和一致性是矛盾的，需要权衡</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/23/%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB/" data-id="ckfmol2ow000i6wvw4ceb8mfn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java并发编程共享模型之工具(二)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/22/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7(%E4%BA%8C)/" class="article-date">
  <time datetime="2020-09-22T00:28:59.977Z" itemprop="datePublished">2020-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/22/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7(%E4%BA%8C)/">java并发编程共享模型之工具(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="java并发编程共享模型之工具-二"><a href="#java并发编程共享模型之工具-二" class="headerlink" title="java并发编程共享模型之工具(二)"></a>java并发编程共享模型之工具(二)</h1><h4 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h4><p>在任务调度线程池功能加入之前，可以使用java.uti.Timer来实现定时功能，Timer的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是穿行执行的，同一时间只能由一个任务执行，前一个任务的延迟或异常都将会影响到之后的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        TimerTask task = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;task1......&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        TimerTask task1 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;task2....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">        <span class="comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span></span><br><span class="line">        timer.schedule(task,<span class="number">1000</span>);</span><br><span class="line">        timer.schedule(task1,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 ScheduledExecutorService 改写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutorServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;begin...&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="comment">// 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">        pool.schedule(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task1.....&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        pool.schedule(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task1.....&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        &#125;,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin...Tue Sep <span class="number">22</span> <span class="number">08</span>:<span class="number">48</span>:<span class="number">39</span> CST <span class="number">2020</span></span><br><span class="line">task1.....Tue Sep <span class="number">22</span> <span class="number">08</span>:<span class="number">48</span>:<span class="number">40</span> CST <span class="number">2020</span></span><br><span class="line">task1.....Tue Sep <span class="number">22</span> <span class="number">08</span>:<span class="number">48</span>:<span class="number">40</span> CST <span class="number">2020</span></span><br></pre></td></tr></table></figure>

<p>scheduleAtFixedRate 例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">scheduleAtFixedRateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;bengin....&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        pool.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task1...&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bengin....Tue Sep 22 08:54:35 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:54:36 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:54:37 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:54:38 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:54:39 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:54:40 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:54:41 CST 2020</span><br></pre></td></tr></table></figure>

<p>scheduleAtFixedRate 例子（任务执行时间超过了间隔时间）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">scheduleAtFixedRateTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;bengin....&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        pool.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task1...&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出分析：一开始，延时 1s，接下来，由于任务执行时间 &gt; 间隔时间，间隔被『撑』到了 2s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bengin....Tue Sep 22 08:58:03 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:58:04 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:58:06 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:58:08 CST 2020</span><br><span class="line">task1...Tue Sep 22 08:58:10 CST 2020</span><br></pre></td></tr></table></figure>

<p>scheduleWithFixedDelay 例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleWithFixedDelayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot;bengin....&quot;</span>);</span><br><span class="line">        pool.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot;task....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束 &lt;-&gt; 延时 &lt;-&gt; 下一个任务开始 所 以间隔都是 3s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tue Sep 22 09:03:09 CST 2020bengin....</span><br><span class="line">Tue Sep 22 09:03:10 CST 2020task....</span><br><span class="line">Tue Sep 22 09:03:13 CST 2020task....</span><br><span class="line">Tue Sep 22 09:03:16 CST 2020task....</span><br><span class="line">Tue Sep 22 09:03:19 CST 2020task....</span><br></pre></td></tr></table></figure>

<p><strong>评价</strong></p>
<p>整个线程池变现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也会被释放。用来执行延迟或反复执行的任务。</p>
<h4 id="正确处理执行任务异常"><a href="#正确处理执行任务异常" class="headerlink" title="正确处理执行任务异常"></a>正确处理执行任务异常</h4><p>方法1：主动捉异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;error:&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>方法2：使用 Future</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">log.debug(<span class="string">&quot;result:&#123;&#125;&quot;</span>, f.get());</span><br></pre></td></tr></table></figure>

<h4 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h4><p>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型 运算</p>
<p>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计 算，如归并排序、斐波那契数列、都可以用分治思想进行求解</p>
<p>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运 算效率</p>
<p>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池</p>
<p><strong>使用</strong></p>
<p>提交给Fork/Join 线程池的任务需要继承RecursiveTask(有返回值)或RecursiveAction(没有返回值)，例如下面定义了一个对1-N之间的整数求和的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        System.out.println(forkJoinPool.invoke(<span class="keyword">new</span> AddTask(<span class="number">5</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddTask</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AddTask&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;n=&quot;</span> + n +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 n 已经为 1，可以求得结果了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;join&quot;</span> + n);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将任务进行拆分(fork)</span></span><br><span class="line">        AddTask t1 = <span class="keyword">new</span> AddTask(n - <span class="number">1</span>);</span><br><span class="line">        t1.fork();</span><br><span class="line">        System.out.println(<span class="string">&quot;fork&quot;</span> + n + t1);</span><br><span class="line">        <span class="comment">// 合并(join)结果</span></span><br><span class="line">        <span class="keyword">int</span> result = n + t1.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;join&quot;</span> + n + t1 + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fork5AddTask&#123;n&#x3D;4&#125;</span><br><span class="line">fork4AddTask&#123;n&#x3D;3&#125;</span><br><span class="line">fork3AddTask&#123;n&#x3D;2&#125;</span><br><span class="line">fork2AddTask&#123;n&#x3D;1&#125;</span><br><span class="line">join1</span><br><span class="line">join2AddTask&#123;n&#x3D;1&#125;3</span><br><span class="line">join3AddTask&#123;n&#x3D;2&#125;6</span><br><span class="line">join4AddTask&#123;n&#x3D;3&#125;10</span><br><span class="line">join5AddTask&#123;n&#x3D;4&#125;15</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<h4 id="J-U-C"><a href="#J-U-C" class="headerlink" title="J.U.C"></a>J.U.C</h4><h4 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h4><p>**概述 **</p>
<p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p>
<p>特点：</p>
<ul>
<li><p>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取 锁和释放锁 </p>
<ul>
<li>getState - 获取 state 状态</li>
<li>setState - 设置 state 状态 </li>
<li>compareAndSetState - cas 机制设置 state 状态 </li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li><p>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList </p>
</li>
<li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet  </p>
</li>
</ul>
<p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p>
<ul>
<li>tryAcquire</li>
<li>tryRelease</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared </li>
<li>isHeldExclusively</li>
</ul>
<p>获取锁的姿势</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果锁获取失败</span></span><br><span class="line"><span class="keyword">if</span>(!tryAcquire(arg))&#123;</span><br><span class="line">	<span class="comment">//入队，可以选择阻塞当前线程  park  unpark</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放锁的姿势</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span>(tryRelease(arg))&#123;</span><br><span class="line">	<span class="comment">//让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReentrantLock-原理"><a href="#ReentrantLock-原理" class="headerlink" title="ReentrantLock 原理"></a>ReentrantLock 原理</h4><h5 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h5><p><strong>加锁解锁流程</strong></p>
<p>先从构造器开始看，默认为非公平锁实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NonfairSync继承自AQS</p>
<p>没有竞争时</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wX8R8U"><img src="https://s1.ax1x.com/2020/09/22/wX8R8U.png" alt="wX8R8U.png"></a></p>
<p>第一次竞争出现时</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wX84KJ"><img src="https://s1.ax1x.com/2020/09/22/wX84KJ.png" alt="wX84KJ.png"></a></p>
<p>Thread-1 执行了</p>
<ol>
<li>CAS 尝试将 state 由 0 改为 1，结果失败 </li>
<li>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败 </li>
<li>接下来进入 addWaiter 逻辑，构造 Node 队列 <ul>
<li>图中黄色三角表示该 </li>
<li>Node 的 waitStatus 状态，其中 0 为默认正常状态 Node 的创建是懒惰的</li>
<li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wX8O2D"><img src="https://s1.ax1x.com/2020/09/22/wX8O2D.png" alt="wX8O2D.png"></a></p>
<p>当前线程进入 acquireQueued 逻辑 </p>
<ol>
<li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞 </li>
<li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li>
<li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wXGCIP"><img src="https://s1.ax1x.com/2020/09/22/wXGCIP.png" alt="wXGCIP.png"></a></p>
<ol start="4">
<li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li>
<li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true </li>
<li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wXGkRS"><img src="https://s1.ax1x.com/2020/09/22/wXGkRS.png" alt="wXGkRS.png"></a></p>
<p>再次有多个线程经历上述过程竞争失败，变成这个样子</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wXGuaq"><img src="https://s1.ax1x.com/2020/09/22/wXGuaq.png" alt="wXGuaq.png"></a></p>
<p>Thread-0 释放锁，进入 tryRelease 流程，如果成功 </p>
<ul>
<li>设置 exclusiveOwnerThread 为 null </li>
<li>state = 0</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wXGJsJ"><img src="https://s1.ax1x.com/2020/09/22/wXGJsJ.png" alt="wXGJsJ.png"></a></p>
<p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程 </p>
<p>找到队列中离 head 近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1</p>
<p>回到 Thread-1 的 acquireQueued 流程</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wXGDzD"><img src="https://s1.ax1x.com/2020/09/22/wXGDzD.png" alt="wXGDzD.png"></a></p>
<p>如果加锁成功（没有竞争），会设置</p>
<ul>
<li>exclusiveOwnerThread 为 Thread-1，state = 1 </li>
<li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread </li>
<li>原本的 head 因为从链表断开，而可被垃圾回收</li>
</ul>
<p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/wXGbes"><img src="https://s1.ax1x.com/2020/09/22/wXGbes.png" alt="wXGbes.png"></a></p>
<p>如果不巧又被 Thread-4 占了先</p>
<ul>
<li>Thread-4 被设置为 exclusiveOwnerThread，state = 1</li>
<li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞 </li>
</ul>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>**ReentrantReadWriteLock **</p>
<p>当读操作远远高于写操作时，这时候使用读写锁让读-读可以并发，提高性能。类似于数据库中的 select … from … lock in share mode</p>
<p>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DataContainer dataContainer = <span class="keyword">new</span> DataContainer();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            dataContainer.read();</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            dataContainer.read();</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rw = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.ReadLock r = rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.WriteLock w = rw.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取读锁...&quot;</span>);</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;释放读锁...&quot;</span>);</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取写锁...&quot;</span>);</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;写入&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;释放写锁...&quot;</span>);</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果，从输出结果看到线程一锁定期间，线程2的读操作不受影响</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取读锁...</span><br><span class="line">获取读锁...</span><br><span class="line">读取</span><br><span class="line">读取</span><br><span class="line">释放读锁...</span><br><span class="line">释放读锁...</span><br></pre></td></tr></table></figure>

<p>测试 读锁-写锁 相互阻塞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DataContainer dataContainer = <span class="keyword">new</span> DataContainer();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    dataContainer.write();</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>写锁-写锁 也是相互阻塞的</p>
<p><strong>注意事项</strong></p>
<ul>
<li>读锁不支持条件变量</li>
<li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    r.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重入降级支持：即持有写锁的情况下去获取读锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line"><span class="comment">// 是否有效，如果失效，需要重新计算</span></span><br><span class="line">    data</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取写锁前必须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = ...</span><br><span class="line">                    cacheValid = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span></span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     <span class="comment">// 自己用完数据, 释放读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**StampedLock **</p>
<p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p>
<p>加解读锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.readLock(); </span><br><span class="line">lock.unlockRead(stamp);</span><br></pre></td></tr></table></figure>

<p>加解写锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.writeLock(); </span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure>

<p>乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通 过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line"><span class="comment">// 锁升级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>StampedLock 不支持条件变量</li>
<li>StampedLock 不支持可重入</li>
</ul>
<p>**Semaphore **</p>
<p>基本使用</p>
<p>信号量，用来限制能同时访问共享资源的线程上限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建 semaphore 对象 </span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 3. 获取许可 </span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                    sleep(<span class="number">1</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 4. 释放许可         </span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">07:35:15.485 c.TestSemaphore [Thread-2] - running...</span><br><span class="line">07:35:15.485 c.TestSemaphore [Thread-1] - running...</span><br><span class="line">07:35:15.485 c.TestSemaphore [Thread-0] - running...</span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-2] - end...</span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-0] - end... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-1] - end...</span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-3] - running... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-5] - running...</span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-4] - running... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-5] - end... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-4] - end... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-3] - end... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-6] - running...</span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-7] - running...</span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-9] - running... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-6] - end...</span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-7] - end... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-9] - end... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-8] - running...</span><br><span class="line">07:35:19.492 c.TestSemaphore [Thread-8] - end...</span><br></pre></td></tr></table></figure>

<h4 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h4><p>用来进行线程同步协作，等待所有线程完成倒计时。</p>
<p>其中构造参数用来初始化等待计数值，await（）用来等待计数归零，countDown（）用来让计数减一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line"> </span><br><span class="line">    log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    latch.await(); </span><br><span class="line">    log.debug(<span class="string">&quot;wait end...&quot;</span>); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">18:44:00.778 c.TestCountDownLatch [main] - waiting...</span><br><span class="line">18:44:00.778 c.TestCountDownLatch [Thread-2] - begin... </span><br><span class="line">18:44:00.778 c.TestCountDownLatch [Thread-0] - begin... </span><br><span class="line">18:44:00.778 c.TestCountDownLatch [Thread-1] - begin... </span><br><span class="line">18:44:01.782 c.TestCountDownLatch [Thread-0] - end...2 </span><br><span class="line">18:44:02.283 c.TestCountDownLatch [Thread-2] - end...1</span><br><span class="line">18:44:02.782 c.TestCountDownLatch [Thread-1] - end...0 </span><br><span class="line">18:44:02.782 c.TestCountDownLatch [main] - wait end...</span><br></pre></td></tr></table></figure>

<p>可以配合线程池使用，改进如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">    ExecutorService service = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>); </span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">            latch.await();</span><br><span class="line">            log.debug(<span class="string">&quot;wait end...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">18:52:25.831 c.TestCountDownLatch [pool-1-thread-3] - begin...</span><br><span class="line">18:52:25.831 c.TestCountDownLatch [pool-1-thread-1] - begin... </span><br><span class="line">18:52:25.831 c.TestCountDownLatch [pool-1-thread-2] - begin...</span><br><span class="line">18:52:25.831 c.TestCountDownLatch [pool-1-thread-4] - waiting...</span><br><span class="line">18:52:26.835 c.TestCountDownLatch [pool-1-thread-1] - end...2</span><br><span class="line">18:52:27.335 c.TestCountDownLatch [pool-1-thread-2] - end...1</span><br><span class="line">18:52:27.835 c.TestCountDownLatch [pool-1-thread-3] - end...0</span><br><span class="line">18:52:27.835 c.TestCountDownLatch [pool-1-thread-4] - wait end... </span><br></pre></td></tr></table></figure>

<p><strong>应用之同步等待多线程准备完毕</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>, (r) -&gt; &#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">&quot;t&quot;</span> + num.getAndIncrement());</span><br><span class="line"> &#125;);</span><br><span class="line">	CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>); String[] all = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">	Random r = <span class="keyword">new</span> Random();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = j;</span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(r.nextInt(<span class="number">100</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                all[x] = Thread.currentThread().getName() + <span class="string">&quot;(&quot;</span> + (i + <span class="string">&quot;%&quot;</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                System.out.print(<span class="string">&quot;\r&quot;</span> + Arrays.toString(all));</span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">&quot;\n游戏开始...&quot;</span>); </span><br><span class="line">service.shutdown();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[t0(100%), t1(100%), t2(100%), t3(100%), t4(100%), t5(100%), t6(100%), t7(100%), t8(100%), t9(100%)]</span><br><span class="line">游戏开始..</span><br></pre></td></tr></table></figure>

<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执 行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>); <span class="comment">// 个数为2时才会继续执行</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;线程1开始..&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	cb.await();</span><br><span class="line"><span class="comment">// 当个数不足时，等待</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;线程1继续向下运行...&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">&#125;).start();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;线程2开始..&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	cb.await();</span><br><span class="line">	<span class="comment">// 2 秒后，线程个数够2，继续运行</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;线程2继续向下运行...&quot;</span>+<span class="keyword">new</span> Date()); &#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的 CyclicBarrier 可以被比 喻为『人满发车]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/22/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%B7%A5%E5%85%B7(%E4%BA%8C)/" data-id="ckfmol2pg00116wvw9c3rh1vt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/26/Linux(%E4%B8%80)/">Linux(一)</a>
          </li>
        
          <li>
            <a href="/2020/09/25/Git/">Git</a>
          </li>
        
          <li>
            <a href="/2020/09/25/%E6%B3%A8%E8%A7%A3/">注解</a>
          </li>
        
          <li>
            <a href="/2020/09/24/%E5%8F%8D%E5%B0%84/">反射</a>
          </li>
        
          <li>
            <a href="/2020/09/24/Stream%E6%B5%81%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/">Stream流、方法引用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 我的笔记<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>